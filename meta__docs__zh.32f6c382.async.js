"use strict";(self.webpackChunk_antv_g_site=self.webpackChunk_antv_g_site||[]).push([[9600],{33117:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(39891);var d={}},3477:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(59984);var d={}},44128:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(99578);var d={}},22608:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(31530);var d={}},8095:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(73706);var d={}},5340:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(39275);var d={}},2456:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(82979);var d={}},60603:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(10141);var d={}},65207:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(40486);var d={}},7686:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(52055);var d={}},5662:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(47787);var d={}},33694:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(31133);var d={}},69943:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(70627);var d={}},67340:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(6174);var d={}},34825:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(77334);var d={}},67690:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(33381);var d={}},97861:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(53926);var d={}},11232:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(24958);var d={}},83348:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(90651);var d={}},43668:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(96838);var d={}},71733:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(37163);var d={}},42489:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(19970);var d={}},522:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(7314);var d={}},66504:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(17395);var d={}},17043:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(86687);var d={}},55495:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(17491);var d={}},19545:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(32897);var d={}},84984:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(82151);var d={}},14282:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(54978);var d={}},32528:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(95296);var d={}},79318:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(53423);var d={}},3389:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(28535);var d={}},2250:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(39246);var d={}},30594:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(7857);var d={}},31121:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(83873);var d={}},99313:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(86863);var d={}},91872:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(58046);var d={}},28750:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(38629);var d={}},4660:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(37248);var d={}},73841:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(92223);var d={}},92373:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(39511);var d={}},19363:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(88038);var d={}},62309:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(62370);var d={}},67449:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(36642);var d={}},30312:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(64342);var d={}},50277:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(5763);var d={}},40334:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(39869);var d={}},96342:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(81507);var d={}},75202:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(66565);var d={}},88763:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(38052);var d={}},47227:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(7426);var d={}},83521:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(97319);var d={}},19295:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(21360);var d={}},7134:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(43115);var d={}},70794:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(60612);var d={}},74298:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(72429);var d={}},52534:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(40584);var d={}},40313:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(41256);var d={}},59476:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(75080);var d={}},23681:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(74199);var d={}},60181:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(67349);var d={}},5879:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(63869);var d={}},74430:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(38564);var d={}},6933:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(15297);var d={}},33776:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(66160);var d={}},31941:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(72032);var d={}},16471:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(35376);var d={}},88837:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(6011);var d={}},20831:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(69979);var d={}},99729:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(75749);var d={}},74030:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(59025);var d={}},11853:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(22867);var d={}},62641:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(69651);var d={}},12467:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(37698);var d={}},40478:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(47622);var d={}},7502:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(75076);var d={}},30287:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(76724);var d={}},32913:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(7805);var d={}},59343:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(97934);var d={}},4071:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(18114);var d={}},81424:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(11481);var d={}},31481:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(55027);var d={}},32066:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(57503);var d={}},90646:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(3259);var d={}},43082:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(58509);var d={}},89673:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(79928);var d={}},63104:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(26824);var d={}},52159:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(98921);var d={}},23517:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(53280);var d={}},67925:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(38177);var d={}},2938:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(11495);var d={}},87502:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(93368);var d={}},16795:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(61436);var d={}},83211:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(83797);var d={}},80612:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(29260);var d={}},79567:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(88622);var d={}},51415:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(21655);var d={}},66727:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(59721);var d={}},99184:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(54887);var d={}},99022:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(7270);var d={}},39515:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(54910);var d={}},24465:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(87801);var d={}},30716:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(81052);var d={}},89601:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(23166);var d={}},34143:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(44859);var d={}},25421:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(68279);var d={}},82552:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(26846);var d={}},74846:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(98783);var d={}},59433:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(97400);var d={}},59658:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(54862);var d={}},87155:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(64746);var d={}},37451:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(17551);var d={}},82791:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(57815);var d={}},30982:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(2195);var d={}},88461:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(88238);var d={}},23792:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(29878);var d={}},9337:function(a,e,n){n.r(e),n.d(e,{demos:function(){return d}});n(67294),n(73826);var d={}},95368:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(39891);const d=[{value:"在 2D 场景中对于整个场景的常见交互有平移、缩放和旋转，通过",paraId:0},{value:"相机",paraId:1},{value:"动作实现。",paraId:0},{value:"例如对场景的平移等价于固定视点，让相机沿 u、v 轴（G 的世界坐标系 Y 轴正向向下）方向移动，也称作 ",paraId:2},{value:"pan",paraId:3},{value:" 相机动作，在具体实现中通过对鼠标 move 系列事件的监听实现，同时由于相机固定为正交投影，视点是否固定并不影响最终成像效果。",paraId:2},{value:"但而在 3D 场景中，同样的鼠标平移动作可能包含不同的语义。例如在模型观察场景中，我们希望固定视点，改变相机位置，而在第一/三人称开放世界中，我们希望固定相机位置，改变视点。",paraId:4},{value:"我们提供了 ",paraId:5},{value:"g-plugin-control",paraId:5},{value:" 插件，目前支持观察者模式，即通过鼠标交互固定视点，改变相机位置：",paraId:5},{value:"鼠标拖拽将引起相机在 u、v 轴的移动，即 pan 动作",paraId:6},{value:"鼠标滚轮缩放将引起相机在 n 轴的移动，即 dolly 动作",paraId:6},{value:"示例",paraId:7},{value:"：",paraId:8},{value:"import { Plugin as PluginControl } from '@antv/g-plugin-control';\n\nrenderer.registerPlugin(new Plugin3D());\n",paraId:9}]},21730:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(59984);const d=[{value:"雾和光源一样，都属于场景级别的对象，距离相机近处的物体能见度较大。",paraId:0},{value:"在下面的 ",paraId:1},{value:"示例",paraId:2},{value:" 中展示了红色的雾，注意远离相机的地方（球体边缘处）：",paraId:1},{value:"const fog = new Fog();\ncanvas.appendChild(fog);\n",paraId:3},{value:"当不需要时可以随时移除：",paraId:4},{value:"canvas.removeChild(fog);\n",paraId:5},{value:"整个场景中只会有一个 Fog 生效，因此添加多个无效。",paraId:6},{value:"颜色，默认值为 ",paraId:7,tocIndex:1},{value:"'black'",paraId:7,tocIndex:1},{value:"类型，支持以下枚举值，默认为 ",paraId:8,tocIndex:2},{value:"FogType.NONE",paraId:8,tocIndex:2},{value:"，即无效果：",paraId:8,tocIndex:2},{value:"export enum FogType {\n  NONE = 0,\n  EXP = 1,\n  EXP2 = 2,\n  LINEAR = 3,\n}\n",paraId:9,tocIndex:2},{value:"效果强度，默认值为 0",paraId:10,tocIndex:3},{value:"type 取 ",paraId:11,tocIndex:4},{value:"FogType.LINEAR",paraId:11,tocIndex:4},{value:" 时生效。最近距离，默认值为 1",paraId:11,tocIndex:4},{value:"type 取 ",paraId:12,tocIndex:5},{value:"FogType.LINEAR",paraId:12,tocIndex:5},{value:" 时生效。最远距离，默认值为 1000",paraId:12,tocIndex:5}]},92432:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(99578);const d=[{value:"再复杂的模型都可以用“三角面”来描述，区别只在于数量多少。因此在 3D 世界中我们用这种描述能力更强的方式定义几何形状，它们可以是我们熟悉的 Circle、Rect，也可以是“犹他茶壶”。",paraId:0},{value:"我们内置了一些常用的几何，例如 Cube、Sphere 等，它们在运行时程序化生成。",paraId:1},{value:"可以随时启用材质的 ",paraId:2},{value:"wireframe",paraId:3},{value:" 属性查看几何中包含的三角面：",paraId:2},{value:"material.wireframe = true;\n",paraId:4},{value:"在该",paraId:5},{value:"示例",paraId:6},{value:"中效果如下，可以看出一个 Sphere 球体是由不同经纬度上的众多三角面组成：",paraId:5},{value:"当我们想修改几何信息时，例如改变一个几何形状为 CubeGeometry 的 Mesh 时，应该在几何而非 Mesh 上操作：",paraId:7,tocIndex:0},{value:"import {\n    MeshBasicMaterial,\n    CubeGeometry,\n    Mesh,\n    Plugin as Plugin3D,\n} from '@antv/g-plugin-3d';\n\n// 创建几何\nconst cubeGeometry = new CubeGeometry(device, {\n    width: 200,\n    height: 200,\n    depth: 200,\n});\n\n// 创建 Mesh\nconst cube = new Mesh({\n    style: {\n        fill: '#1890FF',\n        opacity: 1,\n        geometry: cubeGeometry,\n        material: basicMaterial,\n    },\n});\n\n// 修改这个形状为 Cube 的 Mesh 宽度\n// 正确用法\ncubeGeometry.width = 300;\n// 或者\ncube.style.geometry.width = 300;\n\n// 错误用法\ncube.style.width = 300;\n",paraId:8,tocIndex:0},{value:"立方体，",paraId:9,tocIndex:1},{value:"示例",paraId:10,tocIndex:1},{value:"属性名",paraId:11,tocIndex:1},{value:"说明",paraId:11,tocIndex:1},{value:"width",paraId:11,tocIndex:1},{value:"宽度，必填",paraId:11,tocIndex:1},{value:"height",paraId:11,tocIndex:1},{value:"高度，必填",paraId:11,tocIndex:1},{value:"depth",paraId:11,tocIndex:1},{value:"深度，必填",paraId:11,tocIndex:1},{value:"widthSegments",paraId:11,tocIndex:1},{value:"影响程序化生成，默认值为 1",paraId:11,tocIndex:1},{value:"heightSegments",paraId:11,tocIndex:1},{value:"影响程序化生成，默认值为 1",paraId:11,tocIndex:1},{value:"depthSegments",paraId:11,tocIndex:1},{value:"影响程序化生成，默认值为 1",paraId:11,tocIndex:1},{value:"球体，",paraId:12,tocIndex:2},{value:"示例",paraId:13,tocIndex:2},{value:"属性名",paraId:14,tocIndex:2},{value:"说明",paraId:14,tocIndex:2},{value:"radius",paraId:14,tocIndex:2},{value:"球半径，必填，默认值为 0.5",paraId:14,tocIndex:2},{value:"latitudeBands",paraId:14,tocIndex:2},{value:"默认值为 16",paraId:14,tocIndex:2},{value:"longitudeBands",paraId:14,tocIndex:2},{value:"默认值为 16",paraId:14,tocIndex:2},{value:"平面，默认躺在 XZ 平面上，",paraId:15,tocIndex:3},{value:"示例",paraId:16,tocIndex:3},{value:"属性名",paraId:17,tocIndex:3},{value:"说明",paraId:17,tocIndex:3},{value:"width",paraId:17,tocIndex:3},{value:"宽度",paraId:17,tocIndex:3},{value:"depth",paraId:17,tocIndex:3},{value:"深度",paraId:17,tocIndex:3},{value:"widthSegments",paraId:17,tocIndex:3},{value:"默认值为 5",paraId:17,tocIndex:3},{value:"depthSegments",paraId:17,tocIndex:3},{value:"默认值为 5",paraId:17,tocIndex:3},{value:"圆环，",paraId:18,tocIndex:4},{value:"示例",paraId:19,tocIndex:4},{value:"属性名",paraId:20,tocIndex:4},{value:"说明",paraId:20,tocIndex:4},{value:"tubeRadius",paraId:20,tocIndex:4},{value:"选填，默认值为 0.2",paraId:20,tocIndex:4},{value:"ringRadius",paraId:20,tocIndex:4},{value:"选填，默认值为 0.3",paraId:20,tocIndex:4},{value:"segments",paraId:20,tocIndex:4},{value:"选填，默认值为 30",paraId:20,tocIndex:4},{value:"sides",paraId:20,tocIndex:4},{value:"选填，默认值为 20",paraId:20,tocIndex:4},{value:"圆柱，",paraId:21,tocIndex:5},{value:"示例",paraId:22,tocIndex:5},{value:"属性名",paraId:23,tocIndex:5},{value:"说明",paraId:23,tocIndex:5},{value:"radius",paraId:23,tocIndex:5},{value:"圆柱体顶面半径，默认值为 0.5",paraId:23,tocIndex:5},{value:"height",paraId:23,tocIndex:5},{value:"圆柱体高度，默认值为 1",paraId:23,tocIndex:5},{value:"heightSegments",paraId:23,tocIndex:5},{value:"圆柱体身体曲面划分数目，默认值为 5",paraId:23,tocIndex:5},{value:"capSegments",paraId:23,tocIndex:5},{value:"圆柱体顶面划分数目，默认值为 20",paraId:23,tocIndex:5},{value:"圆锥，",paraId:24,tocIndex:6},{value:"示例",paraId:25,tocIndex:6},{value:"属性名",paraId:26,tocIndex:6},{value:"说明",paraId:26,tocIndex:6},{value:"baseRadius",paraId:26,tocIndex:6},{value:"圆锥体底面半径，默认值为 0.5",paraId:26,tocIndex:6},{value:"peakRadius",paraId:26,tocIndex:6},{value:"圆锥体顶面半径，默认值为 0",paraId:26,tocIndex:6},{value:"height",paraId:26,tocIndex:6},{value:"圆锥体高度，默认值为 1",paraId:26,tocIndex:6},{value:"heightSegments",paraId:26,tocIndex:6},{value:"圆锥体身体曲面划分数目，默认值为 5",paraId:26,tocIndex:6},{value:"capSegments",paraId:26,tocIndex:6},{value:"圆锥体顶面划分数目，默认值为 20",paraId:26,tocIndex:6},{value:"胶囊，",paraId:27,tocIndex:7},{value:"示例",paraId:28,tocIndex:7},{value:"属性名",paraId:29,tocIndex:7},{value:"说明",paraId:29,tocIndex:7},{value:"radius",paraId:29,tocIndex:7},{value:"胶囊半径，默认值为 0.5",paraId:29,tocIndex:7},{value:"height",paraId:29,tocIndex:7},{value:"胶囊高度，默认值为 1",paraId:29,tocIndex:7},{value:"heightSegments",paraId:29,tocIndex:7},{value:"胶囊身体曲面划分数目，默认值为 1",paraId:29,tocIndex:7},{value:"sides",paraId:29,tocIndex:7},{value:"胶囊顶面划分数目，默认值为 20",paraId:29,tocIndex:7},{value:"以上内置几何都继承自 BufferGeometry，因此需要自定义时也可以使用它。",paraId:30,tocIndex:8},{value:"在",paraId:31,tocIndex:8},{value:"示例",paraId:32,tocIndex:8},{value:"中，我们创建了一个完全自定义的几何体，配合 ",paraId:31,tocIndex:8},{value:"Mesh",paraId:33,tocIndex:8},{value:" 和 ",paraId:31,tocIndex:8},{value:"MeshBasicMaterial",paraId:34,tocIndex:8},{value:"：",paraId:31,tocIndex:8},{value:"import { BufferGeometry, MeshBasicMaterial, Mesh } from '@antv/g-plugin-3d';\n\nconst bufferGeometry = new BufferGeometry(device);\nconst basicMaterial = new MeshBasicMaterial(device);\nconst mesh = new Mesh({\n    style: {\n        fill: '#1890FF',\n        opacity: 1,\n        geometry: bufferGeometry,\n        material: basicMaterial,\n    },\n});\n\nbufferGeometry.setVertexBuffer({\n    bufferIndex: 1,\n    byteStride: 4 * 3,\n    stepMode: VertexStepMode.VERTEX,\n    attributes: [\n        {\n            format: Format.F32_RGB,\n            bufferByteOffset: 4 * 0,\n            location: VertexAttributeLocation.POSITION,\n        },\n    ],\n    data: Float32Array.from([\n        -100.0,\n        100.0,\n        100.0, // 顶点1\n        100.0,\n        100.0,\n        100.0, // 顶点2\n        100.0,\n        -100.0,\n        100.0, // 顶点3\n        100.0,\n        -100.0,\n        100.0, // 顶点4\n        -100.0,\n        -100.0,\n        100.0, // 顶点5\n        -100.0,\n        100.0,\n        100.0, // 顶点6\n    ]),\n});\nbufferGeometry.vertexCount = 6;\n",paraId:35,tocIndex:8},{value:"设置需要绘制的顶点数目，默认全部绘制，后续可以随时修改。",paraId:36,tocIndex:9},{value:"geometry.vertexCount = 10;\n",paraId:37,tocIndex:9},{value:"在 instanced 模式下，绘制的实例数目。",paraId:38,tocIndex:10},{value:"geometry.instancedCount = 10;\n",paraId:39,tocIndex:10},{value:"使用索引数组（drawElements）绘制时的起始位置，默认为 0。",paraId:40,tocIndex:11},{value:"geometry.indexStart = 3;\n",paraId:41,tocIndex:11},{value:"使用非索引数组（drawArrays）绘制时的起始位置，默认为 0。",paraId:42,tocIndex:12},{value:"geometry.primitiveStart = 3;\n",paraId:43,tocIndex:12},{value:"设置索引数组。",paraId:44,tocIndex:14},{value:"参数列表：",paraId:45,tocIndex:14},{value:"indices ",paraId:46,tocIndex:14},{value:"number[] | Int32Array | Uint32Array | Uint16Array",paraId:46,tocIndex:14},{value:" 索引数组",paraId:46,tocIndex:14},{value:"例如在内置程序化生成的几何中，最终都会设置索引数组：",paraId:47,tocIndex:14},{value:"geometry.setIndices(new Uint32Array(indices));\n",paraId:48,tocIndex:14},{value:"设置顶点数组。",paraId:49,tocIndex:15},{value:"参数列表：",paraId:50,tocIndex:15},{value:"descriptor ",paraId:51,tocIndex:15},{value:"GeometryVertexBufferDescriptor",paraId:51,tocIndex:15},{value:" 顶点描述符",paraId:51,tocIndex:15},{value:"其中描述符结构如下：",paraId:52,tocIndex:15},{value:"bufferIndex 索引",paraId:53,tocIndex:15},{value:"byteStride stride 长度（以 byte 为单位）",paraId:53,tocIndex:15},{value:"stepMode 支持 vertex 和 instance 两种",paraId:53,tocIndex:15},{value:"attributes 支持 interleave，其中每个属性包括：\n",paraId:53,tocIndex:15},{value:"format 对应 Shader 中的数据类型",paraId:54,tocIndex:15},{value:"bufferByteOffset 在 stride 中的偏移量",paraId:54,tocIndex:15},{value:"byteStride 属性长度",paraId:54,tocIndex:15},{value:"location 与 Shader 中 location 对应",paraId:54,tocIndex:15},{value:"divisor 选择 instance 模式后生效",paraId:54,tocIndex:15},{value:"data 数据",paraId:53,tocIndex:15},{value:"export interface GeometryVertexBufferDescriptor {\n    bufferIndex: number;\n    byteStride: number;\n    stepMode: VertexStepMode;\n    attributes: Array<{\n        format: Format,\n        bufferByteOffset: number,\n        byteStride?: number,\n        location: number,\n        divisor?: number,\n    }>;\n    data: ArrayBufferView;\n}\n",paraId:55,tocIndex:15},{value:"例如在 Vertex Shader 中声明了如下顶点属性：",paraId:56,tocIndex:15},{value:"layout(location = 10) attribute vec3 a_Position;\n",paraId:57,tocIndex:15},{value:"在不使用 interleave 的情况下，数组中仅包含位置属性：",paraId:58,tocIndex:15},{value:"geometry.setVertexBuffer({\n    bufferIndex: ProceduralGeometryAttributeLocation.POSITION,\n    byteStride: 4 * 3,\n    stepMode: VertexStepMode.VERTEX,\n    attributes: [\n        {\n            format: Format.F32_RGB, // 与 vec3 对应\n            bufferByteOffset: 4 * 0,\n            location: VertexAttributeLocation.POSITION, // 与 location 对应\n        },\n    ],\n    data: Float32Array.from(positions),\n});\n",paraId:59,tocIndex:15},{value:"在初始化之后，顶点数据有时也需要修改。",paraId:60,tocIndex:16},{value:"例如更新上面的位置属性时，首先通过 ",paraId:61,tocIndex:16},{value:"bufferIndex",paraId:61,tocIndex:16},{value:" 定位到具体 Buffer，再通过 ",paraId:61,tocIndex:16},{value:"bufferByteOffset",paraId:61,tocIndex:16},{value:" 指定偏移量，最后更新部分或者全部数据：",paraId:61,tocIndex:16},{value:"geometry.updateVertexBuffer(\n    ProceduralGeometryAttributeLocation.POSITION,\n    VertexAttributeLocation.MAX,\n    0,\n    new Uint8Array(positions.buffer),\n);\n",paraId:62,tocIndex:16},{value:"对程序化生成的几何应用变换矩阵。由于 G 的坐标系 Y 轴正向向下，因此在生成后需要进行 Y 轴翻转。该方法对位置、法线应用变换。",paraId:63,tocIndex:17},{value:"参数列表：",paraId:64,tocIndex:17},{value:"matrix ",paraId:65,tocIndex:17},{value:"mat4",paraId:65,tocIndex:17},{value:" 变换矩阵",paraId:65,tocIndex:17},{value:"geometry.applyMat4(mat4.fromScaling(mat4.create(), vec3.fromValues(1, -1, 1)));\n",paraId:66,tocIndex:17}]},99255:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(31530);const d=[{value:"材质",paraId:0},{value:"需要配合光源呈现出某种“立体感”。",paraId:1},{value:"日常生活中的光源有很多，太阳、台灯、手电筒。它们需要被抽象成可参数化描述的光源。",paraId:2},{value:"例如太阳可以看作是“平行光”，它通过颜色、强度、方向来描述。通常光源是作用于整个场景的，因此在具体使用渲染引擎时，会将它添加到场景 / 画布上，以 G 为例：",paraId:3},{value:"import { DirectionalLight } from '@antv/g-plugin-3d';\n// 创建一个平行光\nconst light = new DirectionalLight({\n    style: {\n        fill: 'white',\n        direction: [-1, 0, 1],\n    },\n});\n// 加入画布\ncanvas.appendChild(light);\n",paraId:4},{value:"对于某些光源来说，在世界坐标系下的位置是有意义的，当我们想移动光源时，和其他 2D 图形完全一致：",paraId:5},{value:"light.translate();\nlight.setPosition();\n",paraId:6},{value:"我们复用 G 中基础图形的部分样式属性，不同光源也有独有的属性。例如我们可以随时改变一个光源的颜色：",paraId:7,tocIndex:0},{value:"light.style.fill = 'red';\n",paraId:8,tocIndex:0},{value:"光源颜色",paraId:9,tocIndex:1},{value:"光照强度，默认为 ",paraId:10,tocIndex:2},{value:"Math.PI",paraId:10,tocIndex:2},{value:"世界坐标系下的方向，类型为 ",paraId:11,tocIndex:5},{value:"[number, number, number]",paraId:11,tocIndex:5},{value:"。",paraId:11,tocIndex:5},{value:"示例",paraId:12,tocIndex:5},{value:"light.style.direction = [-1, 0, 1];\n",paraId:13,tocIndex:5},{value:"严格意义上讲这并不是一种光源，它是一种简单模拟全局光照的手段。当我们想提亮整个场景时，可以使用它。",paraId:14,tocIndex:8},{value:"示例",paraId:15,tocIndex:8},{value:"import { AmbientLight } from '@antv/g-plugin-3d';\nconst ambientLight = new AmbientLight({\n    style: {\n        fill: 'white',\n    },\n});\ncanvas.appendChild(ambientLight);\n",paraId:16,tocIndex:8}]},5303:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(73706);const d=[{value:"不同于 2D 场景下我们用“填充色”、“描边色”、“透明度”等属性描述图形的外观，3D 场景由于需要营造某种“立体感”甚至是“真实感”，需要更为强大、复杂的描述能力，通常称之为“材质” Material。",paraId:0},{value:"材质定义了渲染 API 的一些全局状态（例如 OpenGL / WebGL 中的 Blend、深度测试、模版测试等）以及 Shader。其中 Shader 通过程序定义了该材质对于光照的“反应”。",paraId:1},{value:"我们知道人眼之所以能看到物体，是由于光线经过场景中一系列复杂的传播，由各种不同的物体表面反射进入人眼。最简单的材质当然是无视“光照”，它呈现出类似 2D 图形的质感，Three.js 中称作 “MeshBasicMaterial”。另一个极端当然是追求极致的“真实感”，也称作 PBR（Physically based rendering），在绝大多数游戏级别的渲染引擎中你都能看到它。在我们熟悉的可视化场景中通常使用介于两者之间的光照模型，它既能看出一定的立体感，又不需要追求极度的真实，Phong 模型就符合这样的要求。",paraId:2},{value:"当然除了内置的材质，也可以通过 ShaderMaterial 这种完全自定义的方式使用。",paraId:3},{value:"在",paraId:4},{value:"示例",paraId:5},{value:"中，我们使用 ",paraId:4},{value:"Mesh",paraId:6},{value:" 创建了一个球体，它的几何形体由 ",paraId:4},{value:"Geometry",paraId:7},{value:" 定义，而外观由 ",paraId:4},{value:"MeshPhongMaterial",paraId:8},{value:" 决定。可以看到它的很多用法和 2D 基础图形完全一样，例如添加到画布、变换等：",paraId:4},{value:"import {\n    MeshPhongMaterial,\n    SphereGeometry,\n    DirectionalLight,\n    Mesh,\n    Plugin as Plugin3D,\n} from '@antv/g-plugin-3d';\n\n// 等待画布初始化完成\nawait canvas.ready;\n// 获取 GPU Device\nconst plugin = renderer.getPlugin('device-renderer');\nconst device = plugin.getDevice();\n\nconst sphereGeometry = new SphereGeometry(device, {\n    radius: 200,\n});\nconst material = new MeshPhongMaterial(device, {\n    map: 'https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*npAsSLPX4A4AAAAAAAAAAAAAARQnAQ',\n    // 省略其他参数,\n});\n\n// 创建一个 Mesh\nconst sphere = new Mesh({\n    style: {\n        x: 300, // 设置局部坐标系下的位置\n        y: 250,\n        z: 0, // z 轴坐标\n        fill: '#1890FF',\n        opacity: 1,\n        geometry: sphereGeometry,\n        material,\n    },\n});\n// 添加到画布\ncanvas.appendChild(sphere);\n",paraId:9},{value:"我们可以随时修改以下属性，例如：",paraId:10,tocIndex:0},{value:"material.wireframe = true;\nmaterial.cullMode = CullMode.BACK;\n",paraId:11,tocIndex:0},{value:"使用 GLSL 300 语法编写的 Shader 字符串。",paraId:12,tocIndex:1},{value:"使用 GLSL 300 语法编写的 Shader 字符串。",paraId:13,tocIndex:2},{value:"是否绘制 wireframe，常用于直观展示三角面。开启后将额外生成重心坐标，原理详见 ",paraId:14,tocIndex:3},{value:"https://zhuanlan.zhihu.com/p/48499247",paraId:14,tocIndex:3},{value:"。",paraId:14,tocIndex:3},{value:"const basicMaterial = new MeshBasicMaterial({\n    wireframe: true,\n    map: 'https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*_aqoS73Se3sAAAAAAAAAAAAAARQnAQ',\n});\n",paraId:15,tocIndex:3},{value:"开启 wireframe 后可指定颜色，默认为 ",paraId:16,tocIndex:4},{value:"'black'",paraId:16,tocIndex:4},{value:"。",paraId:16,tocIndex:4},{value:"开启 wireframe 后可指定线宽，默认为 1。",paraId:17,tocIndex:5},{value:"支持以下枚举值，默认使用 ",paraId:18,tocIndex:6},{value:"CullMode.NONE",paraId:18,tocIndex:6},{value:"，即不开启背面剔除：",paraId:18,tocIndex:6},{value:"export enum CullMode {\n  None,\n  Front,\n  Back,\n  FrontAndBack,\n}\n",paraId:19,tocIndex:6},{value:"默认使用 ",paraId:20,tocIndex:7},{value:"FrontFace.CCW",paraId:20,tocIndex:7},{value:"，即逆时针方向作为正面 winding order：",paraId:20,tocIndex:7},{value:"export enum FrontFace {\n  CCW = GL.CCW,\n  CW = GL.CW,\n}\n",paraId:21,tocIndex:7},{value:"是否开启深度测试，默认开启。",paraId:22,tocIndex:8},{value:"默认使用 ",paraId:23,tocIndex:9},{value:"CompareMode.LessEqual",paraId:23,tocIndex:9},{value:"，不同于 WebGL 的默认值 ",paraId:23,tocIndex:9},{value:"CompareMode.Less",paraId:23,tocIndex:9},{value:"：",paraId:23,tocIndex:9},{value:"export enum CompareMode {\n  Never = GL.NEVER,\n  Less = GL.LESS,\n  Equal = GL.EQUAL,\n  LessEqual = GL.LEQUAL,\n  Greater = GL.GREATER,\n  NotEqual = GL.NOTEQUAL,\n  GreaterEqual = GL.GEQUAL,\n  Always = GL.ALWAYS,\n}\n",paraId:24,tocIndex:9},{value:"是否开启模版测试，默认不开启。",paraId:25,tocIndex:10},{value:"compare 默认使用 ",paraId:26,tocIndex:11},{value:"CompareMode.Never",paraId:26,tocIndex:11},{value:"，枚举值同 ",paraId:26,tocIndex:11},{value:"depthCompare",paraId:26,tocIndex:11},{value:"。",paraId:26,tocIndex:11},{value:"passOp 默认使用 ",paraId:26,tocIndex:11},{value:"StencilOp.Keep",paraId:26,tocIndex:11},{value:"，支持以下枚举值：",paraId:26,tocIndex:11},{value:"export enum StencilOp {\n  Keep = GL.KEEP,\n  Zero = GL.ZERO,\n  Replace = GL.REPLACE,\n  Invert = GL.INVERT,\n  IncrementClamp = GL.INCR,\n  DecrementClamp = GL.DECR,\n  IncrementWrap = GL.INCR_WRAP,\n  DecrementWrap = GL.DECR_WRAP,\n}\n",paraId:27,tocIndex:11},{value:"混合模式支持以下枚举值：",paraId:28,tocIndex:12},{value:"export enum BlendMode {\n  Add = GL.FUNC_ADD,\n  Subtract = GL.FUNC_SUBTRACT,\n  ReverseSubtract = GL.FUNC_REVERSE_SUBTRACT,\n}\n",paraId:29,tocIndex:12},{value:"枚举值同 blendEquation",paraId:30,tocIndex:13},{value:"export enum BlendFactor {\n  Zero = GL.ZERO,\n  One = GL.ONE,\n  Src = GL.SRC_COLOR,\n  OneMinusSrc = GL.ONE_MINUS_SRC_COLOR,\n  Dst = GL.DST_COLOR,\n  OneMinusDst = GL.ONE_MINUS_DST_COLOR,\n  SrcAlpha = GL.SRC_ALPHA,\n  OneMinusSrcAlpha = GL.ONE_MINUS_SRC_ALPHA,\n  DstAlpha = GL.DST_ALPHA,\n  OneMinusDstAlpha = GL.ONE_MINUS_DST_ALPHA,\n}\n",paraId:31,tocIndex:14},{value:"枚举值同 blendSrc",paraId:32,tocIndex:15},{value:"枚举值同 blendSrc",paraId:33,tocIndex:16},{value:"枚举值同 blendSrc",paraId:34,tocIndex:17},{value:"添加一组 Uniform，需要与 Shader 中声明的变量类型匹配。",paraId:35,tocIndex:19},{value:"参数列表：",paraId:36,tocIndex:19},{value:"uniforms: ",paraId:37,tocIndex:19},{value:"Record<string, number | number[] | Texture>",paraId:37,tocIndex:19},{value:"例如 MeshPhongMaterial 在初始化时会添加如下：",paraId:38,tocIndex:19},{value:"material.setUniform({\n    u_Specular: [0, 0, 0],\n    u_BumpScale: 5,\n    u_Map: mapTexture,\n});\n",paraId:39,tocIndex:19},{value:"对应 Shader 中的 Uniform 声明，例如 ",paraId:40,tocIndex:19},{value:"u_Specular",paraId:40,tocIndex:19},{value:" 的类型为 ",paraId:40,tocIndex:19},{value:"vec3",paraId:40,tocIndex:19},{value:"，在设置时就需要使用长度为 3 的数组进行赋值：",paraId:40,tocIndex:19},{value:"layout(std140) uniform ub_MaterialParams {\n  vec3 u_Specular;\n  float u_BumpScale;\n};\n\nuniform sampler2D u_Map;\n",paraId:41,tocIndex:19},{value:"一个特殊的情况是纹理，例如上面的例子中 ",paraId:42,tocIndex:20},{value:"u_Map",paraId:42,tocIndex:20},{value:" 为采样器，在设置时就需要使用纹理：",paraId:42,tocIndex:20},{value:"const mapTexture = plugin.loadTexture(\n    'https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*_aqoS73Se3sAAAAAAAAAAAAAARQnAQ',\n);\nmaterial.setUniform({\n    u_Map: mapTexture,\n});\n",paraId:43,tocIndex:20},{value:"例如我们为平行光定义了如下结构体：",paraId:44,tocIndex:21},{value:"struct DirectionalLight {\n  vec3 direction;\n  float intensity;\n  vec3 color;\n};\n",paraId:45,tocIndex:21},{value:"一种特殊情况是结构体数组，例如在 Shader 中声明了一个平行光数组：",paraId:46,tocIndex:21},{value:"DirectionalLight directionalLights[NUM_DIR_LIGHTS];\n",paraId:47,tocIndex:21},{value:"当我们想给数组中第一个元素赋值时：",paraId:48,tocIndex:21},{value:"material.setUniform({\n    'directionalLights[0].direction': [0, 0, 0],\n    'directionalLights[0].color': [0, 0, 0],\n});\n",paraId:49,tocIndex:21},{value:"使用 Point 原语绘制。",paraId:50,tocIndex:23},{value:"示例",paraId:51,tocIndex:23},{value:"默认值为 1。例如 WebGL 有最大值限制 ",paraId:52,tocIndex:24},{value:"gl.ALIASED_POINT_SIZE_RANGE",paraId:52,tocIndex:24},{value:"。",paraId:52,tocIndex:24},{value:"贴图。",paraId:53,tocIndex:25},{value:"和 Three.js 保持一致：",paraId:54,tocIndex:26},{value:"https://threejs.org/docs/#api/en/materials/MeshBasicMaterial",paraId:54,tocIndex:26},{value:"该材质不受光照影响，从 FragmentShader 可以看出直接使用 fill 定义的颜色或者 map 定义的贴图：",paraId:55,tocIndex:26},{value:"// material.basic.frag\n\n// 公共的 Uniform 定义\n#pragma glslify: import('@antv/g-shader-components/scene.both.glsl')\n#pragma glslify: import('@antv/g-shader-components/material.both.glsl')\n\n#pragma glslify: import('@antv/g-shader-components/batch.declaration.frag')\n#pragma glslify: import('@antv/g-shader-components/uv.declaration.frag')\n#pragma glslify: import('@antv/g-shader-components/map.declaration.frag')\n#pragma glslify: import('@antv/g-shader-components/wireframe.declaration.frag')\n#pragma glslify: import('@antv/g-shader-components/fog.declaration.frag')\n\nvoid main() {\n  // 通用属性，例如 fill opacity\n  #pragma glslify: import('@antv/g-shader-components/batch.frag')\n  // 贴图\n  #pragma glslify: import('@antv/g-shader-components/map.frag')\n\n  gbuf_color = u_Color;\n  gbuf_color.a = gbuf_color.a * u_Opacity;\n\n  // 绘制 wireframe\n  #pragma glslify: import('@antv/g-shader-components/wireframe.frag')\n  // 场景雾\n  #pragma glslify: import('@antv/g-shader-components/fog.frag')\n}\n",paraId:56,tocIndex:26},{value:"漫反射贴图，例如：",paraId:57,tocIndex:27},{value:"const map = plugin.loadTexture(\n    'https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*_aqoS73Se3sAAAAAAAAAAAAAARQnAQ',\n);\nconst basicMaterial = new MeshBasicMaterial({\n    map,\n});\n",paraId:58,tocIndex:27},{value:"继承自 MeshBasicMaterial，使用 Lambertian 模型，无高光。",paraId:59,tocIndex:28},{value:"自发光颜色。",paraId:60,tocIndex:29},{value:"继承自 MeshBasicMaterial，使用 Blinn-Phong 光照模型。",paraId:61,tocIndex:30},{value:"在多伦多大学的某教学页面上可以看到 Phong 模型的一个基础实现： ",paraId:62,tocIndex:30},{value:"http://www.cs.toronto.edu/~jacobson/phong-demo/",paraId:62,tocIndex:30},{value:"该模型将直接光照部分“漫反射”、高光与间接光照部分“环境光”累加，得出最终的贡献值。从下图中我们能看到物体表面的法线、光源到物体表面的入射方向，以及人眼（相机）的观察方向都需要考虑。",paraId:63,tocIndex:30},{value:"下图为实际渲染效果：",paraId:64,tocIndex:30},{value:"以下参数可以在该",paraId:65,tocIndex:30},{value:"示例",paraId:66,tocIndex:30},{value:"中调整。",paraId:65,tocIndex:30},{value:"自发光颜色。",paraId:67,tocIndex:31},{value:"高光颜色。",paraId:68,tocIndex:32},{value:"高光贴图。例如",paraId:69,tocIndex:33},{value:"示例",paraId:70,tocIndex:33},{value:"中使用的：",paraId:69,tocIndex:33},{value:"高光闪亮程度",paraId:71,tocIndex:34},{value:"凹凸贴图，用于干扰法线。例如",paraId:72,tocIndex:35},{value:"示例",paraId:73,tocIndex:35},{value:"中使用的：",paraId:72,tocIndex:35},{value:"凹凸贴图影响程度。",paraId:74,tocIndex:36},{value:"自定义材质，其中 vertex/fragmentShader 需要指定：",paraId:75,tocIndex:37},{value:"const shaderMaterial = new ShaderMaterial(device, {\n    vertexShader: ``,\n    fragmentShader: ``,\n});\n",paraId:76,tocIndex:37},{value:"考虑到渲染性能，在使用过程中应该尽可能少地创建材质。特别是在可视化场景下，完全可以做到大量图形共享同一个材质：",paraId:77,tocIndex:39},{value:"// 创建共享材质\nconst material = new MeshBasicMaterial();\n\n// 1k 个 Mesh 共享\nfor (let i = 0; i < 1000; i++) {\n    const mesh = new Mesh({\n        style: {\n            // 省略其他样式属性\n            material,\n        },\n    });\n}\n",paraId:78,tocIndex:39},{value:"我们尝试解决以下问题：",paraId:79,tocIndex:40},{value:"一套 Shader 适应不同渲染 API，例如 WebGL 1/2、WebGPU",paraId:80,tocIndex:40},{value:"Shader 开发体验，例如编辑器的高亮、智能提示",paraId:80,tocIndex:40},{value:"模块化，即 Shader chunks 的复用",paraId:80,tocIndex:40},{value:"在 Shader 语言上我们选择 WebGL 2 使用的 GLSL 300，通过运行时简单字符串替换完成对 WebGL 1 使用的 GLSL 100 的兼容。同时使用 Rust 社区的 naga（打包成 wasm 形式）完成在运行时从 GLSL 到 WGSL 的转译，以支持 WebGPU。",paraId:81,tocIndex:41},{value:"例如下面展示了对于 UBO 从 GLSL 300 到 WGSL 的转译：",paraId:82,tocIndex:41},{value:"// GLSL\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n};\n\n// WGSL\n[[block]]\nstruct ub_SceneParams {\n    u_ProjectionMatrix: mat4x4<f32>;\n    u_ViewMatrix: mat4x4<f32>;\n    u_CameraPosition: vec3<f32>;\n    u_DevicePixelRatio: f32;\n};\n",paraId:83,tocIndex:41},{value:"很多引擎使用模版字符串存放 Shader 代码，例如 Three.js、Clay.gl 等：",paraId:84,tocIndex:42},{value:"// https://github.com/mrdoob/three.js/blob/e1ead8c5c2/src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl.js\nexport default /* glsl */ `\n#ifdef USE_ALPHAMAP\n diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n`;\n",paraId:85,tocIndex:42},{value:"好处是无需额外的构建工具 loader/插件，坏处就是丧失了语法高亮，在 Shader 开发时容易犯错。我们希望使用编辑器的高亮以及 Lint，例如配合 VS Code GLSL Lint 插件。因此 shader 需要以 *.glsl/vert/frag 形式存在，使用时以文本形式引入：",paraId:86,tocIndex:42},{value:"// 引入文本字符串\nimport vert from './xxx.vert';\nimport frag from './xxx.frag';\n",paraId:87,tocIndex:42},{value:"可以使用构建工具的插件/ loader 实现，例如：",paraId:88,tocIndex:42},{value:"babel-inline-import",paraId:89,tocIndex:42},{value:"webpack raw-loader",paraId:89,tocIndex:42},{value:"我们希望使用同一个构建工具打 esm / cjs / umd，另外考虑到 wasm，最终选择 rollup-plugin-glslify，并且这个插件还有另一个好处。",paraId:90,tocIndex:42},{value:"如何组织 shader chunks 是一个很麻烦的问题，总有需要复用的代码片段。",paraId:91,tocIndex:43},{value:"Babylon.js 会使用预编译指令，自行完成片段 / 占位符的引入，但这发生在运行时：",paraId:92,tocIndex:43},{value:"#include<clipPlaneFragmentDeclaration>\n\nuniform vec4 color;\n\nvoid main(void) {\n  #include<clipPlaneFragment>\n gbuf_color = color;\n}\n",paraId:93,tocIndex:43},{value:"在构建时完成替换可以省掉 compiler 代码，现成的方案是 glslify，但需要配合构建工具，例如：",paraId:94,tocIndex:43},{value:"webpack ",paraId:95,tocIndex:43},{value:"https://github.com/glslify/glslify-loader",paraId:95,tocIndex:43},{value:"babel ",paraId:95,tocIndex:43},{value:"https://github.com/onnovisser/babel-plugin-glsl",paraId:95,tocIndex:43},{value:"rollup rollup-plugin-glslify 我们选择它",paraId:95,tocIndex:43},{value:"// main.frag\n#pragma glslify: import('./common.glsl')\n\nvoid main() {\n  gbuf_color = vec4(color, 1.0);\n}\n",paraId:96,tocIndex:43},{value:"但问题是会增大包体积，毕竟共用的 chunk 都内联在每个内置 Shader 字符串中了。",paraId:97,tocIndex:43},{value:"参考 stack.gl 建立的一系列 shader components：",paraId:98,tocIndex:43},{value:"https://github.com/glslify/glsl-easings",paraId:98,tocIndex:43},{value:" 我们也提供一个 ",paraId:98,tocIndex:43},{value:"@antv/g-shader-components",paraId:98,tocIndex:43},{value:" 包提供内置的所有 chunks。",paraId:98,tocIndex:43},{value:"Shader 代码中多余的空格、换行、注释最好压缩掉，因为经过上述基于 glslify 的构建流程后，它们都包含在字符串中：",paraId:99,tocIndex:44},{value:"// index.esm.js\nvar vert$1 = '#define GLSLIFY 1\\n#define PI 3.1415926535...';\n",paraId:100,tocIndex:44}]},57754:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(39275);const d=[{value:"在 3D 场景中 Mesh 的描述能力是最强大的，需要配合 ",paraId:0},{value:"Geometry",paraId:1},{value:" 和 ",paraId:0},{value:"Material",paraId:2},{value:" 使用。",paraId:0},{value:"import {\n    MeshPhongMaterial,\n    SphereGeometry,\n    DirectionalLight,\n    Mesh,\n    Plugin as Plugin3D,\n} from '@antv/g-plugin-3d';\n\nconst sphereGeometry = new SphereGeometry(device, {\n    radius: 200,\n});\nconst material = new MeshPhongMaterial(device, {\n    map: 'https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*npAsSLPX4A4AAAAAAAAAAAAAARQnAQ',\n    // 省略其他参数,\n});\n\n// 创建一个 Mesh\nconst sphere = new Mesh({\n    style: {\n        x: 300, // 设置局部坐标系下的位置\n        y: 250,\n        z: 0, // z 轴坐标\n        fill: '#1890FF',\n        opacity: 1,\n        geometry: sphereGeometry,\n        material,\n    },\n});\n// 添加到画布\ncanvas.appendChild(sphere);\n",paraId:3},{value:"我们复用 2D 图形的部分样式属性名。",paraId:4,tocIndex:0},{value:"填充色",paraId:5,tocIndex:1},{value:"透明度",paraId:6,tocIndex:2},{value:"局部坐标系下 Z 轴坐标",paraId:7,tocIndex:3},{value:"和 2D 图形一样，简单推广到 3D 即可。例如平移、缩放、旋转：",paraId:8,tocIndex:4},{value:"mesh.translate(0, 0, 0);\nmesh.setPosition(0, 0, 0);\nmesh.translateLocal(0, 0, 0);\nmesh.setLocalPosition(0, 0, 0);\n\nmesh.scale(1, 1, 1);\nmesh.scaleLocal(1, 1, 1);\nmesh.setLocalScale(1, 1, 1);\n\n// 绕 Y 轴逆时针方向旋转\nmesh.rotate(0, 0.1, 0);\n",paraId:9,tocIndex:4},{value:"轴对齐包围盒也从 2D 的矩形推广到 3D 中的立方体：",paraId:10,tocIndex:5},{value:"const bounds = mesh.getBounds();\n// { center: [0, 0, 0], halfExtents: [100, 100, 100] }\n",paraId:11,tocIndex:5}]},34257:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(82979);const d=[{value:"除了使用 ",paraId:0},{value:"Web Animations API",paraId:1},{value:" 描述动画，我们还支持播放 ",paraId:0},{value:"Lottie",paraId:0},{value:" 格式，为此我们提供了一个类似 ",paraId:0},{value:"lottie-web",paraId:0},{value:" 的播放器。在内部我们会将其中定义的图形和关键帧动画转换成我们的",paraId:0},{value:"基础图形",paraId:2},{value:" 和动画描述，同时提供简单的动画控制方法例如播放、暂停以及跳转到指定时刻或帧，加入到画布后就可以像基础图形一样任意操作它们。",paraId:0},{value:"示例",paraId:3},{value:"首先安装播放器：",paraId:4,tocIndex:0},{value:"npm install @antv/g-lottie-player --save\n",paraId:5,tocIndex:0},{value:"然后使用播放器提供的 ",paraId:6,tocIndex:0},{value:"loadAnimation",paraId:7,tocIndex:0},{value:" 方法创建一个 ",paraId:6,tocIndex:0},{value:"LottieAnimation",paraId:8,tocIndex:0},{value:" 对象，传入 Lottie JSON：",paraId:6,tocIndex:0},{value:"import { loadAnimation } from '@antv/g-lottie-player';\n\nconst ballAnimation = loadAnimation(bouncy_ball, { loop: true });\n",paraId:9,tocIndex:0},{value:"最后在合适的时机渲染到画布：",paraId:10,tocIndex:0},{value:"canvas.addEventListener(CanvasEvent.READY, () => {\n    const wrapper = ballAnimation.render(canvas);\n});\n",paraId:11,tocIndex:0},{value:"参考 ",paraId:12,tocIndex:1},{value:"lottie-web",paraId:12,tocIndex:1},{value:" 的同名方法，用于加载 Lottie 文件创建 ",paraId:12,tocIndex:1},{value:"LottieAnimation",paraId:13,tocIndex:1},{value:"。",paraId:12,tocIndex:1},{value:"参数如下：",paraId:14,tocIndex:1},{value:"data",paraId:15,tocIndex:1},{value:" Lottie JSON",paraId:15,tocIndex:1},{value:"options",paraId:15,tocIndex:1},{value:" 配置项\n",paraId:15,tocIndex:1},{value:"loop",paraId:16,tocIndex:1},{value:" 类型为 ",paraId:16,tocIndex:1},{value:"boolean | number",paraId:16,tocIndex:1},{value:"。是否开启循环播放，默认值为 ",paraId:16,tocIndex:1},{value:"true",paraId:16,tocIndex:1},{value:" 即无限循环。当传入 ",paraId:16,tocIndex:1},{value:"number",paraId:16,tocIndex:1},{value:" 时代表循环次数。",paraId:16,tocIndex:1},{value:"autoplay",paraId:16,tocIndex:1},{value:" 类型为 ",paraId:16,tocIndex:1},{value:"boolean",paraId:16,tocIndex:1},{value:"。加载完成后立刻开始自动播放，默认值为 ",paraId:16,tocIndex:1},{value:"false",paraId:16,tocIndex:1},{value:"例如创建一个无限循环、立即播放的动画：",paraId:17,tocIndex:1},{value:"import { loadAnimation } from '@antv/g-lottie-player';\n\nconst ballAnimation = loadAnimation(bouncy_ball, {\n    loop: true,\n    autoplay: true,\n});\n",paraId:18,tocIndex:1},{value:"通过 ",paraId:19,tocIndex:2},{value:"loadAnimation",paraId:20,tocIndex:2},{value:" 可以创建该对象，进而对动画过程进行控制。",paraId:19,tocIndex:2},{value:"渲染到",paraId:21,tocIndex:3},{value:"画布",paraId:22,tocIndex:3},{value:"并返回一个 ",paraId:21,tocIndex:3},{value:"Group",paraId:23,tocIndex:3},{value:" 作为容器，添加到画布或者任意已挂载的元素下，随后可以对其进行变换：",paraId:21,tocIndex:3},{value:"const wrapper = animation.render(canvas);\n\nwrapper.scale(0.5);\nwrapper.translate(100, 100);\n",paraId:24,tocIndex:3},{value:"支持传入以下两种参数：",paraId:25,tocIndex:3},{value:"画布。此时会添加到画布根节点下",paraId:26,tocIndex:3},{value:"任意已添加到画布中的元素",paraId:26,tocIndex:3},{value:"值得注意的是，和动画一样需要在",paraId:27,tocIndex:3},{value:"画布初始化完成后",paraId:28,tocIndex:3},{value:"进行。",paraId:27,tocIndex:3},{value:"开始播放",paraId:29,tocIndex:4},{value:"animation.play();\n",paraId:30,tocIndex:4},{value:"暂停播放",paraId:31,tocIndex:5},{value:"animation.pause();\n",paraId:32,tocIndex:5},{value:"如果正在播放则暂停，反之亦然",paraId:33,tocIndex:6},{value:"animation.togglePause();\n",paraId:34,tocIndex:6},{value:"结束播放",paraId:35,tocIndex:7},{value:"animation.stop();\n",paraId:36,tocIndex:7},{value:"跳转到指定时刻或帧。",paraId:37,tocIndex:8},{value:"参数如下：",paraId:38,tocIndex:8},{value:"value",paraId:39,tocIndex:8},{value:" 指定秒时刻或者帧数",paraId:39,tocIndex:8},{value:"isFrame",paraId:39,tocIndex:8},{value:" 表示 ",paraId:39,tocIndex:8},{value:"value",paraId:39,tocIndex:8},{value:" 是否传入的是帧数，默认值为 ",paraId:39,tocIndex:8},{value:"false",paraId:39,tocIndex:8},{value:"// 跳转到时间轴的 2s 时刻\nanimation.goTo(2);\n\n// 跳转到第 10 帧\nanimation.goTo(10, true);\n",paraId:40,tocIndex:8},{value:"从指定的帧范围开始播放动画。",paraId:41,tocIndex:9},{value:"参数如下：",paraId:42,tocIndex:9},{value:"segments",paraId:43,tocIndex:9},{value:" ",paraId:43,tocIndex:9},{value:"[number, number]",paraId:43,tocIndex:9},{value:" 指定起始和终止帧范围",paraId:43,tocIndex:9},{value:"animation.playSegments([firstFrame, lastFrame]);\n",paraId:44,tocIndex:9},{value:"获取每秒的帧数。",paraId:45,tocIndex:10},{value:"animation.fps(); // 25\n",paraId:46,tocIndex:10},{value:"返回持续时间，以秒或者帧为单位。",paraId:47,tocIndex:11},{value:"参数如下：",paraId:48,tocIndex:11},{value:"inFrames",paraId:49,tocIndex:11},{value:" 是否以帧为单位，默认为 ",paraId:49,tocIndex:11},{value:"false",paraId:49,tocIndex:11},{value:"animation.getDuration(); // 2\nanimation.getDuration(true); // 120\n",paraId:50,tocIndex:11},{value:"两者的换算关系为：",paraId:51,tocIndex:11},{value:"const durationInSeconds = animation.getDuration();\nconst durationInFrames = animation.getDuration(true);\n\ndurationInFrames === animation.fps() * durationInSeconds; // true\n",paraId:52,tocIndex:11},{value:"控制播放速度，默认为 ",paraId:53,tocIndex:12},{value:"1",paraId:53,tocIndex:12},{value:"。大于 ",paraId:53,tocIndex:12},{value:"1",paraId:53,tocIndex:12},{value:" 表示加速，小于 ",paraId:53,tocIndex:12},{value:"1",paraId:53,tocIndex:12},{value:" 表示减速：",paraId:53,tocIndex:12},{value:"// 2x\nanimation.setSpeed(2);\n",paraId:54,tocIndex:12},{value:"1",paraId:55,tocIndex:13},{value:" 表示正向，",paraId:55,tocIndex:13},{value:"-1",paraId:55,tocIndex:13},{value:" 表示反向。默认正向播放：",paraId:55,tocIndex:13},{value:"animation.setSpeed(1);\nanimation.setSpeed(-1);\n",paraId:56,tocIndex:13},{value:"销毁全部内部对象，当然同时也会终止动画。",paraId:57,tocIndex:14},{value:"animation.destroy();\n",paraId:58,tocIndex:14},{value:"返回 Lottie 文件尺寸：",paraId:59,tocIndex:15},{value:"animation.size(); // { width: 1080, height: 260 }\n",paraId:60,tocIndex:15},{value:"返回 Lottie 文件中包含的 ",paraId:61,tocIndex:16},{value:"Bodymovin",paraId:61,tocIndex:16},{value:" 版本",paraId:61,tocIndex:16},{value:"animation.version();\n",paraId:62,tocIndex:16},{value:"支持 ",paraId:63,tocIndex:18},{value:"Shape Layer",paraId:63,tocIndex:18},{value:" 中定义的以下",paraId:63,tocIndex:18},{value:"元素",paraId:63,tocIndex:18},{value:"：",paraId:63,tocIndex:18},{value:" Rectangle 会转换成 ",paraId:64,tocIndex:18},{value:"Rect",paraId:65,tocIndex:18},{value:" 进行渲染。",paraId:64,tocIndex:18},{value:"https://lottiefiles.github.io/lottie-docs/shapes/#rectangle",paraId:64,tocIndex:18},{value:" Ellipse 会转换成 ",paraId:64,tocIndex:18},{value:"Ellipse",paraId:66,tocIndex:18},{value:" 进行渲染。",paraId:64,tocIndex:18},{value:"https://lottiefiles.github.io/lottie-docs/shapes/#ellipse",paraId:64,tocIndex:18},{value:" Path 会转换成 ",paraId:64,tocIndex:18},{value:"Path",paraId:67,tocIndex:18},{value:" 进行渲染。",paraId:64,tocIndex:18},{value:"https://lottiefiles.github.io/lottie-docs/shapes/#path",paraId:64,tocIndex:18},{value:" Group 会转换成 ",paraId:64,tocIndex:18},{value:"Group",paraId:68,tocIndex:18},{value:" 进行渲染。",paraId:64,tocIndex:18},{value:"https://lottiefiles.github.io/lottie-docs/shapes/#group",paraId:64,tocIndex:18},{value:" PolyStar ",paraId:64,tocIndex:18},{value:"https://lottiefiles.github.io/lottie-docs/shapes/#polystar",paraId:64,tocIndex:18},{value:"https://lottiefiles.github.io/lottie-docs/concepts/#transform",paraId:69,tocIndex:19},{value:"支持以下特性：",paraId:70,tocIndex:19},{value:"anchor",paraId:71,tocIndex:19},{value:" 对应 ",paraId:72,tocIndex:19},{value:"a",paraId:72,tocIndex:19},{value:" 字段",paraId:72,tocIndex:19},{value:"translation",paraId:73,tocIndex:19},{value:" 对应 ",paraId:72,tocIndex:19},{value:"p",paraId:72,tocIndex:19},{value:" 字段",paraId:72,tocIndex:19},{value:"scaling",paraId:74,tocIndex:19},{value:" 对应 ",paraId:72,tocIndex:19},{value:"s",paraId:72,tocIndex:19},{value:" 字段",paraId:72,tocIndex:19},{value:"rotation",paraId:75,tocIndex:19},{value:" 对应 ",paraId:72,tocIndex:19},{value:"r",paraId:72,tocIndex:19},{value:" 字段",paraId:72,tocIndex:19},{value:"暂不支持以下特性：",paraId:76,tocIndex:19},{value:"skew",paraId:77,tocIndex:19},{value:" 对应 ",paraId:78,tocIndex:19},{value:"sk",paraId:78,tocIndex:19},{value:" 字段",paraId:78,tocIndex:19},{value:"skewAxis",paraId:79,tocIndex:19},{value:" 对应 ",paraId:78,tocIndex:19},{value:"sa",paraId:78,tocIndex:19},{value:" 字段",paraId:78,tocIndex:19},{value:"在该",paraId:80,tocIndex:19},{value:"示例",paraId:81,tocIndex:19},{value:"中，深蓝色为基准矩形，我们以红色圆点为 ",paraId:80,tocIndex:19},{value:"transformOrigin",paraId:82,tocIndex:19},{value:"，旋转一定角度得到淡蓝色矩形。",paraId:80,tocIndex:19},{value:"https://lottiefiles.github.io/lottie-docs/concepts/#animated-position",paraId:83,tocIndex:20},{value:"支持以下样式属性：",paraId:84,tocIndex:21},{value:" Fill",paraId:85,tocIndex:21},{value:" Stroke",paraId:85,tocIndex:21},{value:" Gradients",paraId:85,tocIndex:21},{value:"https://lottiefiles.github.io/lottie-docs/shapes/#fill",paraId:86,tocIndex:22},{value:"填充色，同时支持以下特性：",paraId:87,tocIndex:22},{value:"fillOpacity",paraId:88,tocIndex:22},{value:" 对应 ",paraId:89,tocIndex:22},{value:"o",paraId:89,tocIndex:22},{value:" 字段",paraId:89,tocIndex:22},{value:"fillRule",paraId:90,tocIndex:22},{value:" 对应 ",paraId:89,tocIndex:22},{value:"r",paraId:89,tocIndex:22},{value:" 字段",paraId:89,tocIndex:22},{value:"https://lottiefiles.github.io/lottie-docs/shapes/#stroke",paraId:91,tocIndex:23},{value:"描边色，同时支持以下特性：",paraId:92,tocIndex:23},{value:"strokeOpacity",paraId:93,tocIndex:23},{value:" 对应 ",paraId:94,tocIndex:23},{value:"o",paraId:94,tocIndex:23},{value:" 字段",paraId:94,tocIndex:23},{value:"strokeWidth",paraId:95,tocIndex:23},{value:" 对应 ",paraId:94,tocIndex:23},{value:"w",paraId:94,tocIndex:23},{value:" 字段",paraId:94,tocIndex:23},{value:"lineCap",paraId:96,tocIndex:23},{value:" 对应 ",paraId:94,tocIndex:23},{value:"lc",paraId:94,tocIndex:23},{value:" 字段",paraId:94,tocIndex:23},{value:"lineJoin",paraId:97,tocIndex:23},{value:" 对应 ",paraId:94,tocIndex:23},{value:"lj",paraId:94,tocIndex:23},{value:" 字段",paraId:94,tocIndex:23},{value:"miterLimit",paraId:98,tocIndex:23},{value:" 对应 ",paraId:94,tocIndex:23},{value:"ml",paraId:94,tocIndex:23},{value:" 字段",paraId:94,tocIndex:23},{value:"lineDash",paraId:99,tocIndex:23},{value:" 对应 ",paraId:94,tocIndex:23},{value:"d",paraId:94,tocIndex:23},{value:" 字段",paraId:94,tocIndex:23},{value:"https://lottiefiles.github.io/lottie-docs/shapes/#gradients",paraId:100,tocIndex:24},{value:"支持",paraId:101,tocIndex:24},{value:"线性",paraId:102,tocIndex:24},{value:"和",paraId:101,tocIndex:24},{value:"放射",paraId:103,tocIndex:24},{value:"渐变。",paraId:101,tocIndex:24},{value:"暂不支持以下特性：",paraId:104,tocIndex:24},{value:"对渐变应用动画",paraId:105,tocIndex:24},{value:"Highlight length & angle (",paraId:105,tocIndex:24},{value:"h",paraId:105,tocIndex:24},{value:" 和 ",paraId:105,tocIndex:24},{value:"a",paraId:105,tocIndex:24},{value:" 字段)",paraId:105,tocIndex:24},{value:"https://lottiefiles.github.io/lottie-docs/layers/#layers",paraId:106,tocIndex:28},{value:"https://lottiefiles.github.io/lottie-docs/layers/#solid-color-layer",paraId:107,tocIndex:29},{value:"https://lottiefiles.github.io/lottie-docs/layers/#image-layer",paraId:108,tocIndex:30},{value:" ",paraId:108,tocIndex:30},{value:"https://lottiefiles.github.io/lottie-docs/assets/#image",paraId:108,tocIndex:30},{value:"https://lottiefiles.github.io/lottie-docs/layers/#text-layer",paraId:109,tocIndex:31},{value:" ",paraId:109,tocIndex:31},{value:"https://lottiefiles.github.io/lottie-docs/text/",paraId:109,tocIndex:31},{value:"https://lottiefiles.github.io/lottie-docs/layers/#precomposition-layer",paraId:110,tocIndex:32},{value:" ",paraId:110,tocIndex:32},{value:"https://lottiefiles.github.io/lottie-docs/assets/#precomposition",paraId:110,tocIndex:32},{value:"https://lottie-animation-community.github.io/docs/specs/layers/shapes/#merge-paths-property",paraId:111,tocIndex:33},{value:"内部会转换成 ",paraId:112,tocIndex:34},{value:"clipPath",paraId:113,tocIndex:34},{value:" 应用在目标元素上，并支持对其进行路径动画。",paraId:112,tocIndex:34},{value:"注意事项：",paraId:114,tocIndex:34},{value:"受限于 SVG 的实现。目前仅支持单一 Clipping Mask，声明多个也只有第一个会生效",paraId:115,tocIndex:34},{value:"Mask Mode Type",paraId:115,tocIndex:34},{value:" 仅支持 ",paraId:115,tocIndex:34},{value:"Add",paraId:115,tocIndex:34},{value:" 运算符",paraId:115,tocIndex:34},{value:"https://lottie-animation-community.github.io/docs/specs/layers/common/#clipping-masks",paraId:116,tocIndex:34},{value:"针对 Layer 的后处理效果暂不支持。",paraId:117,tocIndex:35},{value:"https://lottiefiles.github.io/lottie-docs/effects/#layer-effects",paraId:118,tocIndex:35},{value:"暂不支持表达式。",paraId:119,tocIndex:36},{value:"https://lottiefiles.github.io/lottie-docs/expressions/",paraId:120,tocIndex:36}]},36194:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(10141);const d=[{value:"参考 ",paraId:0},{value:"Web Animations API",paraId:0},{value:"，我们为每一个 DisplayObject 添加了动画能力。",paraId:0},{value:"目前我们支持基于 Keyframe 的动画，用户需要定义一系列关键帧，其中每一帧都可以包含变换属性、帧偏移量、缓动函数等参数，G 内部通过插值得到各个属性值在当前时间下的值并应用到目标图形上（如下图）。另外，对一些特殊属性变换会带来特别的动画效果，例如：",paraId:1},{value:"offsetDistance",paraId:2},{value:" 属性可以实现",paraId:2},{value:"路径动画",paraId:3},{value:"lineDashOffset",paraId:2},{value:" 属性可以实现",paraId:2},{value:"蚂蚁线动画",paraId:4},{value:"lineDash",paraId:2},{value:" 属性可以实现",paraId:2},{value:"笔迹动画",paraId:5},{value:"Path 的 ",paraId:2},{value:"path",paraId:2},{value:" 属性可以实现",paraId:2},{value:"形变动画（Morph）",paraId:6},{value:"在 Transition 效果上，我们支持：",paraId:7},{value:"Tween 缓动效果。内置例如 ",paraId:8},{value:"linear",paraId:8},{value:" ",paraId:8},{value:"cubic-bezier",paraId:8},{value:" 等，也支持自定义。",paraId:8},{value:"Spring，一种基于真实物理弹簧的效果。",paraId:8},{value:"我们从一个 Keyframe 动画入手，实现一个 ",paraId:9},{value:"ScaleIn",paraId:9},{value:" 的动画 ",paraId:9},{value:"示例",paraId:10},{value:"：",paraId:9},{value:"const scaleInCenter = circle.animate(\n    [\n        {\n            transform: 'scale(0)', // 起始关键帧\n        },\n        {\n            transform: 'scale(1)', // 结束关键帧\n        },\n    ],\n    {\n        duration: 500, // 持续时间\n        easing: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)', // 缓动函数\n        fill: 'both', // 动画处于非运行状态时，该图形的展示效果\n    },\n);\n",paraId:11},{value:"熟悉 CSS Transform/Animation 的开发者一定不会陌生。其对应的 CSS Animation 为：",paraId:12},{value:".scale-in-center {\n    animation: scale-in-center 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;\n}\n@keyframes scale-in-center {\n    0% {\n        transform: scale(0);\n    }\n    100% {\n        transform: scale(1);\n    }\n}\n",paraId:13},{value:"一个动画对象通常由两部分组成：target 目标图形和 KeyframeEffect 动画效果。前者在通过 ",paraId:14,tocIndex:0},{value:"object.animate()",paraId:14,tocIndex:0},{value:" 创建时已经指定，后者又由两部分组成：一组 Keyframe 和 EffectTiming。",paraId:14,tocIndex:0},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Animation",paraId:15,tocIndex:0},{value:"通过 ",paraId:16,tocIndex:1},{value:"DisplayObject.animate()",paraId:16,tocIndex:1},{value:" 可以创建一个 Animation 对象：",paraId:16,tocIndex:1},{value:"const animation = circle.animate(keyframes, options);\n",paraId:17,tocIndex:1},{value:"需要注意，应用动画效果的目标图形必须先挂载到画布上：",paraId:18,tocIndex:1},{value:"// wrong\nconst animation = circle.animate(keyframes, options);\ncanvas.appendChild(circle);\n\n// correct\ncanvas.appendChild(circle);\nconst animation = circle.animate(keyframes, options);\n",paraId:19,tocIndex:1},{value:"支持 ",paraId:20,tocIndex:2},{value:"KeyframeFormats",paraId:20,tocIndex:2},{value:"最常见的是在 keyframes 中声明需要变换的属性，下面的例子让圆的透明度和填充色发生变换：",paraId:21,tocIndex:2},{value:"circle.animate(\n    [\n        {\n            // from\n            opacity: 0,\n            fill: '#fff',\n        },\n        {\n            // to\n            opacity: 1,\n            fill: '#000',\n        },\n    ],\n    2000,\n);\n",paraId:22,tocIndex:2},{value:"keyframes 数组中的元素为 ",paraId:23,tocIndex:2},{value:"Keyframe",paraId:24,tocIndex:2},{value:"。",paraId:23,tocIndex:2},{value:"options",paraId:25,tocIndex:3},{value:" 支持两种类型：",paraId:25,tocIndex:3},{value:"EffectTiming",paraId:26,tocIndex:3},{value:" 配置",paraId:27,tocIndex:3},{value:"number",paraId:27,tocIndex:3},{value:" 等价于 ",paraId:27,tocIndex:3},{value:"{ duration }",paraId:27,tocIndex:3},{value:"因此以下两种写法等价：",paraId:28,tocIndex:3},{value:"circle.animate(keyframes, {\n    duration: 100,\n});\ncircle.animate(keyframes, 100);\n",paraId:29,tocIndex:3},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Animation/effect",paraId:30,tocIndex:5},{value:"返回 ",paraId:31,tocIndex:5},{value:"KeyframeEffect",paraId:32,tocIndex:5},{value:" 对象。后续可以在运行时调整动画效果，例如修改缓动函数等：",paraId:31,tocIndex:5},{value:"const effect = animation.effect;\n\neffect.getTiming().ease = 'linear';\n",paraId:33,tocIndex:5},{value:"获取动画开始时间。",paraId:34,tocIndex:6},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Animation/startTime",paraId:35,tocIndex:6},{value:"获取或设置动画相对于时间线的当前时间。",paraId:36,tocIndex:7},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Animation/currentTime",paraId:37,tocIndex:7},{value:"// 获取\nconst currentTime = animation.currentTime;\n\n// 设置新时间，会影响动画效果\nanimation.currentTime = newTime;\n",paraId:38,tocIndex:7},{value:"在该",paraId:39,tocIndex:7},{value:"示例",paraId:40,tocIndex:7},{value:"中，可以随时修改改属性，由于该动画单次执行时间为 3500ms，缓动函数又是线性，因此小圆形会回到路径对应的位置，再继续移动。",paraId:39,tocIndex:7},{value:"返回动画的运行状态。当一些手动控制方法（例如 ",paraId:41,tocIndex:8},{value:"pause()",paraId:41,tocIndex:8},{value:"）被调用后，状态发生改变。",paraId:41,tocIndex:8},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Animation/playState",paraId:42,tocIndex:8},{value:"idle 动画处于未准备好的状态",paraId:43,tocIndex:8},{value:"running 动画处于运行状态",paraId:43,tocIndex:8},{value:"paused 动画处于暂停状态",paraId:43,tocIndex:8},{value:"finished 动画运行完毕.",paraId:43,tocIndex:8},{value:"动画正在等待一些异步任务完成，例如正在暂停一个运行中的动画。",paraId:44,tocIndex:9},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Animation/pending",paraId:45,tocIndex:9},{value:"返回一个动画准备开始时 resolve 的 Promise。",paraId:46,tocIndex:10},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Animation/ready",paraId:47,tocIndex:10},{value:"animation.ready.then(() => {\n    animation.playState; // running\n    canvas.timeline.currentTime;\n});\n",paraId:48,tocIndex:10},{value:"返回一个动画结束时 resolve 的 Promise。",paraId:49,tocIndex:11},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Animation/finished",paraId:50,tocIndex:11},{value:"例如我们想让图形在所有动画结束之后移除自身：",paraId:51,tocIndex:11},{value:"Promise.all(circle.getAnimations().map((animation) => animation.finished)).then(\n    () => {\n        return circle.remove();\n    },\n);\n",paraId:52,tocIndex:11},{value:"或者完成一组连续动画，例如让一个圆先向右，再向下移动，",paraId:53,tocIndex:11},{value:"示例",paraId:54,tocIndex:11},{value:"：",paraId:53,tocIndex:11},{value:"(async () => {\n  // 向右移动 100px\n  const moveRight = circle.animate(\n    [\n      {\n        transform: 'translate(0)',\n      },\n      {\n        transform: 'translate(100px)',\n      },\n    ],\n    {\n      duration: 1000,\n      easing: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)',\n      fill: 'both',\n    },\n  );\n  // 等待动画完成\n  await moveRight.finished;\n\n  // 完成后向下移动\n  const moveDown = circle.animate(\n    //... 省略\n  );\n",paraId:55,tocIndex:11},{value:"设置动画完成后的回调函数，类似 ",paraId:56,tocIndex:12},{value:"animationend",paraId:56,tocIndex:12},{value:" 事件。",paraId:56,tocIndex:12},{value:"示例",paraId:57,tocIndex:12},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Animation/onfinish",paraId:58,tocIndex:12},{value:"animation.onfinish = function (e) {\n    e.target; // animation\n    e.target.playState; // 'finished'\n};\n",paraId:59,tocIndex:12},{value:"回调函数中的事件对象为 ",paraId:60,tocIndex:12},{value:"AnimationPlaybackEvent",paraId:60,tocIndex:12},{value:"，该事件比较特殊，不可冒泡，也无法调用对象上的一些方法，有用的属性如下：",paraId:60,tocIndex:12},{value:"target 返回监听的 animation",paraId:61,tocIndex:12},{value:"currentTime 动画当前时间",paraId:61,tocIndex:12},{value:"timelineTime 时间线时间",paraId:61,tocIndex:12},{value:"处于运行中的动画，在每一帧结束后调用，此时属性已经完成插值。如果动画处于暂停、未开始或者结束状态不会被调用。",paraId:62,tocIndex:13},{value:"示例",paraId:63,tocIndex:13},{value:"animation.onframe = function (e) {\n    e.target; // animation\n    e.target.playState; // 'running'\n};\n",paraId:64,tocIndex:13},{value:"动画播放的速率，默认值为 1",paraId:65,tocIndex:14},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Animation/playbackRate",paraId:66,tocIndex:14},{value:"例如我们想手动控制动画的运行方向，或者降低播放速率：",paraId:67,tocIndex:14},{value:"animation.playbackRate = -1;\nanimation.play();\n\n// 减速\nanimation.playbackRate *= 0.9;\n\n// 加速\nanimation.playbackRate *= 1.1;\n",paraId:68,tocIndex:14},{value:"通过以下方法可以手动控制动画的运行状态，例如暂停、重启、结束等。",paraId:69,tocIndex:15},{value:"示例",paraId:70,tocIndex:15},{value:"开始或者继续动画。当动画处于 ",paraId:71,tocIndex:16},{value:"finished",paraId:71,tocIndex:16},{value:" 状态时，调用它会重启动画。",paraId:71,tocIndex:16},{value:"animation.play();\nanimation.playState; // 'running'\n",paraId:72,tocIndex:16},{value:"暂停动画",paraId:73,tocIndex:17},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Animation/pause",paraId:74,tocIndex:17},{value:"animation.pause();\nanimation.playState; // 'paused'\n",paraId:75,tocIndex:17},{value:"将动画的运行时间调整到最后（和运行方向有关）。",paraId:76,tocIndex:18},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Animation/finish",paraId:77,tocIndex:18},{value:"animation.finish();\nanimation.playState; // 'finished'\n",paraId:78,tocIndex:18},{value:"清除该动画效果，将 ",paraId:79,tocIndex:19},{value:"startTime",paraId:79,tocIndex:19},{value:" 和 ",paraId:79,tocIndex:19},{value:"currentTime",paraId:79,tocIndex:19},{value:" 设置为 ",paraId:79,tocIndex:19},{value:"null",paraId:79,tocIndex:19},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Animation/cancel",paraId:80,tocIndex:19},{value:"翻转动画运行方向，效果等同于设置 playbackRate 为 -1。",paraId:81,tocIndex:20},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Animation/reverse",paraId:82,tocIndex:20},{value:"控制动画运行速率，默认速率为 1，",paraId:83,tocIndex:21},{value:"示例",paraId:84,tocIndex:21},{value:"：",paraId:83,tocIndex:21},{value:"animation.updatePlaybackRate(2); // 加速\nanimation.updatePlaybackRate(0.5); // 减速\nanimation.updatePlaybackRate(-1); // 反向\n",paraId:85,tocIndex:21},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Animation/updatePlaybackRate",paraId:86,tocIndex:21},{value:"动画效果，可以通过 ",paraId:87,tocIndex:22},{value:"getTiming()",paraId:87,tocIndex:22},{value:" 获取该效果对应的时间配置对象。由两部分组成：一组 Keyframe 和 ",paraId:87,tocIndex:22},{value:"EffectTiming",paraId:88,tocIndex:22},{value:"。",paraId:87,tocIndex:22},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Animation/effect",paraId:89,tocIndex:22},{value:"返回当前处于动画中的图形",paraId:90,tocIndex:23},{value:"https://developer.mozilla.org/en-US/docs/Web/API/KeyframeEffect/target",paraId:91,tocIndex:23},{value:"const animation = circle.animate({\n    // ...\n});\n\nanimation.effect.target; // circle\n",paraId:92,tocIndex:23},{value:"返回 ",paraId:93,tocIndex:24},{value:"EffectTiming",paraId:94,tocIndex:24},{value:" 对象",paraId:93,tocIndex:24},{value:"https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getTiming",paraId:95,tocIndex:24},{value:"const timing = animation.effect.getTiming();\ntiming.ease = 'linear';\n",paraId:96,tocIndex:24},{value:"返回 ",paraId:97,tocIndex:25},{value:"ComputedEffectTiming",paraId:98,tocIndex:25},{value:" 对象，它与 ",paraId:97,tocIndex:25},{value:"EffectTiming",paraId:99,tocIndex:25},{value:" 的区别在于前者会把后者的一些字面量计算后返回：",paraId:97,tocIndex:25},{value:"duration 为 'auto' 时返回 0",paraId:100,tocIndex:25},{value:"fill 为 'auto' 时返回 'none'",paraId:100,tocIndex:25},{value:"https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getComputedTiming",paraId:101,tocIndex:25},{value:"更新 ",paraId:102,tocIndex:26},{value:"EffectTiming",paraId:103,tocIndex:26},{value:" 属性，例如以下两种写法等价：",paraId:102,tocIndex:26},{value:"const timing = animation.effect.getTiming();\ntiming.ease = 'linear';\n\nanimation.updateTiming({ ease: 'linear' });\n",paraId:104,tocIndex:26},{value:"https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/updateTiming",paraId:105,tocIndex:26},{value:"在开头的例子中，我们定义了两个 Keyframe：",paraId:106,tocIndex:27},{value:"[\n  {\n    transform: 'scale(0)', // 起始关键帧\n  },\n  {\n    transform: 'scale(1)', // 结束关键帧\n  }\n],\n",paraId:107,tocIndex:27},{value:"目前支持对以下属性进行变换 ",paraId:108,tocIndex:28},{value:"示例",paraId:109,tocIndex:28},{value:"：",paraId:108,tocIndex:28},{value:"名称",paraId:110,tocIndex:28},{value:"类型",paraId:110,tocIndex:28},{value:"取值范围",paraId:110,tocIndex:28},{value:"备注",paraId:110,tocIndex:28},{value:"transform",paraId:110,tocIndex:28},{value:"string",paraId:110,tocIndex:28},{value:"scale(1, 2)",paraId:110,tocIndex:28},{value:" ",paraId:110,tocIndex:28},{value:"scaleY(1)",paraId:110,tocIndex:28},{value:"和 ",paraId:110,tocIndex:28},{value:"CSS Transform",paraId:110,tocIndex:28},{value:" 保持一致",paraId:110,tocIndex:28},{value:"opacity",paraId:110,tocIndex:28},{value:"number",paraId:110,tocIndex:28},{value:"[0-1]",paraId:110,tocIndex:28},{value:"透明度",paraId:110,tocIndex:28},{value:"strokeOpacity",paraId:110,tocIndex:28},{value:"number",paraId:110,tocIndex:28},{value:"[0-1]",paraId:110,tocIndex:28},{value:"描边透明度",paraId:110,tocIndex:28},{value:"fill",paraId:110,tocIndex:28},{value:"string",paraId:110,tocIndex:28},{value:"例如 ",paraId:110,tocIndex:28},{value:"red",paraId:110,tocIndex:28},{value:" ",paraId:110,tocIndex:28},{value:"#fff",paraId:110,tocIndex:28},{value:"填充色",paraId:110,tocIndex:28},{value:"stroke",paraId:110,tocIndex:28},{value:"string",paraId:110,tocIndex:28},{value:"例如 ",paraId:110,tocIndex:28},{value:"red",paraId:110,tocIndex:28},{value:" ",paraId:110,tocIndex:28},{value:"#fff",paraId:110,tocIndex:28},{value:"描边色",paraId:110,tocIndex:28},{value:"lineWidth",paraId:110,tocIndex:28},{value:"number",paraId:110,tocIndex:28},{value:"例如 ",paraId:110,tocIndex:28},{value:"1",paraId:110,tocIndex:28},{value:" ",paraId:110,tocIndex:28},{value:"10",paraId:110,tocIndex:28},{value:"线宽",paraId:110,tocIndex:28},{value:"r",paraId:110,tocIndex:28},{value:"number",paraId:110,tocIndex:28},{value:"例如 ",paraId:110,tocIndex:28},{value:"10",paraId:110,tocIndex:28},{value:" ",paraId:110,tocIndex:28},{value:"20",paraId:110,tocIndex:28},{value:"Circle 的半径",paraId:110,tocIndex:28},{value:"rx/ry",paraId:110,tocIndex:28},{value:"number",paraId:110,tocIndex:28},{value:"例如 ",paraId:110,tocIndex:28},{value:"10",paraId:110,tocIndex:28},{value:" ",paraId:110,tocIndex:28},{value:"20",paraId:110,tocIndex:28},{value:"Ellipse 的半径",paraId:110,tocIndex:28},{value:"width",paraId:110,tocIndex:28},{value:"number",paraId:110,tocIndex:28},{value:"例如 ",paraId:110,tocIndex:28},{value:"10",paraId:110,tocIndex:28},{value:" ",paraId:110,tocIndex:28},{value:"20",paraId:110,tocIndex:28},{value:"Rect/Image 的宽度",paraId:110,tocIndex:28},{value:"height",paraId:110,tocIndex:28},{value:"number",paraId:110,tocIndex:28},{value:"例如 ",paraId:110,tocIndex:28},{value:"10",paraId:110,tocIndex:28},{value:" ",paraId:110,tocIndex:28},{value:"20",paraId:110,tocIndex:28},{value:"Rect/Image 的高度",paraId:110,tocIndex:28},{value:"x1/y1/x2/y2",paraId:110,tocIndex:28},{value:"number",paraId:110,tocIndex:28},{value:"例如 ",paraId:110,tocIndex:28},{value:"10",paraId:110,tocIndex:28},{value:" ",paraId:110,tocIndex:28},{value:"20",paraId:110,tocIndex:28},{value:"Line 的端点坐标",paraId:110,tocIndex:28},{value:"offsetDistance",paraId:110,tocIndex:28},{value:"number",paraId:110,tocIndex:28},{value:"[0-1]",paraId:110,tocIndex:28},{value:"路径偏移，在",paraId:110,tocIndex:28},{value:"路径动画",paraId:111,tocIndex:28},{value:"中使用",paraId:110,tocIndex:28},{value:"lineDash",paraId:110,tocIndex:28},{value:"[number, number]",paraId:110,tocIndex:28},{value:"例如 ",paraId:110,tocIndex:28},{value:"[0, 100]",paraId:110,tocIndex:28},{value:"实线和间隔的长度，在",paraId:110,tocIndex:28},{value:"笔迹动画",paraId:112,tocIndex:28},{value:"中使用",paraId:110,tocIndex:28},{value:"lineDashOffset",paraId:110,tocIndex:28},{value:"number",paraId:110,tocIndex:28},{value:"例如 ",paraId:110,tocIndex:28},{value:"-20",paraId:110,tocIndex:28},{value:" ",paraId:110,tocIndex:28},{value:"0",paraId:110,tocIndex:28},{value:" ",paraId:110,tocIndex:28},{value:"20",paraId:110,tocIndex:28},{value:"设置虚线的偏移量，在",paraId:110,tocIndex:28},{value:"蚂蚁线效果",paraId:113,tocIndex:28},{value:"中使用",paraId:110,tocIndex:28},{value:"path",paraId:110,tocIndex:28},{value:"string",paraId:110,tocIndex:28},{value:"例如 ",paraId:110,tocIndex:28},{value:"M 100,100 L 200,200",paraId:110,tocIndex:28},{value:"Path 的定义，在",paraId:110,tocIndex:28},{value:"形变动画",paraId:114,tocIndex:28},{value:"中使用",paraId:110,tocIndex:28},{value:"对于自定义属性，可以",paraId:115,tocIndex:28},{value:"在样式系统中注册",paraId:116,tocIndex:28},{value:"。在该",paraId:115,tocIndex:28},{value:"示例",paraId:117,tocIndex:28},{value:"中，我们注册了多种不同类型的自定义属性，让它们支持插值。",paraId:115,tocIndex:28},{value:"其中 transform 和 ",paraId:118,tocIndex:28},{value:"CSS Transform",paraId:118,tocIndex:28},{value:" 保持一致，支持以下属性值：",paraId:118,tocIndex:28},{value:"缩放，无单位\n",paraId:119,tocIndex:28},{value:"scale(x, y)",paraId:120,tocIndex:28},{value:"scaleX(x)",paraId:120,tocIndex:28},{value:"scaleY(x)",paraId:120,tocIndex:28},{value:"scaleZ(z)",paraId:120,tocIndex:28},{value:"scale3d(x, y, z)",paraId:120,tocIndex:28},{value:"平移，0 可以不加单位，无单位当作 px 处理，百分比相对于当前图形包围盒\n",paraId:119,tocIndex:28},{value:"translate(0, 0) translate(0, 30px) translate(100%, 100%)",paraId:121,tocIndex:28},{value:"translateX(0)",paraId:121,tocIndex:28},{value:"translateY(0)",paraId:121,tocIndex:28},{value:"translateZ(0)",paraId:121,tocIndex:28},{value:"translate3d(0, 0, 0)",paraId:121,tocIndex:28},{value:"旋转，支持 deg rad turn 这些单位\n",paraId:119,tocIndex:28},{value:"rotate(0.5turn) rotate(30deg) rotate(1rad)",paraId:122,tocIndex:28},{value:"拉伸，支持 deg rad turn 这些角度单位\n",paraId:119,tocIndex:28},{value:"skew(ax, ay)",paraId:123,tocIndex:28},{value:"skewX(a)",paraId:123,tocIndex:28},{value:"skewY(a)",paraId:123,tocIndex:28},{value:"变换矩阵\n",paraId:119,tocIndex:28},{value:"matrix(a,b,c,d,tx,ty) 可参考 ",paraId:124,tocIndex:28},{value:"CSS matrix 定义",paraId:124,tocIndex:28},{value:"matrix3d() 包含 16 个元素的完整矩阵定义",paraId:124,tocIndex:28},{value:"无变换 none",paraId:119,tocIndex:28},{value:"⚠️ 暂不支持以下取值：",paraId:125,tocIndex:28},{value:"calc()",paraId:126,tocIndex:28},{value:"。例如 ",paraId:126,tocIndex:28},{value:"translate(calc(100% + 10px))",paraId:126,tocIndex:28},{value:"perspective",paraId:126,tocIndex:28},{value:"关键帧的偏移量，取值范围为 ",paraId:127,tocIndex:29},{value:"[0-1]",paraId:127,tocIndex:29},{value:"。",paraId:127,tocIndex:29},{value:"[{ opacity: 1 }, { opacity: 0.1, offset: 0.7 }, { opacity: 0 }];\n",paraId:128,tocIndex:29},{value:"当不指定时，offset 会通过相邻 keyframe 自动计算，例如下面的 3 个 keyframe 都未指定，一头一尾默认值为 0 和 1，中间这一帧计算得到 0.5：",paraId:129,tocIndex:29},{value:"[\n  { transform: 'scale(0)' }, // offset 0\n  { transform: 'scale(2)' }, // offset 0.5\n  { transform: 'scale(1)' }, // offset 1\n],\n",paraId:130,tocIndex:29},{value:"可以通过 ",paraId:131,tocIndex:30},{value:"easing",paraId:131,tocIndex:30},{value:" 指明相邻 keyframe 之间的缓动函数：",paraId:131,tocIndex:30},{value:"circle.animate(\n    [\n        { opacity: 1, easing: 'ease-out' },\n        { opacity: 0.1, easing: 'ease-in' },\n        { opacity: 0 },\n    ],\n    2000,\n);\n",paraId:132,tocIndex:30},{value:"内置缓动函数详见 ",paraId:133,tocIndex:30},{value:"easing",paraId:134,tocIndex:30},{value:"一些常见的动画效果，例如 fadeIn 等等，可以参考 ",paraId:135,tocIndex:31},{value:"https://github.com/wellyshen/use-web-animations/tree/master/src/animations",paraId:135,tocIndex:31},{value:"export default {\n    keyframes: [{ opacity: 0 }, { opacity: 1 }],\n    animationOptions: { duration: 1000, fill: 'both' },\n};\n",paraId:136,tocIndex:31},{value:"示例",paraId:137},{value:"https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming",paraId:138,tocIndex:32},{value:"const timing = animation.effect.getTiming();\n",paraId:139,tocIndex:32},{value:"开始动画前的延迟，以毫秒为单位，默认值为 0，因此动画会立即开始。",paraId:140,tocIndex:33},{value:"https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/delay",paraId:141,tocIndex:33},{value:"类型",paraId:142,tocIndex:33},{value:"： ",paraId:142,tocIndex:33},{value:"number",paraId:142,tocIndex:33},{value:"默认值",paraId:143,tocIndex:33},{value:"：0",paraId:143,tocIndex:33},{value:"是否必须",paraId:144,tocIndex:33},{value:"：",paraId:144,tocIndex:33},{value:"false",paraId:144,tocIndex:33},{value:"动画在时间线上的运行方向，也会影响到每次迭代结束后的行为。通过该属性我们可以实现往复运动的效果。",paraId:145,tocIndex:34},{value:"https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/direction",paraId:146,tocIndex:34},{value:"类型",paraId:147,tocIndex:34},{value:"： ",paraId:147,tocIndex:34},{value:"string",paraId:147,tocIndex:34},{value:"默认值",paraId:148,tocIndex:34},{value:"：",paraId:148,tocIndex:34},{value:"normal",paraId:148,tocIndex:34},{value:"是否必须",paraId:149,tocIndex:34},{value:"：",paraId:149,tocIndex:34},{value:"false",paraId:149,tocIndex:34},{value:"可以取以下值：",paraId:150,tocIndex:34},{value:"normal 每次迭代中，动画都从起始帧运行到结束帧",paraId:151,tocIndex:34},{value:"reverse 每次迭代中，动画都从结束帧运行到起始帧",paraId:151,tocIndex:34},{value:"alternate 每次迭代结束后更换方向，例如第一次迭代从前往后，第二次迭代从后往前",paraId:151,tocIndex:34},{value:"alternate-reverse 每次迭代结束后更换方向，例如第一次迭代从后往前，第二次迭代从前往后",paraId:151,tocIndex:34},{value:"动画运行时长，以毫秒为单位，默认为 ",paraId:152,tocIndex:35},{value:"auto",paraId:152,tocIndex:35},{value:"，和 0 效果相同。",paraId:152,tocIndex:35},{value:"https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/duration",paraId:153,tocIndex:35},{value:"类型",paraId:154,tocIndex:35},{value:"： ",paraId:154,tocIndex:35},{value:"number | string",paraId:154,tocIndex:35},{value:"默认值",paraId:155,tocIndex:35},{value:"：",paraId:155,tocIndex:35},{value:"auto",paraId:155,tocIndex:35},{value:"是否必须",paraId:156,tocIndex:35},{value:"：",paraId:156,tocIndex:35},{value:"false",paraId:156,tocIndex:35},{value:"说明",paraId:157,tocIndex:35},{value:" 不能为负数",paraId:157,tocIndex:35},{value:"缓动函数，默认为 ",paraId:158,tocIndex:36},{value:"linear",paraId:158,tocIndex:36},{value:"，我们也内置了一系列常用函数。",paraId:158,tocIndex:36},{value:"示例",paraId:159,tocIndex:36},{value:"https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/easing",paraId:160,tocIndex:36},{value:"类型",paraId:161,tocIndex:36},{value:"： ",paraId:161,tocIndex:36},{value:"string",paraId:161,tocIndex:36},{value:"默认值",paraId:162,tocIndex:36},{value:"：",paraId:162,tocIndex:36},{value:"linear",paraId:162,tocIndex:36},{value:"是否必须",paraId:163,tocIndex:36},{value:"：",paraId:163,tocIndex:36},{value:"false",paraId:163,tocIndex:36},{value:"支持以下内置缓动函数，来自：",paraId:164,tocIndex:36},{value:"https://easings.net/",paraId:164,tocIndex:36},{value:"constant",paraId:165,tocIndex:36},{value:"accelerate",paraId:165,tocIndex:36},{value:"decelerate",paraId:165,tocIndex:36},{value:"accelerate-decelerate",paraId:165,tocIndex:36},{value:"decelerate-accelerate",paraId:165,tocIndex:36},{value:"linear",paraId:165,tocIndex:36},{value:"ease-in / in",paraId:165,tocIndex:36},{value:"ease-out / out",paraId:165,tocIndex:36},{value:"ease-in-out / in-out",paraId:165,tocIndex:36},{value:"ease-out-in / out-in",paraId:165,tocIndex:36},{value:"ease",paraId:165,tocIndex:36},{value:"in-sine",paraId:165,tocIndex:36},{value:"out-sine",paraId:165,tocIndex:36},{value:"in-out-sine",paraId:165,tocIndex:36},{value:"out-in-sine",paraId:165,tocIndex:36},{value:"steps",paraId:165,tocIndex:36},{value:"in-quad",paraId:165,tocIndex:36},{value:"out-quad",paraId:165,tocIndex:36},{value:"in-out-quad",paraId:165,tocIndex:36},{value:"out-in-quad",paraId:165,tocIndex:36},{value:"step-start",paraId:165,tocIndex:36},{value:"in-cubic",paraId:165,tocIndex:36},{value:"out-cubic",paraId:165,tocIndex:36},{value:"in-out-cubic",paraId:165,tocIndex:36},{value:"out-in-cubic",paraId:165,tocIndex:36},{value:"step-end",paraId:165,tocIndex:36},{value:"in-quart",paraId:165,tocIndex:36},{value:"out-quart",paraId:165,tocIndex:36},{value:"in-out-quart",paraId:165,tocIndex:36},{value:"out-in-quart",paraId:165,tocIndex:36},{value:"in-quint",paraId:165,tocIndex:36},{value:"out-quint",paraId:165,tocIndex:36},{value:"in-out-quint",paraId:165,tocIndex:36},{value:"out-in-quint",paraId:165,tocIndex:36},{value:"in-expo",paraId:165,tocIndex:36},{value:"out-expo",paraId:165,tocIndex:36},{value:"in-out-expo",paraId:165,tocIndex:36},{value:"out-in-expo",paraId:165,tocIndex:36},{value:"in-circ",paraId:165,tocIndex:36},{value:"out-circ",paraId:165,tocIndex:36},{value:"in-out-circ",paraId:165,tocIndex:36},{value:"out-in-circ",paraId:165,tocIndex:36},{value:"in-back",paraId:165,tocIndex:36},{value:"out-back",paraId:165,tocIndex:36},{value:"in-out-back",paraId:165,tocIndex:36},{value:"out-in-back",paraId:165,tocIndex:36},{value:"in-bounce",paraId:165,tocIndex:36},{value:"out-bounce",paraId:165,tocIndex:36},{value:"in-out-bounce",paraId:165,tocIndex:36},{value:"out-in-bounce",paraId:165,tocIndex:36},{value:"in-elastic",paraId:165,tocIndex:36},{value:"out-elastic",paraId:165,tocIndex:36},{value:"in-out-elastic",paraId:165,tocIndex:36},{value:"out-in-elastic",paraId:165,tocIndex:36},{value:"spring / spring-in",paraId:165,tocIndex:36},{value:"spring-out",paraId:165,tocIndex:36},{value:"spring-in-out",paraId:165,tocIndex:36},{value:"spring-out-in",paraId:165,tocIndex:36},{value:"除此之外，还可以通过 ",paraId:166,tocIndex:36},{value:"cubic-bezier(<number>, <number>, <number>, <number>)",paraId:166,tocIndex:36},{value:" 自定义形如三次贝塞尔曲线的函数。以上部分内置函数也是通过它定义完成的，例如 ",paraId:166,tocIndex:36},{value:"ease-in-sine = cubic-bezier(0.47, 0, 0.745, 0.715)",paraId:166,tocIndex:36},{value:"当以上内置缓动函数无法满足时，可以通过 ",paraId:167,tocIndex:36},{value:"EasingFunctions",paraId:167,tocIndex:36},{value:" 注册自定义函数。",paraId:167,tocIndex:36},{value:"import { EasingFunctions } from '@antv/g';\n// 注册自定义缓动函数\nEasingFunctions['my-easing'] = (t: number) => t;\n\ncircle.animate([{ opacity: 0 }, { opacity: 1 }], {\n    duration: 500,\n    easing: 'my-easing', // 使用\n});\n",paraId:168,tocIndex:36},{value:"动画结束前的延迟，以毫秒为单位，默认值为 0，因此动画运行完毕会立即结束。",paraId:169,tocIndex:37},{value:"https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/endDelay",paraId:170,tocIndex:37},{value:"类型",paraId:171,tocIndex:37},{value:"： ",paraId:171,tocIndex:37},{value:"number",paraId:171,tocIndex:37},{value:"默认值",paraId:172,tocIndex:37},{value:"：0",paraId:172,tocIndex:37},{value:"是否必须",paraId:173,tocIndex:37},{value:"：",paraId:173,tocIndex:37},{value:"false",paraId:173,tocIndex:37},{value:"我们也可以设置一个负数，让动画提前结束：",paraId:174,tocIndex:37},{value:"const animation = circle.animate(\n    [{ transform: 'scale(1)' }, { transform: 'scale(2)' }],\n    {\n        duration: 2000,\n        endDelay: -1000, // 动画执行到一半会立刻结束\n        easing: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)',\n    },\n);\n",paraId:175,tocIndex:37},{value:"该属性规定了图形在动画处于非运行状态（例如动画开始前，结束后）时的展示效果。支持以下值：",paraId:176,tocIndex:38},{value:"auto/none 默认值，这意味着动画在第一帧开始前和最后一帧结束后都不会影响到图形的展示效果。例如在动画完成后图形会恢复到动画前状态，如果设置了 delay 在延迟期间也不会应用第一帧的效果。",paraId:177,tocIndex:38},{value:"forwards 动画完成后停住，不恢复到初始状态",paraId:177,tocIndex:38},{value:"backwards 动画开始前应用第一帧效果",paraId:177,tocIndex:38},{value:"both 为 forwards 和 backwards 的组合效果",paraId:177,tocIndex:38},{value:"https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/fill",paraId:178,tocIndex:38},{value:"例如我们想让图形在缩放动画完成后，停在结束状态：",paraId:179,tocIndex:38},{value:"const animation = circle.animate(\n    [\n        {\n            transform: 'scale(1)',\n            fill: '#1890FF',\n            stroke: '#F04864',\n            opacity: 1,\n        },\n        { transform: 'scale(2)', fill: 'red', stroke: '#1890FF', opacity: 0.8 },\n    ],\n    {\n        duration: 1500,\n        easing: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)',\n        fill: 'both',\n    },\n);\n",paraId:180,tocIndex:38},{value:"循环次数，默认值为 1，也可以取大于 0 的小数。当我们想让动画一直运行下去时，可以取 ",paraId:181,tocIndex:39},{value:"Infinity",paraId:181,tocIndex:39},{value:"。",paraId:181,tocIndex:39},{value:"https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/iterations",paraId:182,tocIndex:39},{value:"类型",paraId:183,tocIndex:39},{value:"： ",paraId:183,tocIndex:39},{value:"number",paraId:183,tocIndex:39},{value:"默认值",paraId:184,tocIndex:39},{value:"：1",paraId:184,tocIndex:39},{value:"是否必须",paraId:185,tocIndex:39},{value:"：",paraId:185,tocIndex:39},{value:"false",paraId:185,tocIndex:39},{value:"从何处开始执行动画，例如动画总是从 0 开始运行，设置为 0.5 代表动画会从当中开始运行。",paraId:186,tocIndex:40},{value:"https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/iterationStart",paraId:187,tocIndex:40},{value:"类型",paraId:188,tocIndex:40},{value:"： ",paraId:188,tocIndex:40},{value:"number",paraId:188,tocIndex:40},{value:"默认值",paraId:189,tocIndex:40},{value:"：0",paraId:189,tocIndex:40},{value:"是否必须",paraId:190,tocIndex:40},{value:"：",paraId:190,tocIndex:40},{value:"false",paraId:190,tocIndex:40},{value:"继承了 ",paraId:191,tocIndex:41},{value:"EffectTiming",paraId:192,tocIndex:41},{value:" 的所有属性，同时包含一些只读的、计算后的额外属性。",paraId:191,tocIndex:41},{value:"const computedTiming = animation.effect.getComputedTiming();\n",paraId:193,tocIndex:41},{value:"动画的预计结束时间，需要考虑前后延迟。计算方式为：",paraId:194,tocIndex:42},{value:"delay",paraId:195,tocIndex:42},{value:" + ",paraId:194,tocIndex:42},{value:"activeDuration",paraId:196,tocIndex:42},{value:" + ",paraId:194,tocIndex:42},{value:"endDelay",paraId:197,tocIndex:42},{value:"https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getComputedTiming#return_value",paraId:198,tocIndex:42},{value:"动画效果运行的预计时长，单位毫秒。计算方式为 ",paraId:199,tocIndex:43},{value:"duration",paraId:200,tocIndex:43},{value:" * ",paraId:199,tocIndex:43},{value:"iterations",paraId:201,tocIndex:43},{value:"https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getComputedTiming#return_value",paraId:202,tocIndex:43},{value:"同 ",paraId:203,tocIndex:44},{value:"currentTime",paraId:204,tocIndex:44},{value:"，单位毫秒。",paraId:203,tocIndex:44},{value:"返回在当前 iteration 内的进度，取值范围为 ",paraId:205,tocIndex:45},{value:"[0-1]",paraId:205,tocIndex:45},{value:"。当动画不在运行中时返回 null。",paraId:205,tocIndex:45},{value:"在该",paraId:206,tocIndex:45},{value:"示例",paraId:207,tocIndex:45},{value:"中，我们在每一帧结束的 ",paraId:206,tocIndex:45},{value:"onframe",paraId:208,tocIndex:45},{value:" 回调函数中打印进度值：",paraId:206,tocIndex:45},{value:"animation.onframe = (e) => {\n    console.log(e.target.effect.getComputedTiming().progress);\n};\n",paraId:209,tocIndex:45},{value:"返回动画当前循环执行的次数，从 0 开始。当动画不在运行中时返回 null。",paraId:210,tocIndex:46},{value:"我们熟悉的缓动函数（又称 Tween）是一种基于当前运行时间的动画效果，即使能够自定义缓动函数，仍然有一些动画效果无法实现。例如现已被广泛使用的 Spring 效果，在 ",paraId:211,tocIndex:47},{value:"React Spring Visualizer",paraId:211,tocIndex:47},{value:" 中可以看到该动画效果并非仅仅依靠当前运行时间，而是一种基于物理弹簧属性（自重、摩擦力等）的效果： ",paraId:211,tocIndex:47},{value:"因此在一些流行的动画库中，Transition 通常不止 Tween 一种，例如 ",paraId:212,tocIndex:47},{value:"Framer Motion",paraId:212,tocIndex:47},{value:" 就支持 Spring：",paraId:212,tocIndex:47},{value:"<motion.div animate={{ rotate: 180 }} transition={{ type: 'spring' }} />\n",paraId:213,tocIndex:47},{value:"也有像 ",paraId:214,tocIndex:47},{value:"https://react-spring.io/",paraId:214,tocIndex:47},{value:" 这样的库：",paraId:214,tocIndex:47},{value:"Spring 背后的原理：",paraId:215,tocIndex:47},{value:"https://blog.maximeheckel.com/posts/the-physics-behind-spring-animations",paraId:215,tocIndex:47},{value:"那么对于这种非缓动的效果，如何使用 CSS Animation 或者 WAAPI 实现呢？关于这个问题在 W3C 中早已有过讨论：",paraId:216,tocIndex:47},{value:"https://github.com/w3c/csswg-drafts/issues/229。",paraId:216,tocIndex:47},{value:" 目前我们内置了 spring 系列的变换效果，但暂不提供弹簧参数的配置 ",paraId:216,tocIndex:47},{value:"示例",paraId:217,tocIndex:47},{value:"：",paraId:216,tocIndex:47},{value:"const animation = image.animate(\n    [{ transform: 'rotate(0)' }, { transform: 'rotate(360deg)' }],\n    {\n        duration: 1500,\n        iterations: Infinity,\n        easing: 'spring',\n    },\n);\n",paraId:218,tocIndex:47},{value:"让图形沿着某个路径移动是一个常见的需求，在 CSS 中通过 ",paraId:219,tocIndex:48},{value:"MotionPath",paraId:219,tocIndex:48},{value:" 实现：",paraId:219,tocIndex:48},{value:"#motion-demo {\n    animation: move 3000ms infinite alternate ease-in-out;\n    offset-path: path('M20,20 C20,100 200,0 200,100');\n}\n@keyframes move {\n    0% {\n        offset-distance: 0%;\n    }\n    100% {\n        offset-distance: 100%;\n    }\n}\n",paraId:220,tocIndex:48},{value:"首先通过 offsetPath 创建一条运动轨迹，目前支持 ",paraId:221,tocIndex:48},{value:"Line",paraId:222,tocIndex:48},{value:" ",paraId:221,tocIndex:48},{value:"Path",paraId:223,tocIndex:48},{value:" 和 ",paraId:221,tocIndex:48},{value:"Polyline",paraId:224,tocIndex:48},{value:"。然后通过对 offsetDistance （取值范围 ",paraId:221,tocIndex:48},{value:"[0-1]",paraId:221,tocIndex:48},{value:"）进行变换实现该效果：",paraId:221,tocIndex:48},{value:"const circle = new Circle({\n    style: {\n        offsetPath: new Line({\n            // 创建运动轨迹\n            style: {\n                // 不需要设置其他与轨迹无关的绘图属性\n                x1: 100,\n                y1: 100,\n                x2: 300,\n                y2: 100,\n            },\n        }),\n        r: 10,\n    },\n});\n\ncircle.animate(\n    [\n        { offsetDistance: 0 }, // 变换\n        { offsetDistance: 1 },\n    ],\n    {\n        duration: 3000,\n        easing: 'ease-in-out',\n        iterations: Infinity,\n    },\n);\n",paraId:225,tocIndex:48},{value:"完整示例",paraId:226,tocIndex:48},{value:"效果如下： ",paraId:227,tocIndex:48},{value:"在 PS 中常见的套索工具就是一种“蚂蚁线”效果。",paraId:228,tocIndex:49},{value:"lineDashOffset",paraId:229,tocIndex:49},{value:" 属性用来设置虚线的偏移量，对它进行变换就可以实现该效果：",paraId:230,tocIndex:49},{value:"const circle = new Circle({\n    style: {\n        // 省略其他绘图属性\n        lineDash: [10, 10],\n    },\n});\ncircle.animate([{ lineDashOffset: -20 }, { lineDashOffset: 0 }], {\n    duration: 500,\n    iterations: Infinity,\n});\n",paraId:231,tocIndex:49},{value:"完整示例",paraId:232,tocIndex:49},{value:"效果如下： ",paraId:233,tocIndex:49},{value:"一种常见的动画效果是让描边的轨迹从无到有展现出来，",paraId:234,tocIndex:50},{value:"lineDash",paraId:235,tocIndex:50},{value:" 属性指定了描边实线和间隔的长度，笔迹初始状态“无”可以用 ",paraId:234,tocIndex:50},{value:"[0, length]",paraId:234,tocIndex:50},{value:" 表示，而完整状态可以用 ",paraId:234,tocIndex:50},{value:"[length, 0]",paraId:234,tocIndex:50},{value:" 表示。其中描边的长度可以通过图形上的方法取得，例如 Path 的 ",paraId:234,tocIndex:50},{value:"getTotalLength",paraId:236,tocIndex:50},{value:" 方法：",paraId:234,tocIndex:50},{value:"const length = path.getTotalLength();\npath.animate([{ lineDash: [0, length] }, { lineDash: [length, 0] }], {\n    duration: 3500,\n    easing: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)',\n    iterations: Infinity,\n    direction: 'alternate',\n});\n",paraId:237,tocIndex:50},{value:"完整示例",paraId:238,tocIndex:50},{value:"效果如下： ",paraId:239,tocIndex:50},{value:"在很多 SVG 相关的库中都能看到形变动画的例子，例如：",paraId:240,tocIndex:51},{value:"Paper.js",paraId:241,tocIndex:51},{value:"Kute.js",paraId:241,tocIndex:51},{value:" 提供了 ",paraId:241,tocIndex:51},{value:"Morph",paraId:241,tocIndex:51},{value:" 和 ",paraId:241,tocIndex:51},{value:"CubicMorph",paraId:241,tocIndex:51},{value:" 两个组件",paraId:241,tocIndex:51},{value:"Snap.svg",paraId:241,tocIndex:51},{value:"GreenSocks 提供的 ",paraId:241,tocIndex:51},{value:"MorphSVGPlugin",paraId:241,tocIndex:51},{value:" 插件甚至能在 Canvas 中渲染",paraId:241,tocIndex:51},{value:"以上部分库会要求变换前后的路径定义包含相同的分段，不然无法进行插值。",paraId:242,tocIndex:51},{value:"G 参考了 Kute.js 中的 ",paraId:243,tocIndex:51},{value:"CubicMorph",paraId:243,tocIndex:51},{value:"，首先将 Path 定义中的各个部分转成三阶贝塞尔曲线表示，然后利用三阶贝塞尔曲线易于分割的特性，将变换前后的路径规范到相同数目的分段，最后对各个分段中的控制点进行插值实现动画效果：",paraId:243,tocIndex:51},{value:"// 定义 Path\nconst path1 = 'M 0,40 ...';\nconst path2 = [\n    ['M', 100, 100],\n    ['L', 200, 200],\n];\n\npath.animate([{ path: path1 }, { path: path2 }], {\n    duration: 2500,\n    easing: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)',\n    iterations: Infinity,\n    direction: 'alternate',\n});\n",paraId:244,tocIndex:51},{value:"完整示例",paraId:245,tocIndex:51},{value:"效果如下： ",paraId:246,tocIndex:51},{value:"由于只能对 path 属性进行变换，对于其他基础图形例如 Circle、Rect、Line，我们提供了工具方法 ",paraId:247,tocIndex:52},{value:"convertToPath",paraId:248,tocIndex:52},{value:" 进行转换：",paraId:247,tocIndex:52},{value:"import { Circle, convertToPath } from '@antv/g';\n\nconst circle = new Circle({\n    style: {\n        cx: 50,\n        cy: 50,\n        r: 50,\n    },\n});\nconst circlePath = convertToPath(circle); // 转换得到 Path 字符串\n\npath.animate([{ path: originalPath }, { path: circlePath }], {\n    duration: 2500,\n});\n",paraId:249,tocIndex:52},{value:"目前支持转换路径的基础图形有：",paraId:250,tocIndex:52},{value:"Circle",paraId:251,tocIndex:52},{value:" ",paraId:250,tocIndex:52},{value:"Ellipse",paraId:252,tocIndex:52},{value:" ",paraId:250,tocIndex:52},{value:"Rect",paraId:253,tocIndex:52},{value:" ",paraId:250,tocIndex:52},{value:"Line",paraId:254,tocIndex:52},{value:" ",paraId:250,tocIndex:52},{value:"Polyline",paraId:255,tocIndex:52},{value:" ",paraId:250,tocIndex:52},{value:"Polygon",paraId:256,tocIndex:52},{value:" ",paraId:250,tocIndex:52},{value:"Path",paraId:257,tocIndex:52},{value:"。 ",paraId:250,tocIndex:52},{value:"完整示例",paraId:258,tocIndex:52},{value:"需要注意的是，对这些基础图形的变换会影响到最终生成的 path 字符串。例如下面的五角星原始路径尺寸太大，我们可以缩放后进行动画：",paraId:259,tocIndex:52},{value:"const starPath = new Path({\n    style: {\n        path: 'M301.113,12.011l99.25,179.996l201.864,38.778L461.706,380.808l25.508,203.958l-186.101-87.287L115.01,584.766l25.507-203.958L0,230.785l201.86-38.778L301.113,12.011',\n    },\n});\nstarPath.scale(0.2); // 先缩放\nconst pathString = convertToPath(starPath); // 再转换成 path 字符串\n",paraId:260,tocIndex:52},{value:"在形变动画中，我们暂不支持多于两组 keyframes，例如：",paraId:261,tocIndex:53},{value:"path.animate(\n    [\n        // 使用了三组 keyframes\n        { path: path1 },\n        { path: path2 },\n        { path: path3 },\n    ],\n    {\n        duration: 2500,\n    },\n);\n",paraId:262,tocIndex:53},{value:"对于多个 path 间的连续变化，可以拆成多个 Animation，例如：",paraId:263,tocIndex:53},{value:"const animation1 = path.animate([{ path: path1 }, { path: path2 }], {\n    duration: 1250,\n    fill: 'both',\n});\n\nanimation1.finished.then(() => {\n    path.animate([{ path: path2 }, { path: path3 }], {\n        duration: 1250,\n        fill: 'both',\n    });\n});\n",paraId:264,tocIndex:53},{value:"在 ",paraId:265,tocIndex:54},{value:"g-webgl",paraId:265,tocIndex:54},{value:" 中支持基于 WebGL Transform Feedback 的 GPU 动画。",paraId:265,tocIndex:54}]},25434:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(40486);const d=[{value:"可以参考 SVG 的 ",paraId:0},{value:"<circle>",paraId:0},{value:" 元素。",paraId:0},{value:"如下 ",paraId:1},{value:"示例",paraId:2},{value:" 绘制了一个圆心在 ",paraId:1},{value:"[100, 100]",paraId:1},{value:"，半径为 ",paraId:1},{value:"100",paraId:1},{value:" 的圆：",paraId:1},{value:"const circle = new Circle({\n    style: {\n        cx: 100,\n        cy: 100,\n        r: 100,\n    },\n});\n",paraId:3},{value:"继承了 ",paraId:4,tocIndex:0},{value:"DisplayObject",paraId:5,tocIndex:0},{value:" 的 ",paraId:4,tocIndex:0},{value:"样式属性",paraId:6,tocIndex:0},{value:"。",paraId:4,tocIndex:0},{value:"默认值为 ",paraId:7,tocIndex:1},{value:"[0.5, 0.5]",paraId:7,tocIndex:1},{value:"。详见 ",paraId:7,tocIndex:1},{value:"DisplayObject anchor",paraId:8,tocIndex:1},{value:"默认值为 ",paraId:9,tocIndex:2},{value:"center",paraId:9,tocIndex:2},{value:"。详见 ",paraId:9,tocIndex:2},{value:"DisplayObject transformOrigin",paraId:10,tocIndex:2},{value:"圆心在局部坐标系下的 x 轴坐标。",paraId:11,tocIndex:4},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/cx",paraId:12,tocIndex:4},{value:"初始值",paraId:13,tocIndex:4},{value:"适用元素",paraId:14,tocIndex:4},{value:"是否可继承",paraId:15,tocIndex:4},{value:"是否支持动画",paraId:14,tocIndex:4},{value:"计算值",paraId:16,tocIndex:4},{value:"'0'",paraId:14,tocIndex:4},{value:"-",paraId:14,tocIndex:4},{value:"否",paraId:14,tocIndex:4},{value:"是",paraId:14,tocIndex:4},{value:"<percentage>",paraId:17,tocIndex:4},{value:" ",paraId:14,tocIndex:4},{value:"<length>",paraId:18,tocIndex:4},{value:"圆心在局部坐标系下的 y 轴坐标。",paraId:19,tocIndex:5},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/cy",paraId:20,tocIndex:5},{value:"初始值",paraId:21,tocIndex:5},{value:"适用元素",paraId:22,tocIndex:5},{value:"是否可继承",paraId:23,tocIndex:5},{value:"是否支持动画",paraId:22,tocIndex:5},{value:"计算值",paraId:24,tocIndex:5},{value:"'0'",paraId:22,tocIndex:5},{value:"-",paraId:22,tocIndex:5},{value:"否",paraId:22,tocIndex:5},{value:"是",paraId:22,tocIndex:5},{value:"<percentage>",paraId:25,tocIndex:5},{value:" ",paraId:22,tocIndex:5},{value:"<length>",paraId:26,tocIndex:5},{value:"圆的半径。",paraId:27,tocIndex:6},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/r",paraId:28,tocIndex:6},{value:"初始值",paraId:29,tocIndex:6},{value:"适用元素",paraId:30,tocIndex:6},{value:"是否可继承",paraId:31,tocIndex:6},{value:"是否支持动画",paraId:30,tocIndex:6},{value:"计算值",paraId:32,tocIndex:6},{value:"'0'",paraId:30,tocIndex:6},{value:"-",paraId:30,tocIndex:6},{value:"否",paraId:30,tocIndex:6},{value:"是",paraId:30,tocIndex:6},{value:"<percentage>",paraId:33,tocIndex:6},{value:" ",paraId:30,tocIndex:6},{value:"<length>",paraId:34,tocIndex:6}]},15560:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(52055);const d=[{value:"首先需要明确一些概念，例如包围盒、坐标、锚点、变换中心等。了解它们有助于更好地使用具体的 API。",paraId:0},{value:"在",paraId:1,tocIndex:0},{value:"场景图",paraId:2,tocIndex:0},{value:"中我们了解到可以在图形之间构建父子关系，这种父子关系有时会与我们的直觉相悖，例如给一根直线（",paraId:1,tocIndex:0},{value:"Line",paraId:3,tocIndex:0},{value:"）添加一个子节点文本（",paraId:1,tocIndex:0},{value:"Text",paraId:4,tocIndex:0},{value:"）：",paraId:1,tocIndex:0},{value:"line.appendChild(text);\n",paraId:5,tocIndex:0},{value:"但本质上这种层次结构只是定义了一种父子关系，在计算变换时把它考虑进去。例如我们不需要再单独移动直线以及文本，基于这种父子关系，移动直线即可，文本会跟随它移动。在变换过程中，文本相对于直线的位置始终并没有变，即文本在父节点直线的局部坐标系下的坐标没有变。",paraId:6,tocIndex:0},{value:"为了简化计算，我们需要用一个规则的几何体包裹住图形，通常使用",paraId:7,tocIndex:1},{value:"轴对齐包围盒",paraId:7,tocIndex:1},{value:"（Axis Aligned Bounding Box），它是一个非旋转的立方体，下图来自：",paraId:7,tocIndex:1},{value:"https://developer.mozilla.org/zh-CN/docs/Games/Techniques/3D_collision_detection#axis-aligned_bounding_boxes%EF%BC%88aabb%E5%8C%85%E5%9B%B4%E7%9B%92%EF%BC%89",paraId:7,tocIndex:1},{value:" ",paraId:7,tocIndex:1},{value:"我们使用如下定义：",paraId:8,tocIndex:1},{value:"interface AABB {\n    center: [number, number, number]; // 中心坐标\n    halfExtents: [number, number, number]; // 长宽高的一半\n    min: [number, number, number]; // 左上角坐标\n    max: [number, number, number]; // 右下角坐标\n}\n",paraId:9,tocIndex:1},{value:"在不同情况下，包围盒有不同的含义。我们先看针对单一图形的包围盒代表什么。下图展示了一个半径为 100，边框宽度为 20 的圆，为了更好的说明我们把边框设置成了半透明，同时它还带有阴影效果。",paraId:10,tocIndex:1},{value:"对于用户而言，通常希望使用图形的几何定义，例如这个圆的尺寸就是 ",paraId:11,tocIndex:1},{value:"100 * 100",paraId:11,tocIndex:1},{value:"，我们不希望鼠标滑过阴影区域也判定拾取到这个圆。",paraId:11,tocIndex:1},{value:"而对于渲染管线而言，这些样式属性显然都需要考虑进去，例如：",paraId:12,tocIndex:1},{value:"在脏矩形渲染中正确的擦除绘制区域，一旦不考虑阴影带来的包围盒尺寸增加，就会出现擦除不干净的“残影”",paraId:13,tocIndex:1},{value:"剔除插件也需要考虑，例如一个图形即使只有阴影部分出现在视口中，它也不应被剔除",paraId:13,tocIndex:1},{value:"我们很容易根据不同类型的图形定义几何包围盒：",paraId:14,tocIndex:1},{value:"Geometry Bounds",paraId:15,tocIndex:1},{value:"。仅由图形的几何定义决定（因此 ",paraId:15,tocIndex:1},{value:"Group",paraId:16,tocIndex:1},{value:" 会返回 null），不考虑绝大部分绘图属性（几何定义必须的除外，例如 ",paraId:15,tocIndex:1},{value:"Circle",paraId:17,tocIndex:1},{value:" 的半径、",paraId:15,tocIndex:1},{value:"Rect",paraId:18,tocIndex:1},{value:" 的宽高、",paraId:15,tocIndex:1},{value:"Path",paraId:19,tocIndex:1},{value:" 的路径定义等），也不考虑变换（例如放大缩小并不会改变）。可通过 ",paraId:15,tocIndex:1},{value:"getGeometryBounds",paraId:20,tocIndex:1},{value:" 获取",paraId:15,tocIndex:1},{value:"前面介绍过基于场景图的层次结构，一旦一个图形拥有了子节点，它在计算包围盒时也应当考虑，例如我们想对它做整体旋转时，需要找到这个包围盒的中心作为旋转中心。因此以下包围盒都是会考虑层次结构的：",paraId:21,tocIndex:1},{value:"Bounds",paraId:22,tocIndex:1},{value:"。在世界坐标系下计算，合并自身以及所有子节点的 Geometry Bounds 得到。用户通常最常用这个包围盒。可通过 ",paraId:22,tocIndex:1},{value:"getBounds",paraId:23,tocIndex:1},{value:" 获取",paraId:22,tocIndex:1},{value:"Local Bounds",paraId:22,tocIndex:1},{value:"。和 Bounds 的唯一区别是在父节点的局部坐标系下计算。可通过 ",paraId:22,tocIndex:1},{value:"getLocalBounds",paraId:24,tocIndex:1},{value:" 获取",paraId:22,tocIndex:1},{value:"Render Bounds",paraId:22,tocIndex:1},{value:"。在世界坐标系下计算，在 Bounds 的基础上，受部分绘图属性影响，例如边框宽度，阴影，部分滤镜等，同时合并所有子节点的 Render Bounds。可通过 ",paraId:22,tocIndex:1},{value:"getRenderBounds",paraId:25,tocIndex:1},{value:" 获取。用户通常不关心这个包围盒。",paraId:22,tocIndex:1},{value:"在下图中，ul1 拥有两个字节点 li1 和 li2，在计算自身的 Geometry Bounds 时不会考虑它们，而在计算 Bounds 时需要。由于 ul1 还有阴影，因此它的 Render Bounds 要大一圈：",paraId:26,tocIndex:1},{value:"一个图形的锚点（原点）应该如何定义呢？我们可以基于 ",paraId:27,tocIndex:2},{value:"Geometry Bounds",paraId:28,tocIndex:2},{value:" 定义，取值范围 ",paraId:27,tocIndex:2},{value:"[0, 0] ~ [1, 1]",paraId:27,tocIndex:2},{value:"，其中 ",paraId:27,tocIndex:2},{value:"[0, 0]",paraId:27,tocIndex:2},{value:" 代表 Geometry Bounds 左上角，",paraId:27,tocIndex:2},{value:"[1, 1]",paraId:27,tocIndex:2},{value:" 代表右下角。而不同图形由于几何定义不同，默认锚点如下：",paraId:27,tocIndex:2},{value:"Circle",paraId:29,tocIndex:2},{value:"，",paraId:30,tocIndex:2},{value:"Ellipse",paraId:31,tocIndex:2},{value:" 为圆心位置 ",paraId:30,tocIndex:2},{value:"[0.5, 0.5]",paraId:30,tocIndex:2},{value:"Rect",paraId:32,tocIndex:2},{value:"，",paraId:30,tocIndex:2},{value:"Image",paraId:33,tocIndex:2},{value:"，",paraId:30,tocIndex:2},{value:"Line",paraId:34,tocIndex:2},{value:"，",paraId:30,tocIndex:2},{value:"Polyline",paraId:35,tocIndex:2},{value:"，",paraId:30,tocIndex:2},{value:"Polygon",paraId:36,tocIndex:2},{value:"，",paraId:30,tocIndex:2},{value:"Path",paraId:37,tocIndex:2},{value:" 为包围盒左上角顶点位置 ",paraId:30,tocIndex:2},{value:"[0, 0]",paraId:30,tocIndex:2},{value:"Text",paraId:38,tocIndex:2},{value:" 为文本锚点位置，应该使用 ",paraId:30,tocIndex:2},{value:"textBaseline",paraId:30,tocIndex:2},{value:" 与 ",paraId:30,tocIndex:2},{value:"textAlign",paraId:39,tocIndex:2},{value:" 这两个属性设置，因此设置此属性无效",paraId:30,tocIndex:2},{value:"Group",paraId:40,tocIndex:2},{value:" 无几何定义，因此锚点始终为 ",paraId:30,tocIndex:2},{value:"[0, 0]",paraId:30,tocIndex:2},{value:"，设置此属性也无效",paraId:30,tocIndex:2},{value:"有时我们希望改变一个基础图形的原点定义，例如将 Rect 的原点定义为中心而非左上角，",paraId:41,tocIndex:2},{value:"示例",paraId:42,tocIndex:2},{value:"：",paraId:41,tocIndex:2},{value:"rect.style.anchor = [0.5, 0.5];\n",paraId:43,tocIndex:2},{value:"那锚点的改变会影响图形在局部/世界坐标系下的坐标吗？答案是不会。我们只是把图形的原点放在这个坐标下而已，无论原点的定义如何修改，这个“位置”坐标始终不会改变：",paraId:44,tocIndex:2},{value:"rect.getPosition(); // [200, 200]\nrect.style.anchor = [0.5, 0.5];\nrect.getPosition(); // [200, 200]\n",paraId:45,tocIndex:2},{value:"对图形进行缩放、旋转变换时，需要指定一个变换中心。例如同样是 ",paraId:46,tocIndex:3},{value:"scale(2)",paraId:46,tocIndex:3},{value:"，以圆心作为变换中心与圆的 Geometry Bounds 左上角为变换中心，最终得到的效果完全不一样。在 ",paraId:46,tocIndex:3},{value:"gl-matrix",paraId:46,tocIndex:3},{value:" 这样的库中，得到 RTS 变换矩阵通常也需要指定变换中心：",paraId:46,tocIndex:3},{value:"mat4.fromRotationTranslationScaleOrigin();\n",paraId:47,tocIndex:3},{value:"在某些场景下，用一些字面量或者百分比定义会更方便。例如 CSS 就提供了 ",paraId:48,tocIndex:3},{value:"transform-origin",paraId:48,tocIndex:3},{value:" 属性，它正是相对于 Bounds 进行定义的，下图来自：",paraId:48,tocIndex:3},{value:"https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin：",paraId:48,tocIndex:3},{value:"当我们想实现“绕中心点旋转”时，只需要使用字面量或者百分比，这样就能避免进行 Bounds 的获取：",paraId:49,tocIndex:3},{value:"group.style.transformOrigin = 'center';\ngroup.style.transformOrigin = 'center center';\ngroup.style.transformOrigin = '50% 50%';\n",paraId:50,tocIndex:3}]},85547:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(47787);const d=[{value:"DisplayObject 是所有图形的基类，例如 ",paraId:0},{value:"Group",paraId:1},{value:" ",paraId:0},{value:"Circle",paraId:2},{value:" ",paraId:0},{value:"Text",paraId:3},{value:" 等都会继承它。",paraId:0},{value:"我们尝试让它尽可能兼容 ",paraId:4},{value:"DOM Element",paraId:4},{value:"，除了能降低学习成本，还能将自身伪装成 DOM Element 来充分利用已有的 Web 生态，例如：",paraId:4},{value:"使用 CSS 选择器进行",paraId:5},{value:"高级查询",paraId:6},{value:"使用 Hammer.js ",paraId:5},{value:"扩展手势",paraId:7},{value:"使用 Interact.js ",paraId:5},{value:"实现 Drag&Drop，Resize",paraId:8},{value:"保留 D3 的数据处理，",paraId:5},{value:"替换渲染层",paraId:9},{value:"保留 Observable Plot 的数据处理，",paraId:5},{value:"替换渲染层",paraId:10},{value:"Element",paraId:11},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Element/id",paraId:12,tocIndex:1},{value:"全局唯一的标识，可通过 ",paraId:13,tocIndex:1},{value:"getElementById",paraId:14,tocIndex:1},{value:" 查询。",paraId:13,tocIndex:1},{value:"const circle = new Circle({\n    id: 'my-circle-id',\n    style: {\n        r: 10,\n    },\n});\ncircle.id; // 'my-circle-id'\ncanvas.getElementById('my-circle-id'); // circle\n",paraId:15,tocIndex:1},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName",paraId:16,tocIndex:2},{value:"图形名称，不要求全局唯一，可通过 ",paraId:17,tocIndex:2},{value:"getElementsByName",paraId:18,tocIndex:2},{value:" 查询。",paraId:17,tocIndex:2},{value:"const circle = new Circle({\n    name: 'my-circle-name',\n    style: {\n        r: 10,\n    },\n});\ncircle.name; // 'my-circle-name'\ncanvas.getElementsByName('my-circle-name'); // [circle]\n",paraId:19,tocIndex:2},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Element/className",paraId:20,tocIndex:3},{value:"图形拥有的类名，可通过它获取/设置图形的类名。后续可以使用 ",paraId:21,tocIndex:3},{value:"getElementsByClassName",paraId:22,tocIndex:3},{value:" 查询。",paraId:21,tocIndex:3},{value:"const circle = new Circle({\n    className: 'my-circle-classname',\n    style: {\n        r: 10,\n    },\n});\ncircle.className; // 'my-circle-classname'\ncanvas.getElementsByClassName('my-circle-classname'); // [circle]\n",paraId:23,tocIndex:3},{value:"可以使用空格隔开多个类名，随后使用 ",paraId:24,tocIndex:3},{value:"classList",paraId:25,tocIndex:3},{value:" 只读属性获取类名列表：",paraId:24,tocIndex:3},{value:"circle.className = 'c1 c2';\ncircle.classList; // ['c1', 'c2']\n",paraId:26,tocIndex:3},{value:"未指定类名将返回空字符串：",paraId:27,tocIndex:3},{value:"const group = new Group();\ngroup.className; // ''\n",paraId:28,tocIndex:3},{value:"最后在设置时还可以使用 ",paraId:29,tocIndex:3},{value:"class",paraId:29,tocIndex:3},{value:" 作为别名：",paraId:29,tocIndex:3},{value:"const group = new Group({\n    class: 'my-classname',\n    // className: 'my-classname'\n});\n\ngroup.setAttribute('class', 'my-classname');\n\n// 但不可以使用 class 属性，为保留字\ngroup.class;\n",paraId:30,tocIndex:3},{value:"是否支持响应",paraId:31,tocIndex:4},{value:"事件",paraId:32,tocIndex:4},{value:"，默认为 ",paraId:31,tocIndex:4},{value:"true",paraId:31,tocIndex:4},{value:"。在某些不需要支持交互的图形上可以关闭。",paraId:31,tocIndex:4},{value:"例如我们不想让下面这个圆响应鼠标 ",paraId:33,tocIndex:4},{value:"mouseenter/leave",paraId:33,tocIndex:4},{value:" 事件，",paraId:33,tocIndex:4},{value:"示例",paraId:34,tocIndex:4},{value:"// 初始化时禁止交互\nconst circle = new Circle({\n    interactive: false,\n    style: {\n        r: 100,\n    },\n});\n\n// 或者后续禁止\ncircle.interactive = false;\n",paraId:35,tocIndex:4},{value:"推荐使用 ",paraId:36,tocIndex:4},{value:"pointerEvents",paraId:37,tocIndex:4},{value:" 属性，因此上面禁止交互的操作等同于：",paraId:36,tocIndex:4},{value:"circle.style.pointerEvents = 'none';\n",paraId:38,tocIndex:4},{value:"绘图属性通过 ",paraId:39,tocIndex:5},{value:"style",paraId:39,tocIndex:5},{value:" 设置，通常包含了填充色、透明度等",paraId:39,tocIndex:5},{value:"通用属性",paraId:39,tocIndex:5},{value:"，不同类型的图形也有自己的",paraId:39,tocIndex:5},{value:"额外属性",paraId:39,tocIndex:5},{value:"，例如在下面的圆角矩形中，填充色 ",paraId:39,tocIndex:5},{value:"fill",paraId:39,tocIndex:5},{value:"、描边色 ",paraId:39,tocIndex:5},{value:"stroke",paraId:39,tocIndex:5},{value:" 就是通用属性，而矩形的左上角顶点位置",paraId:39,tocIndex:5},{value:"(x, y)",paraId:39,tocIndex:5},{value:"、尺寸 ",paraId:39,tocIndex:5},{value:"width/height",paraId:39,tocIndex:5},{value:" 和圆角半径 ",paraId:39,tocIndex:5},{value:"radius",paraId:39,tocIndex:5},{value:" 则是额外属性：",paraId:39,tocIndex:5},{value:"const rect = new Rect({\n    style: {\n        // 或者使用 attrs\n        x: 200,\n        y: 100,\n        fill: '#1890FF',\n        stroke: '#F04864',\n        lineWidth: 4,\n        width: 300,\n        height: 200,\n        radius: 8,\n    },\n});\n",paraId:40,tocIndex:5},{value:"属性名也可以使用连字符形式，因此以下写法完全等同，完整用法详见",paraId:41,tocIndex:5},{value:"获取/设置属性值",paraId:42,tocIndex:5},{value:"：",paraId:41,tocIndex:5},{value:"const rect = new Rect({\n    'line-width': 4,\n    // lineWidth: 4,\n});\n\nrect.style.lineWidth = 4;\nrect.style['line-width'] = 4;\nrect.style.setProperty('lineWidth', 4);\nrect.style.setProperty('line-width', 4);\n",paraId:43,tocIndex:5},{value:"图形在局部坐标系下的初始位置，根据图形种类使用不同属性描述，后续也可以通过 ",paraId:44,tocIndex:6},{value:"setLocalPosition",paraId:45,tocIndex:6},{value:" 重新设置。",paraId:44,tocIndex:6},{value:"我们提供了在局部坐标系下进行变换的快捷方式，同时与 ",paraId:46,tocIndex:7},{value:"CSS Transform",paraId:46,tocIndex:7},{value:" 保持一致，支持以下",paraId:46,tocIndex:7},{value:"transform-function 变换函数",paraId:46,tocIndex:7},{value:"：",paraId:46,tocIndex:7},{value:"缩放，无单位\n",paraId:47,tocIndex:7},{value:"scale(x, y)",paraId:48,tocIndex:7},{value:"scaleX(x)",paraId:48,tocIndex:7},{value:"scaleY(x)",paraId:48,tocIndex:7},{value:"scaleZ(z)",paraId:48,tocIndex:7},{value:"scale3d(x, y, z)",paraId:48,tocIndex:7},{value:"平移，0 可以不加单位，无单位当作 px 处理，百分比相对于当前图形包围盒\n",paraId:47,tocIndex:7},{value:"translate(0, 0) translate(0, 30px) translate(100%, 100%)",paraId:49,tocIndex:7},{value:"translateX(0)",paraId:49,tocIndex:7},{value:"translateY(0)",paraId:49,tocIndex:7},{value:"translateZ(0)",paraId:49,tocIndex:7},{value:"translate3d(0, 0, 0)",paraId:49,tocIndex:7},{value:"旋转，支持 deg rad turn 这些角度单位\n",paraId:47,tocIndex:7},{value:"rotate(0.5turn) rotate(30deg) rotate(1rad)",paraId:50,tocIndex:7},{value:"拉伸，支持 deg rad turn 这些角度单位\n",paraId:47,tocIndex:7},{value:"skew(ax, ay)",paraId:51,tocIndex:7},{value:"skewX(a)",paraId:51,tocIndex:7},{value:"skewY(a)",paraId:51,tocIndex:7},{value:"矩阵\n",paraId:47,tocIndex:7},{value:"matrix()",paraId:52,tocIndex:7},{value:"matrix3d()",paraId:52,tocIndex:7},{value:"none 清除变换",paraId:47,tocIndex:7},{value:"初始值",paraId:53,tocIndex:7},{value:"适用元素",paraId:54,tocIndex:7},{value:"是否可继承",paraId:55,tocIndex:7},{value:"是否支持动画",paraId:54,tocIndex:7},{value:"计算值",paraId:56,tocIndex:7},{value:"'none'",paraId:54,tocIndex:7},{value:"所有",paraId:54,tocIndex:7},{value:"否",paraId:54,tocIndex:7},{value:"是",paraId:54,tocIndex:7},{value:"<transform>",paraId:54,tocIndex:7},{value:"由于是在局部坐标系下进行变换，因此以下写法在视觉效果上一致：",paraId:57,tocIndex:7},{value:"// 使用 transform 属性\nconst circle = new Circle({\n    style: {\n        transform: 'translate(100px, 100px)',\n        r: 100,\n    },\n});\n\n// 直接设置 cx/cy\nconst circle = new Circle({\n    style: {\n        cx: 100,\n        cy: 100,\n        r: 100,\n    },\n});\n\n// 使用变换方法\nconst circle = new Circle({\n    style: {\n        r: 100,\n    },\n});\ncircle.translateLocal(100, 100);\n",paraId:58,tocIndex:7},{value:"旋转与缩放中心，也称作变换中心，相对于 Bounds 定义。",paraId:59,tocIndex:8},{value:"和 CSS ",paraId:60,tocIndex:8},{value:"transform-origin",paraId:60,tocIndex:8},{value:" 类似，支持以下字符串写法，其中用空格分隔：",paraId:60,tocIndex:8},{value:"一个值\n",paraId:61,tocIndex:8},{value:"单位为 px 的长度，例如 10px",paraId:62,tocIndex:8},{value:"单位为 % 的长度，例如 50%",paraId:62,tocIndex:8},{value:"关键词 left, center, right, top, bottom，等于用百分比表示，例如 left 等于 0%，center 等于 50%",paraId:62,tocIndex:8},{value:"两个值\n",paraId:61,tocIndex:8},{value:"第一个是单位为 px 或 % 的长度，或 left, center, right 关键字中的一个",paraId:63,tocIndex:8},{value:"第二个是单位为 px 或 % 的长度，或 top, center, bottom 关键字中的一个",paraId:63,tocIndex:8},{value:"因此以下写法等价：",paraId:64,tocIndex:8},{value:"// r = 100\ncircle.style.transformOrigin = 'left';\ncircle.style.transformOrigin = 'left center'; // 包围盒水平方向左侧边缘，垂直方向中点\ncircle.style.transformOrigin = '0 50%'; // 包围盒水平方向左侧边缘距离为 0，垂直方向距离顶部 50% 高度\ncircle.style.transformOrigin = '0 100px'; // 包围盒水平方向左侧边缘距离为 0，垂直方向距离顶部 100px\n",paraId:65,tocIndex:8},{value:"⚠️ 暂不支持三个值的写法。",paraId:66,tocIndex:8},{value:"不同图形的默认值也不同：",paraId:67,tocIndex:8},{value:"Text",paraId:68,tocIndex:8},{value:" 为文本锚点位置，应该使用 ",paraId:69,tocIndex:8},{value:"textBaseline",paraId:69,tocIndex:8},{value:" 与 ",paraId:69,tocIndex:8},{value:"textAlign",paraId:70,tocIndex:8},{value:" 这两个属性设置，因此设置此属性无效",paraId:69,tocIndex:8},{value:"初始值",paraId:71,tocIndex:8},{value:"适用元素",paraId:72,tocIndex:8},{value:"是否可继承",paraId:73,tocIndex:8},{value:"是否支持动画",paraId:72,tocIndex:8},{value:"计算值",paraId:74,tocIndex:8},{value:"不同图形各异",paraId:72,tocIndex:8},{value:"所有",paraId:72,tocIndex:8},{value:"否",paraId:72,tocIndex:8},{value:"否",paraId:72,tocIndex:8},{value:"<transform-origin>",paraId:72,tocIndex:8},{value:"图形整体透明度，取值范围为 ",paraId:75,tocIndex:10},{value:"[0, 1]",paraId:75,tocIndex:10},{value:"，支持 ",paraId:75,tocIndex:10},{value:"number",paraId:75,tocIndex:10},{value:" 与 ",paraId:75,tocIndex:10},{value:"string",paraId:75,tocIndex:10},{value:" 两种类型，因此以下两种写法等价：",paraId:75,tocIndex:10},{value:"circle.style.opacity = 0.5;\ncircle.style.opacity = '0.5';\n",paraId:76,tocIndex:10},{value:"初始值",paraId:77,tocIndex:10},{value:"适用元素",paraId:78,tocIndex:10},{value:"是否可继承",paraId:79,tocIndex:10},{value:"是否支持动画",paraId:78,tocIndex:10},{value:"计算值",paraId:80,tocIndex:10},{value:"'1'",paraId:78,tocIndex:10},{value:"所有",paraId:78,tocIndex:10},{value:"否",paraId:78,tocIndex:10},{value:"是",paraId:78,tocIndex:10},{value:"<number>",paraId:81,tocIndex:10},{value:"填充色透明度，取值范围为 ",paraId:82,tocIndex:11},{value:"[0, 1]",paraId:82,tocIndex:11},{value:"，支持 ",paraId:82,tocIndex:11},{value:"number",paraId:82,tocIndex:11},{value:" 与 ",paraId:82,tocIndex:11},{value:"string",paraId:82,tocIndex:11},{value:" 两种类型，因此以下两种写法等价：",paraId:82,tocIndex:11},{value:"circle.style.fillOpacity = 0.5;\ncircle.style.fillOpacity = '0.5';\n",paraId:83,tocIndex:11},{value:"初始值",paraId:84,tocIndex:11},{value:"适用元素",paraId:85,tocIndex:11},{value:"是否可继承",paraId:86,tocIndex:11},{value:"是否支持动画",paraId:85,tocIndex:11},{value:"计算值",paraId:87,tocIndex:11},{value:"'1'",paraId:85,tocIndex:11},{value:"所有",paraId:85,tocIndex:11},{value:"是",paraId:85,tocIndex:11},{value:"是",paraId:85,tocIndex:11},{value:"<number>",paraId:88,tocIndex:11},{value:"填充色，支持 ",paraId:89,tocIndex:12},{value:"string",paraId:89,tocIndex:12},{value:" 类型，详见 ",paraId:89,tocIndex:12},{value:"<paint>",paraId:90,tocIndex:12},{value:"：",paraId:89,tocIndex:12},{value:"circle.style.fill = 'red';\ncircle.style.fill = 'rgb(255, 0, 0)';\n",paraId:91,tocIndex:12},{value:"初始值",paraId:92,tocIndex:12},{value:"适用元素",paraId:93,tocIndex:12},{value:"是否可继承",paraId:94,tocIndex:12},{value:"是否支持动画",paraId:93,tocIndex:12},{value:"计算值",paraId:95,tocIndex:12},{value:"'none'",paraId:93,tocIndex:12},{value:"所有",paraId:93,tocIndex:12},{value:"否",paraId:93,tocIndex:12},{value:"是",paraId:93,tocIndex:12},{value:"<paint>",paraId:96,tocIndex:12},{value:"该属性定义了用来确定一个多边形内部区域的算法，支持以下取值：",paraId:97,tocIndex:13},{value:"'nonzero'",paraId:98,tocIndex:13},{value:" 默认值 ",paraId:98,tocIndex:13},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/fill-rule#nonzero",paraId:98,tocIndex:13},{value:"'evenodd'",paraId:98,tocIndex:13},{value:" ",paraId:98,tocIndex:13},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/fill-rule#evenodd",paraId:98,tocIndex:13},{value:"该 ",paraId:99,tocIndex:13},{value:"示例",paraId:100,tocIndex:13},{value:" 依次展示了 ",paraId:99,tocIndex:13},{value:"'nonzero'",paraId:99,tocIndex:13},{value:" 和 ",paraId:99,tocIndex:13},{value:"'evenodd'",paraId:99,tocIndex:13},{value:" 的填充效果：",paraId:99,tocIndex:13},{value:"描边透明度，取值范围为 ",paraId:101,tocIndex:15},{value:"[0, 1]",paraId:101,tocIndex:15},{value:"，支持 ",paraId:101,tocIndex:15},{value:"number",paraId:101,tocIndex:15},{value:" 与 ",paraId:101,tocIndex:15},{value:"string",paraId:101,tocIndex:15},{value:" 两种类型，因此以下两种写法等价：",paraId:101,tocIndex:15},{value:"circle.style.strokeOpacity = 0.5;\ncircle.style.strokeOpacity = '0.5';\n",paraId:102,tocIndex:15},{value:"初始值",paraId:103,tocIndex:15},{value:"适用元素",paraId:104,tocIndex:15},{value:"是否可继承",paraId:105,tocIndex:15},{value:"是否支持动画",paraId:104,tocIndex:15},{value:"计算值",paraId:106,tocIndex:15},{value:"'1'",paraId:104,tocIndex:15},{value:"所有",paraId:104,tocIndex:15},{value:"是",paraId:104,tocIndex:15},{value:"是",paraId:104,tocIndex:15},{value:"<number>",paraId:107,tocIndex:15},{value:"描边色，支持 ",paraId:108,tocIndex:16},{value:"string",paraId:108,tocIndex:16},{value:" 类型，详见 ",paraId:108,tocIndex:16},{value:"<paint>",paraId:109,tocIndex:16},{value:"：",paraId:108,tocIndex:16},{value:"circle.style.stroke = 'red';\ncircle.style.stroke = 'rgb(255, 0, 0)';\n",paraId:110,tocIndex:16},{value:"初始值",paraId:111,tocIndex:16},{value:"适用元素",paraId:112,tocIndex:16},{value:"是否可继承",paraId:113,tocIndex:16},{value:"是否支持动画",paraId:112,tocIndex:16},{value:"计算值",paraId:114,tocIndex:16},{value:"'none'",paraId:112,tocIndex:16},{value:"所有",paraId:112,tocIndex:16},{value:"否",paraId:112,tocIndex:16},{value:"是",paraId:112,tocIndex:16},{value:"<paint>",paraId:115,tocIndex:16},{value:"描边宽度。与我们熟悉的 ",paraId:116,tocIndex:17},{value:"CSS box model",paraId:116,tocIndex:17},{value:" 不同，边框的一半宽度在图形内，一半在图形外。例如下面这个圆的包围盒宽度为：",paraId:116,tocIndex:17},{value:"r + lineWidth / 2 = 110",paraId:116,tocIndex:17},{value:"支持 ",paraId:117,tocIndex:17},{value:"number",paraId:117,tocIndex:17},{value:" 和 ",paraId:117,tocIndex:17},{value:"string",paraId:117,tocIndex:17},{value:" 类型，前者默认为以 ",paraId:117,tocIndex:17},{value:"px",paraId:117,tocIndex:17},{value:" 为单位的长度值，以下写法等价：",paraId:117,tocIndex:17},{value:"circle.style.lineWidth = 1;\ncircle.style.lineWidth = '1';\ncircle.style.lineWidth = '1px';\n",paraId:118,tocIndex:17},{value:"初始值",paraId:119,tocIndex:17},{value:"适用元素",paraId:120,tocIndex:17},{value:"是否可继承",paraId:121,tocIndex:17},{value:"是否支持动画",paraId:120,tocIndex:17},{value:"计算值",paraId:122,tocIndex:17},{value:"'1'",paraId:120,tocIndex:17},{value:"所有",paraId:120,tocIndex:17},{value:"是",paraId:120,tocIndex:17},{value:"是",paraId:120,tocIndex:17},{value:"<percentage>",paraId:123,tocIndex:17},{value:" ",paraId:120,tocIndex:17},{value:"<length>",paraId:124,tocIndex:17},{value:"端点样式，支持以下取值：",paraId:125,tocIndex:18},{value:"'butt' 默认值。线段末端以方形结束。",paraId:126,tocIndex:18},{value:"'round' 线段末端以圆形结束。",paraId:126,tocIndex:18},{value:"'square' 线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域。",paraId:126,tocIndex:18},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineCap",paraId:127,tocIndex:18},{value:"连接处样式，支持以下取值：",paraId:128,tocIndex:19},{value:"'miter' 默认值。通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。这个设置可以通过 ",paraId:129,tocIndex:19},{value:"miterLimit",paraId:130,tocIndex:19},{value:" 属性看到效果。",paraId:129,tocIndex:19},{value:"'round' 通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。 圆角的半径是线段的宽度。",paraId:129,tocIndex:19},{value:"'bevel' 在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角。",paraId:129,tocIndex:19},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineJoin",paraId:131,tocIndex:19},{value:"斜接面限制比例。SVG 和 Canvas2D 的默认值不同，前者为 4 而后者为 10。我们给 ",paraId:132,tocIndex:20},{value:"Path",paraId:133,tocIndex:20},{value:" ",paraId:132,tocIndex:20},{value:"Polyline",paraId:134,tocIndex:20},{value:" ",paraId:132,tocIndex:20},{value:"Polygon",paraId:135,tocIndex:20},{value:" 这三种图形设置为 4，其余图形设置为 10。",paraId:132,tocIndex:20},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/miterLimit",paraId:136,tocIndex:20},{value:"使用 ",paraId:137,tocIndex:21},{value:"number[]",paraId:137,tocIndex:21},{value:" 描述交替绘制的线段和间距。可参考：",paraId:137,tocIndex:21},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/setLineDash",paraId:137,tocIndex:21},{value:"目前仅支持形如：",paraId:138,tocIndex:21},{value:"[dash, gap]",paraId:138,tocIndex:21},{value:" 的形式，如果数组中仅有一个元素，即 ",paraId:138,tocIndex:21},{value:"[dash]",paraId:138,tocIndex:21},{value:" 等价于 ",paraId:138,tocIndex:21},{value:"[dash, dash]",paraId:138,tocIndex:21},{value:"。",paraId:138,tocIndex:21},{value:"对它应用动画可以实现",paraId:139,tocIndex:21},{value:"笔迹动画效果",paraId:140,tocIndex:21},{value:"。",paraId:139,tocIndex:21},{value:"初始值",paraId:141,tocIndex:21},{value:"适用元素",paraId:142,tocIndex:21},{value:"是否可继承",paraId:143,tocIndex:21},{value:"是否支持动画",paraId:142,tocIndex:21},{value:"计算值",paraId:144,tocIndex:21},{value:"无",paraId:142,tocIndex:21},{value:"所有",paraId:142,tocIndex:21},{value:"是",paraId:142,tocIndex:21},{value:"是",paraId:142,tocIndex:21},{value:"虚线偏移量，",paraId:145,tocIndex:22},{value:"number",paraId:145,tocIndex:22},{value:" 类型，对它进行变换可以实现",paraId:145,tocIndex:22},{value:"蚂蚁线动画",paraId:146,tocIndex:22},{value:"初始值",paraId:147,tocIndex:22},{value:"适用元素",paraId:148,tocIndex:22},{value:"是否可继承",paraId:149,tocIndex:22},{value:"是否支持动画",paraId:148,tocIndex:22},{value:"计算值",paraId:150,tocIndex:22},{value:"'0'",paraId:148,tocIndex:22},{value:"所有",paraId:148,tocIndex:22},{value:"是",paraId:148,tocIndex:22},{value:"是",paraId:148,tocIndex:22},{value:"<percentage>",paraId:151,tocIndex:22},{value:" ",paraId:148,tocIndex:22},{value:"<length>",paraId:152,tocIndex:22},{value:"在图形底部增加阴影效果，支持配置阴影颜色，模糊半径和水平/垂直偏移距离。",paraId:153,tocIndex:23},{value:"示例",paraId:154,tocIndex:23},{value:"阴影不会影响图形的 ",paraId:155,tocIndex:23},{value:"Geometry Bounds",paraId:156,tocIndex:23},{value:"，例如下图中给一个半径为 100 的圆添加阴影后，几何包围盒尺寸不变：",paraId:155,tocIndex:23},{value:"circle.getBounds(); // { halfExtents: [100, 100] }\ncircle.style.shadowBlur = 20;\ncircle.getBounds(); // { halfExtents: [100, 100] }\n",paraId:157,tocIndex:23},{value:"当然外阴影会使 ",paraId:158,tocIndex:23},{value:"Render Bounds",paraId:159,tocIndex:23},{value:" 增大，内阴影则不会。",paraId:158,tocIndex:23},{value:"最后，阴影会对渲染性能造成非常大影响。",paraId:160,tocIndex:23},{value:"目前我们支持两种阴影：",paraId:161,tocIndex:24},{value:"'outer'",paraId:162,tocIndex:24},{value:" 外阴影，也是该属性的默认值。阴影出现在图形填充或者描边的外侧。",paraId:162,tocIndex:24},{value:"'inner'",paraId:162,tocIndex:24},{value:" 内阴影。顾名思义阴影在图形内部，如下图所示。",paraId:162,tocIndex:24},{value:"阴影色，支持 ",paraId:163,tocIndex:25},{value:"string",paraId:163,tocIndex:25},{value:" 类型，例如 ",paraId:163,tocIndex:25},{value:"'#1890FF'",paraId:163,tocIndex:25},{value:"。不支持渐变或者纹理写法。",paraId:163,tocIndex:25},{value:"初始值",paraId:164,tocIndex:25},{value:"适用元素",paraId:165,tocIndex:25},{value:"是否可继承",paraId:166,tocIndex:25},{value:"是否支持动画",paraId:165,tocIndex:25},{value:"计算值",paraId:167,tocIndex:25},{value:"无",paraId:165,tocIndex:25},{value:"所有",paraId:165,tocIndex:25},{value:"否",paraId:165,tocIndex:25},{value:"是",paraId:165,tocIndex:25},{value:"<color>",paraId:168,tocIndex:25},{value:"阴影效果模糊程度，",paraId:169,tocIndex:26},{value:"number",paraId:169,tocIndex:26},{value:" 类型，不允许为负数。越大代表越模糊，为 0 时无模糊效果。",paraId:169,tocIndex:26},{value:"初始值",paraId:170,tocIndex:26},{value:"适用元素",paraId:171,tocIndex:26},{value:"是否可继承",paraId:172,tocIndex:26},{value:"是否支持动画",paraId:171,tocIndex:26},{value:"计算值",paraId:173,tocIndex:26},{value:"无",paraId:171,tocIndex:26},{value:"所有",paraId:171,tocIndex:26},{value:"否",paraId:171,tocIndex:26},{value:"是",paraId:171,tocIndex:26},{value:"<number>",paraId:174,tocIndex:26},{value:"水平方向偏移量，支持 ",paraId:175,tocIndex:27},{value:"number",paraId:175,tocIndex:27},{value:" 或 ",paraId:175,tocIndex:27},{value:"string",paraId:175,tocIndex:27},{value:" 类型，例如负数让阴影往左移，正数向右",paraId:175,tocIndex:27},{value:"初始值",paraId:176,tocIndex:27},{value:"适用元素",paraId:177,tocIndex:27},{value:"是否可继承",paraId:178,tocIndex:27},{value:"是否支持动画",paraId:177,tocIndex:27},{value:"计算值",paraId:179,tocIndex:27},{value:"无",paraId:177,tocIndex:27},{value:"所有",paraId:177,tocIndex:27},{value:"否",paraId:177,tocIndex:27},{value:"是",paraId:177,tocIndex:27},{value:"<percentage>",paraId:180,tocIndex:27},{value:" ",paraId:177,tocIndex:27},{value:"<length>",paraId:181,tocIndex:27},{value:"垂直方向偏移量，例如负数让阴影往上移，正数向下",paraId:182,tocIndex:28},{value:"初始值",paraId:183,tocIndex:28},{value:"适用元素",paraId:184,tocIndex:28},{value:"是否可继承",paraId:185,tocIndex:28},{value:"是否支持动画",paraId:184,tocIndex:28},{value:"计算值",paraId:186,tocIndex:28},{value:"无",paraId:184,tocIndex:28},{value:"所有",paraId:184,tocIndex:28},{value:"否",paraId:184,tocIndex:28},{value:"是",paraId:184,tocIndex:28},{value:"<percentage>",paraId:187,tocIndex:28},{value:" ",paraId:184,tocIndex:28},{value:"<length>",paraId:188,tocIndex:28},{value:"滤镜（Filter）可以对已生成的图像进行一些处理，例如模糊、高亮、提升对比度等。在 Web 端有以下实现：",paraId:189,tocIndex:29},{value:"CSS Filter：",paraId:190,tocIndex:29},{value:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter",paraId:190,tocIndex:29},{value:"Canvas Filter：",paraId:190,tocIndex:29},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/filter",paraId:190,tocIndex:29},{value:"SVG Filter：",paraId:190,tocIndex:29},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/filter",paraId:190,tocIndex:29},{value:"WebGL 中一般称作后处理",paraId:190,tocIndex:29},{value:"参考 CSS Filter 语法，我们支持对图形应用一个或多个滤镜效果，",paraId:191,tocIndex:29},{value:"示例",paraId:192,tocIndex:29},{value:"：",paraId:191,tocIndex:29},{value:"circle.style.filter = 'blur(5px)';\ncircle.style.filter = 'blur(5px) brightness(0.4)'; // 可叠加\n",paraId:193,tocIndex:29},{value:"目前可以在 g-canvas/svg/webgl 渲染器中使用滤镜，有以下注意事项：",paraId:194,tocIndex:29},{value:"由于 Canvas Filter 支持度不佳，主要是 ",paraId:195,tocIndex:29},{value:"Safari 不支持",paraId:195,tocIndex:29},{value:"，因此使用 g-canvas 无法在 Safari 中正常展示滤镜",paraId:195,tocIndex:29},{value:"g-canvas 和 g-svg 在部分 filter 效果上略有差异",paraId:195,tocIndex:29},{value:"可以施加在所有基础图形以及 Group 上",paraId:195,tocIndex:29},{value:"该属性暂不支持动画",paraId:195,tocIndex:29},{value:"将高斯模糊应用于输入图像。其中 radius 定义了高斯函数的标准偏差值，或者屏幕上有多少像素相互融合，因此较大的值将产生更多的模糊，默认值为 0。该参数可以指定为 CSS 长度，但不接受百分比值。",paraId:196,tocIndex:30},{value:"和阴影一样，模糊同样不会影响图形的包围盒尺寸。",paraId:197,tocIndex:30},{value:"circle.style.filter = 'blur(5px)';\n",paraId:198,tocIndex:30},{value:"下图依次展示了 2px 4px 和 10px 的模糊效果，",paraId:199,tocIndex:30},{value:"示例",paraId:200,tocIndex:30},{value:"：",paraId:199,tocIndex:30},{value:"将线性乘法器应用于输入图像，让它变亮或变暗，默认值为 1。值为 0％ 将创建全黑图像。值为 100％ 会使输入保持不变。其他值是效果的线性乘数。如果值大于 100% 提供更明亮的结果。",paraId:201,tocIndex:31},{value:"circle.style.filter = 'brightness(2)';\ncircle.style.filter = 'brightness(200%)';\n",paraId:202,tocIndex:31},{value:"下图依次展示了 0 100% 和 200% 的明亮效果，",paraId:203,tocIndex:31},{value:"示例",paraId:204,tocIndex:31},{value:"：",paraId:203,tocIndex:31},{value:"在图像下展示阴影，可以设置阴影颜色、偏移量与模糊效果，依次传入以下参数：",paraId:205,tocIndex:32},{value:"offset-x 描述阴影的水平偏移距离，单位 px",paraId:206,tocIndex:32},{value:"offset-y 描述阴影的垂直偏移距离，单位 px",paraId:206,tocIndex:32},{value:"blur-radius 数值越大越模糊，单位 px，不允许为负数",paraId:206,tocIndex:32},{value:"color 阴影颜色",paraId:206,tocIndex:32},{value:"阴影不会影响图形的包围盒尺寸。",paraId:207,tocIndex:32},{value:"circle.style.filter = 'drop-shadow(16px 16px 10px black)';\n",paraId:208,tocIndex:32},{value:"下图依次展示了上面配置的效果，",paraId:209,tocIndex:32},{value:"示例",paraId:210,tocIndex:32},{value:"：",paraId:209,tocIndex:32},{value:"调节图像的对比度。当数值为 0% 时，图像会完全变黑。当数值为 100% 时，图像没有任何变化。",paraId:211,tocIndex:33},{value:"circle.style.filter = 'contrast(2)';\ncircle.style.filter = 'contrast(200%)';\n",paraId:212,tocIndex:33},{value:"下图依次展示了 0 1 和 10 的对比度效果，",paraId:213,tocIndex:33},{value:"示例",paraId:214,tocIndex:33},{value:"：",paraId:213,tocIndex:33},{value:"将图像转换成灰色的图片。当值为 100% 时，图像会完全变成灰色。 当值为 0% 时，图像没有任何变化。",paraId:215,tocIndex:34},{value:"circle.style.filter = 'grayscale(1)';\ncircle.style.filter = 'grayscale(100%)';\n",paraId:216,tocIndex:34},{value:"下图依次展示了 0 50% 和 100% 的灰度效果，",paraId:217,tocIndex:34},{value:"示例",paraId:218,tocIndex:34},{value:"：",paraId:217,tocIndex:34},{value:"对图像进行饱和度的处理。当值为 0% 时，图像完全不饱和。当值为 100% 时，图像没有任何变化。",paraId:219,tocIndex:35},{value:"circle.style.filter = 'saturate(1)';\ncircle.style.filter = 'saturate(100%)';\n",paraId:220,tocIndex:35},{value:"下图依次展示了 0 50% 和 100% 的饱和度效果，",paraId:221,tocIndex:35},{value:"示例",paraId:222,tocIndex:35},{value:"：",paraId:221,tocIndex:35},{value:"对图像进行深褐色处理（怀旧风格）。当值为 100% 时，图像完全变成深褐色。当值为 0% 时，图像没有任何变化。",paraId:223,tocIndex:36},{value:"circle.style.filter = 'sepia(1)';\ncircle.style.filter = 'sepia(100%)';\n",paraId:224,tocIndex:36},{value:"下图依次展示了 0 50% 和 100% 的处理效果，",paraId:225,tocIndex:36},{value:"示例",paraId:226,tocIndex:36},{value:"：",paraId:225,tocIndex:36},{value:"在输入图像上应用色相旋转，可设定图像会被调整的色环角度值。值为 0deg 时图像无变化。",paraId:227,tocIndex:37},{value:"circle.style.filter = 'hue-rotate(30deg)';\ncircle.style.filter = 'hue-rotate(180deg)';\n",paraId:228,tocIndex:37},{value:"下图依次展示了 0 90deg 和 180deg 的处理效果，",paraId:229,tocIndex:37},{value:"示例",paraId:230,tocIndex:37},{value:"：",paraId:229,tocIndex:37},{value:"反转输入图像的颜色。amount 的值定义转换的比例，100% 代表完全反转，0% 则图像无变化。",paraId:231,tocIndex:38},{value:"circle.style.filter = 'invert(1)';\ncircle.style.filter = 'invert(100%)';\n",paraId:232,tocIndex:38},{value:"下图依次展示了 0 50% 和 100% 的反转效果，",paraId:233,tocIndex:38},{value:"示例",paraId:234,tocIndex:38},{value:"：",paraId:233,tocIndex:38},{value:"类似 CSS 的 ",paraId:235,tocIndex:39},{value:"zIndex",paraId:235,tocIndex:39},{value:" 属性，用于控制渲染次序，需要注意：",paraId:235,tocIndex:39},{value:"只会影响渲染顺序，并不会改变场景图中的节点结构",paraId:236,tocIndex:39},{value:"只在当前上下文内生效",paraId:236,tocIndex:39},{value:"默认展示次序为场景图添加顺序，后添加的在之前添加的元素之上",paraId:236,tocIndex:39},{value:"初始值",paraId:237,tocIndex:39},{value:"适用元素",paraId:238,tocIndex:39},{value:"是否可继承",paraId:239,tocIndex:39},{value:"是否支持动画",paraId:238,tocIndex:39},{value:"计算值",paraId:240,tocIndex:39},{value:"'0'",paraId:238,tocIndex:39},{value:"所有",paraId:238,tocIndex:39},{value:"否",paraId:238,tocIndex:39},{value:"否",paraId:238,tocIndex:39},{value:"<number>",paraId:241,tocIndex:39},{value:"例如下面的场景图中，由于 li2 在 li1 之后加入画布，因此 li2 默认会展示在 li1 之上。如果希望改变这种展示次序，可以修改 li1 的 zIndex：",paraId:242,tocIndex:39},{value:"// ul1 -> li1\n//     -> li2\n// ul2 -> li3\n\nli1.style.zIndex = 1; // li1 在 li2 之上\n",paraId:243,tocIndex:39},{value:"再比如尽管 li2 的 zIndex 比 ul2 大很多，但由于 ul1 比 ul2 小，它也只能处于 ul2 之下，",paraId:244,tocIndex:39},{value:"示例",paraId:245,tocIndex:39},{value:"为了兼容旧版本，我们也提供了额外的、在上下文中设置的方法：",paraId:246,tocIndex:39},{value:"名称",paraId:247,tocIndex:39},{value:"参数",paraId:247,tocIndex:39},{value:"返回值",paraId:247,tocIndex:39},{value:"备注",paraId:247,tocIndex:39},{value:"setZIndex",paraId:247,tocIndex:39},{value:"number",paraId:247,tocIndex:39},{value:"无",paraId:247,tocIndex:39},{value:"设置 ",paraId:247,tocIndex:39},{value:"zIndex",paraId:247,tocIndex:39},{value:"toFront",paraId:247,tocIndex:39},{value:"无",paraId:247,tocIndex:39},{value:"无",paraId:247,tocIndex:39},{value:"置顶",paraId:247,tocIndex:39},{value:"toBack",paraId:247,tocIndex:39},{value:"无",paraId:247,tocIndex:39},{value:"无",paraId:247,tocIndex:39},{value:"置底",paraId:247,tocIndex:39},{value:"const group = new Group();\n\ngroup.setZIndex(100);\n// or group.setAttribute('zIndex', 100);\n// or group.style.zIndex = 100;\n",paraId:248,tocIndex:39},{value:"控制图形的可见性，可参考：",paraId:249,tocIndex:40},{value:"https://developer.mozilla.org/en-US/docs/Web/CSS/visibility",paraId:249,tocIndex:40},{value:"为了兼容旧版本，我们也提供了以下方法：",paraId:250,tocIndex:40},{value:"名称",paraId:251,tocIndex:40},{value:"参数",paraId:251,tocIndex:40},{value:"返回值",paraId:251,tocIndex:40},{value:"备注",paraId:251,tocIndex:40},{value:"hide",paraId:251,tocIndex:40},{value:"无",paraId:251,tocIndex:40},{value:"无",paraId:251,tocIndex:40},{value:"隐藏节点",paraId:251,tocIndex:40},{value:"show",paraId:251,tocIndex:40},{value:"无",paraId:251,tocIndex:40},{value:"无",paraId:251,tocIndex:40},{value:"展示节点",paraId:251,tocIndex:40},{value:"因此以下写法等价：",paraId:252,tocIndex:40},{value:"const group = new Group();\n\ngroup.style.visibility = 'hidden';\n// or group.setAttribute('visibility', 'hidden');\n// or group.hide();\n\ngroup.style.visibility = 'visible';\n// or group.setAttribute('visibility', 'visible');\n// or group.show();\n",paraId:253,tocIndex:40},{value:"初始值",paraId:254,tocIndex:40},{value:"适用元素",paraId:255,tocIndex:40},{value:"是否可继承",paraId:256,tocIndex:40},{value:"是否支持动画",paraId:255,tocIndex:40},{value:"计算值",paraId:257,tocIndex:40},{value:"'visible'",paraId:255,tocIndex:40},{value:"所有",paraId:255,tocIndex:40},{value:"是",paraId:255,tocIndex:40},{value:"否",paraId:255,tocIndex:40},{value:"<keywords>",paraId:258,tocIndex:40},{value:"关于可见性有两点需要注意：",paraId:259,tocIndex:40},{value:"隐藏的图形仍然可以被拾取，此时需要配合 ",paraId:260,tocIndex:40},{value:"pointerEvents",paraId:261,tocIndex:40},{value:" 使用",paraId:260,tocIndex:40},{value:"隐藏的元素仍然需要参与包围盒运算，即仍会占据空间。如果想完全移除元素，应该使用 ",paraId:260,tocIndex:40},{value:"removeChild",paraId:262,tocIndex:40},{value:"使用裁剪方式创建元素的可显示区域，区域内的部分显示，区域外的隐藏。可参考 CSS 的 ",paraId:263,tocIndex:42},{value:"clip-path",paraId:263,tocIndex:42},{value:"。该属性值可以是任意图形，例如 Circle、Rect 等等。同一个裁剪区域可以被多个图形共享使用。最后，裁剪区域也会影响图形的拾取区域，",paraId:263,tocIndex:42},{value:"示例",paraId:264,tocIndex:42},{value:"。",paraId:263,tocIndex:42},{value:"例如我们想创建一个裁剪成圆形的图片，让裁剪区域刚好处于图片中心（尺寸为 200 * 200），此时我们可以设置裁剪区域圆形的世界坐标为 ",paraId:265,tocIndex:42},{value:"[100, 100]",paraId:265,tocIndex:42},{value:"。",paraId:265,tocIndex:42},{value:"示例",paraId:266,tocIndex:42},{value:"：",paraId:265,tocIndex:42},{value:"const image = new Image({\n    style: {\n        x: 0,\n        y: 0,\n        width: 200,\n        height: 200,\n        clipPath: new Circle({\n            style: {\n                cx: 100,\n                cy: 100,\n                r: 50,\n            },\n        }),\n    },\n});\n",paraId:267,tocIndex:42},{value:"也可以在创建图形之后设置裁剪区域，因此以上写法等价于：",paraId:268,tocIndex:42},{value:"const image = new Image({\n    style: {\n        //... 省略其他属性\n    },\n});\n\nimage.style.clipPath = new Circle({\n    style: {\n        cx: 100,\n        cy: 100,\n        r: 50,\n    },\n});\n// 或者兼容旧版写法\nimage.setClip(\n    new Circle({\n        style: {\n            cx: 100,\n            cy: 100,\n            r: 50,\n        },\n    }),\n);\n",paraId:269,tocIndex:42},{value:"当我们想清除裁剪区域时，可以设置为 ",paraId:270,tocIndex:42},{value:"null",paraId:270,tocIndex:42},{value:"：",paraId:270,tocIndex:42},{value:"image.style.clipPath = null;\n// 或者\nimage.setClip(null);\n",paraId:271,tocIndex:42},{value:"裁剪区域图形本身也是支持修改属性的，受它影响，被裁剪图形会立刻重绘。",paraId:272,tocIndex:43},{value:"配合",paraId:273,tocIndex:43},{value:"动画系统",paraId:274,tocIndex:43},{value:"我们可以对已经添加到画布中的裁剪区域图形进行变换，实现以下效果，",paraId:273,tocIndex:43},{value:"示例",paraId:275,tocIndex:43},{value:"：",paraId:273,tocIndex:43},{value:"// 对裁剪区域应用动画\nclipPathCircle.animate(\n    [{ transform: 'scale(1)' }, { transform: 'scale(1.2)' }],\n    {\n        duration: 1500,\n        iterations: Infinity,\n    },\n);\n",paraId:276,tocIndex:43},{value:"我们暂不支持复合的裁剪区域，例如自定义图形以及 Group.",paraId:277,tocIndex:43},{value:"在",paraId:278,tocIndex:44},{value:"路径动画",paraId:279,tocIndex:44},{value:"中，我们可以使用 ",paraId:278,tocIndex:44},{value:"offsetPath",paraId:278,tocIndex:44},{value:" 指定一个图形的运动轨迹，配合",paraId:278,tocIndex:44},{value:"动画系统",paraId:280,tocIndex:44},{value:"对 ",paraId:278,tocIndex:44},{value:"offsetDistance",paraId:278,tocIndex:44},{value:" 属性应用变换：",paraId:278,tocIndex:44},{value:"const circle = new Circle({\n    style: {\n        offsetPath: new Line({\n            // 创建运动轨迹\n            style: {\n                // 不需要设置其他与轨迹无关的绘图属性\n                x1: 100,\n                y1: 100,\n                x2: 300,\n                y2: 100,\n            },\n        }),\n        r: 10,\n    },\n});\n\nconst animation = circle.animate(\n    [\n        { offsetDistance: 0 }, // 变换\n        { offsetDistance: 1 },\n    ],\n    {\n        duration: 3000,\n        easing: 'ease-in-out',\n        iterations: Infinity,\n    },\n);\n",paraId:281,tocIndex:44},{value:"指定路径轨迹，目前支持 ",paraId:282,tocIndex:45},{value:"Line",paraId:283,tocIndex:45},{value:" ",paraId:282,tocIndex:45},{value:"Path",paraId:284,tocIndex:45},{value:" 和 ",paraId:282,tocIndex:45},{value:"Polyline",paraId:285,tocIndex:45},{value:" 这三种图形。",paraId:282,tocIndex:45},{value:"从路径起点出发行进的距离，取值范围为 ",paraId:286,tocIndex:46},{value:"[0-1]",paraId:286,tocIndex:46},{value:"，0 代表路径起点，1 代表终点。",paraId:286,tocIndex:46},{value:"初始值",paraId:287,tocIndex:46},{value:"适用元素",paraId:288,tocIndex:46},{value:"是否可继承",paraId:289,tocIndex:46},{value:"是否支持动画",paraId:288,tocIndex:46},{value:"计算值",paraId:290,tocIndex:46},{value:"'0'",paraId:288,tocIndex:46},{value:"所有",paraId:288,tocIndex:46},{value:"否",paraId:288,tocIndex:46},{value:"是",paraId:288,tocIndex:46},{value:"<number>",paraId:291,tocIndex:46},{value:"当鼠标悬停在图形上时，我们可以改变它的样式，通过修改容器的 CSS 样式实现。",paraId:292,tocIndex:47},{value:"cursor",paraId:293,tocIndex:47},{value:" 属性支持的值可以参考：",paraId:293,tocIndex:47},{value:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/cursor",paraId:293,tocIndex:47},{value:"const circle = new Circle({\n    style: {\n        //... 省略其他属性\n        cursor: 'pointer',\n    },\n});\n",paraId:294,tocIndex:47},{value:"我们可以设置图形如何响应交互事件，例如命中拾取时展示鼠标样式，或者增大拾取区域。",paraId:295,tocIndex:48},{value:"设置图形如何响应交互事件，可参考：",paraId:296,tocIndex:49},{value:"https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events",paraId:296,tocIndex:49},{value:"简而言之，",paraId:297,tocIndex:49},{value:"fill",paraId:298,tocIndex:49},{value:" ",paraId:297,tocIndex:49},{value:"stroke",paraId:299,tocIndex:49},{value:" 和 ",paraId:297,tocIndex:49},{value:"visibility",paraId:300,tocIndex:49},{value:" 都可以独立或组合影响拾取判定行为。目前支持以下关键词：",paraId:297,tocIndex:49},{value:"'auto'",paraId:301,tocIndex:49},{value:" 默认值，等同于 ",paraId:301,tocIndex:49},{value:"'visiblepainted'",paraId:301,tocIndex:49},{value:"。",paraId:301,tocIndex:49},{value:"'none'",paraId:301,tocIndex:49},{value:" 永远不会成为响应事件的目标。",paraId:301,tocIndex:49},{value:"'visiblepainted'",paraId:301,tocIndex:49},{value:" 满足以下条件才会响应事件：\n",paraId:301,tocIndex:49},{value:"visibility",paraId:302,tocIndex:49},{value:" 设置为 ",paraId:303,tocIndex:49},{value:"'visible'",paraId:303,tocIndex:49},{value:"，即图形为可见的。",paraId:303,tocIndex:49},{value:"在图形填充区域触发同时 ",paraId:303,tocIndex:49},{value:"fill",paraId:304,tocIndex:49},{value:" 取非 ",paraId:303,tocIndex:49},{value:"'none'",paraId:303,tocIndex:49},{value:" 的值。或者在图形描边区域触发同时 ",paraId:303,tocIndex:49},{value:"stroke",paraId:305,tocIndex:49},{value:" 取非 ",paraId:303,tocIndex:49},{value:"'none'",paraId:303,tocIndex:49},{value:" 的值。",paraId:303,tocIndex:49},{value:"'visiblefill'",paraId:301,tocIndex:49},{value:" 满足以下条件才会响应事件：\n",paraId:301,tocIndex:49},{value:"visibility",paraId:306,tocIndex:49},{value:" 设置为 ",paraId:307,tocIndex:49},{value:"'visible'",paraId:307,tocIndex:49},{value:"，即图形为可见的。",paraId:307,tocIndex:49},{value:"在图形填充区域触发，不受 ",paraId:307,tocIndex:49},{value:"fill",paraId:308,tocIndex:49},{value:" 取值的影响。",paraId:307,tocIndex:49},{value:"'visiblestroke'",paraId:301,tocIndex:49},{value:" 满足以下条件才会响应事件：\n",paraId:301,tocIndex:49},{value:"visibility",paraId:309,tocIndex:49},{value:" 设置为 ",paraId:310,tocIndex:49},{value:"'visible'",paraId:310,tocIndex:49},{value:"，即图形为可见的。",paraId:310,tocIndex:49},{value:"在图形描边区域触发，不受 ",paraId:310,tocIndex:49},{value:"stroke",paraId:311,tocIndex:49},{value:" 取值的影响。",paraId:310,tocIndex:49},{value:"'visible'",paraId:301,tocIndex:49},{value:" 满足以下条件才会响应事件：\n",paraId:301,tocIndex:49},{value:"visibility",paraId:312,tocIndex:49},{value:" 设置为 ",paraId:313,tocIndex:49},{value:"'visible'",paraId:313,tocIndex:49},{value:"，即图形为可见的。",paraId:313,tocIndex:49},{value:"在图形填充或者描边区域触发，不受 ",paraId:313,tocIndex:49},{value:"fill",paraId:314,tocIndex:49},{value:" 和 ",paraId:313,tocIndex:49},{value:"stroke",paraId:315,tocIndex:49},{value:" 取值的影响。",paraId:313,tocIndex:49},{value:"'painted'",paraId:301,tocIndex:49},{value:" 满足以下条件才会响应事件：\n",paraId:301,tocIndex:49},{value:"在图形填充区域触发同时 ",paraId:316,tocIndex:49},{value:"fill",paraId:317,tocIndex:49},{value:" 取非 ",paraId:316,tocIndex:49},{value:"'none'",paraId:316,tocIndex:49},{value:" 的值。或者在图形描边区域触发同时 ",paraId:316,tocIndex:49},{value:"stroke",paraId:318,tocIndex:49},{value:" 取非 ",paraId:316,tocIndex:49},{value:"'none'",paraId:316,tocIndex:49},{value:" 的值。不受 ",paraId:316,tocIndex:49},{value:"visibility",paraId:319,tocIndex:49},{value:" 取值的影响。",paraId:316,tocIndex:49},{value:"'fill'",paraId:301,tocIndex:49},{value:" 满足以下条件才会响应事件：\n",paraId:301,tocIndex:49},{value:"在图形填充区域触发，不受 ",paraId:320,tocIndex:49},{value:"fill",paraId:321,tocIndex:49},{value:" 取值的影响。不受 ",paraId:320,tocIndex:49},{value:"visibility",paraId:322,tocIndex:49},{value:" 取值的影响。",paraId:320,tocIndex:49},{value:"'stroke'",paraId:301,tocIndex:49},{value:" 满足以下条件才会响应事件：\n",paraId:301,tocIndex:49},{value:"在图形描边区域触发，不受 ",paraId:323,tocIndex:49},{value:"stroke",paraId:324,tocIndex:49},{value:" 取值的影响。不受 ",paraId:323,tocIndex:49},{value:"visibility",paraId:325,tocIndex:49},{value:" 取值的影响。",paraId:323,tocIndex:49},{value:"'all'",paraId:301,tocIndex:49},{value:" 只要进入图形的填充和描边区域就会响应事件。因此不会受 ",paraId:301,tocIndex:49},{value:"fill",paraId:326,tocIndex:49},{value:" ",paraId:301,tocIndex:49},{value:"stroke",paraId:327,tocIndex:49},{value:" ",paraId:301,tocIndex:49},{value:"visibility",paraId:328,tocIndex:49},{value:" 的取值影响。",paraId:301,tocIndex:49},{value:"在该 ",paraId:329,tocIndex:49},{value:"示例",paraId:330,tocIndex:49},{value:" 中，我们将该属性设置为 ",paraId:329,tocIndex:49},{value:"stroke",paraId:329,tocIndex:49},{value:"，因此填充区域不会响应事件：",paraId:329,tocIndex:49},{value:"在该 ",paraId:331,tocIndex:49},{value:"示例",paraId:332,tocIndex:49},{value:" 中，基于继承机制我们能很方便的控制可交互性：",paraId:331,tocIndex:49},{value:"// 整个画布不响应交互事件\ncanvas.document.documentElement.style.pointerEvents = 'none';\n",paraId:333,tocIndex:49},{value:"初始值",paraId:334,tocIndex:49},{value:"适用元素",paraId:335,tocIndex:49},{value:"是否可继承",paraId:336,tocIndex:49},{value:"是否支持动画",paraId:335,tocIndex:49},{value:"计算值",paraId:337,tocIndex:49},{value:"'auto'",paraId:335,tocIndex:49},{value:"所有",paraId:335,tocIndex:49},{value:"是",paraId:335,tocIndex:49},{value:"否",paraId:335,tocIndex:49},{value:"<keywords>",paraId:338,tocIndex:49},{value:"当 ",paraId:339,tocIndex:50},{value:"lineWidth",paraId:340,tocIndex:50},{value:" 较小时，可交互区域也随之变小，有时我们想增大这个区域，让“细线”更容易被拾取到。注意该属性并不会影响渲染效果。",paraId:339,tocIndex:50},{value:"在下面的 ",paraId:341,tocIndex:50},{value:"示例",paraId:342,tocIndex:50},{value:" 中，我们设置该属性为 ",paraId:341,tocIndex:50},{value:"50",paraId:341,tocIndex:50},{value:"，在进行拾取时线宽相当于 ",paraId:341,tocIndex:50},{value:"50 + 原始线宽",paraId:341,tocIndex:50},{value:"，这样靠近时就更容易拾取到了： ",paraId:341,tocIndex:50},{value:"line.style.increasedLineWidthForHitTesting = 50;\n",paraId:343,tocIndex:50},{value:"另外和 ",paraId:344,tocIndex:50},{value:"lineWidth",paraId:345,tocIndex:50},{value:" 一样，该属性同样会向两侧延展，下图中无填充的 ",paraId:344,tocIndex:50},{value:"Path",paraId:346,tocIndex:50},{value:" 内部拾取区域也变大了：",paraId:344,tocIndex:50},{value:"初始值",paraId:347,tocIndex:50},{value:"适用元素",paraId:348,tocIndex:50},{value:"是否可继承",paraId:349,tocIndex:50},{value:"是否支持动画",paraId:348,tocIndex:50},{value:"计算值",paraId:350,tocIndex:50},{value:"'0'",paraId:348,tocIndex:50},{value:"所有",paraId:348,tocIndex:50},{value:"否",paraId:348,tocIndex:50},{value:"否",paraId:348,tocIndex:50},{value:"<percentage>",paraId:351,tocIndex:50},{value:" ",paraId:348,tocIndex:50},{value:"<length>",paraId:352,tocIndex:50},{value:"我们提供了一系列变换方法。",paraId:353,tocIndex:51},{value:"对于平移操作，我们提供了局部/世界坐标系下，移动绝对/相对距离的 API：",paraId:354,tocIndex:52},{value:"名称",paraId:355,tocIndex:52},{value:"参数",paraId:355,tocIndex:52},{value:"返回值",paraId:355,tocIndex:52},{value:"备注",paraId:355,tocIndex:52},{value:"translate",paraId:355,tocIndex:52},{value:"[number, number]",paraId:355,tocIndex:52},{value:"number, number",paraId:355,tocIndex:52},{value:"number",paraId:355,tocIndex:52},{value:"无",paraId:355,tocIndex:52},{value:"在 ",paraId:355,tocIndex:52},{value:"世界坐标系",paraId:355,tocIndex:52},{value:" 下，相对当前位置移动",paraId:355,tocIndex:52},{value:"translateLocal",paraId:355,tocIndex:52},{value:"[number, number]",paraId:355,tocIndex:52},{value:"number, number",paraId:355,tocIndex:52},{value:"number",paraId:355,tocIndex:52},{value:"无",paraId:355,tocIndex:52},{value:"在 ",paraId:355,tocIndex:52},{value:"局部坐标系",paraId:355,tocIndex:52},{value:" 下，相对当前位置移动",paraId:355,tocIndex:52},{value:"setPosition",paraId:355,tocIndex:52},{value:"[number, number]",paraId:355,tocIndex:52},{value:"number, number",paraId:355,tocIndex:52},{value:"number",paraId:355,tocIndex:52},{value:"无",paraId:355,tocIndex:52},{value:"设置 ",paraId:355,tocIndex:52},{value:"世界坐标系",paraId:355,tocIndex:52},{value:" 下的位置",paraId:355,tocIndex:52},{value:"setLocalPosition",paraId:355,tocIndex:52},{value:"[number, number]",paraId:355,tocIndex:52},{value:"number, number",paraId:355,tocIndex:52},{value:"number",paraId:355,tocIndex:52},{value:"无",paraId:355,tocIndex:52},{value:"设置 ",paraId:355,tocIndex:52},{value:"局部坐标系",paraId:355,tocIndex:52},{value:" 下的位置",paraId:355,tocIndex:52},{value:"getPosition",paraId:355,tocIndex:52},{value:"无",paraId:355,tocIndex:52},{value:"[number, number]",paraId:355,tocIndex:52},{value:"获取 ",paraId:355,tocIndex:52},{value:"世界坐标系",paraId:355,tocIndex:52},{value:" 下的位置",paraId:355,tocIndex:52},{value:"getLocalPosition",paraId:355,tocIndex:52},{value:"无",paraId:355,tocIndex:52},{value:"[number, number]",paraId:355,tocIndex:52},{value:"获取 ",paraId:355,tocIndex:52},{value:"局部坐标系",paraId:355,tocIndex:52},{value:" 下的位置",paraId:355,tocIndex:52},{value:"其中 translate/translateLocal/setPosition/setLocalPosition 支持以下入参形式，其中如果只想修改 X 轴方向，可以只传一个数字：",paraId:356,tocIndex:52},{value:"circle.translate([100, 0]); // [number, number]\ncircle.translate(100, 0); // number, number\ncircle.translate(100); // number\n",paraId:357,tocIndex:52},{value:"和平移不同，我们无法提供 ",paraId:358,tocIndex:53},{value:"setScale",paraId:358,tocIndex:53},{value:" 这样设置世界坐标系下缩放的方法，因此全局坐标系下缩放是只读的，这在 Unity 中称之为 ",paraId:358,tocIndex:53},{value:"lossyScale",paraId:358,tocIndex:53},{value:"。",paraId:358,tocIndex:53},{value:"名称",paraId:359,tocIndex:53},{value:"参数",paraId:359,tocIndex:53},{value:"返回值",paraId:359,tocIndex:53},{value:"备注",paraId:359,tocIndex:53},{value:"scaleLocal",paraId:359,tocIndex:53},{value:"[number, number]",paraId:359,tocIndex:53},{value:"number, number",paraId:359,tocIndex:53},{value:"number",paraId:359,tocIndex:53},{value:"无",paraId:359,tocIndex:53},{value:"在 ",paraId:359,tocIndex:53},{value:"局部坐标系",paraId:359,tocIndex:53},{value:" 下，相对当前缩放比例继续缩放",paraId:359,tocIndex:53},{value:"setLocalScale",paraId:359,tocIndex:53},{value:"[number, number]",paraId:359,tocIndex:53},{value:"number, number",paraId:359,tocIndex:53},{value:"number",paraId:359,tocIndex:53},{value:"无",paraId:359,tocIndex:53},{value:"设置 ",paraId:359,tocIndex:53},{value:"局部坐标系",paraId:359,tocIndex:53},{value:" 下的缩放比例",paraId:359,tocIndex:53},{value:"getScale",paraId:359,tocIndex:53},{value:"无",paraId:359,tocIndex:53},{value:"[number, number]",paraId:359,tocIndex:53},{value:"获取 ",paraId:359,tocIndex:53},{value:"世界坐标系",paraId:359,tocIndex:53},{value:" 下的缩放比例",paraId:359,tocIndex:53},{value:"getLocalScale",paraId:359,tocIndex:53},{value:"无",paraId:359,tocIndex:53},{value:"[number, number]",paraId:359,tocIndex:53},{value:"获取 ",paraId:359,tocIndex:53},{value:"局部坐标系",paraId:359,tocIndex:53},{value:" 下的缩放比例",paraId:359,tocIndex:53},{value:"其中 scaleLocal/setLocalScale 支持以下入参形式，其中如果水平/垂直方向缩放比例相等时，可以只传一个数字：",paraId:360,tocIndex:53},{value:"circle.scaleLocal([2, 2]); // [number, number]\ncircle.scaleLocal(2, 2); // number, number\ncircle.scaleLocal(2); // number\n",paraId:361,tocIndex:53},{value:"如果想实现沿 X / Y 轴翻转，可以传入负值，例如沿 Y 轴翻转：",paraId:362,tocIndex:53},{value:"circle.setLocalScale(-1, 1);\n",paraId:363,tocIndex:53},{value:"在 3D 场景中，旋转可以用矩阵、轴角、欧拉角和四元数表示，它们彼此之间可以互相转换。虽然考虑到未来的扩展性，在 G 内部实现中我们使用了四元数。",paraId:364,tocIndex:54},{value:"名称",paraId:365,tocIndex:54},{value:"参数",paraId:365,tocIndex:54},{value:"返回值",paraId:365,tocIndex:54},{value:"备注",paraId:365,tocIndex:54},{value:"rotateLocal",paraId:365,tocIndex:54},{value:"number",paraId:365,tocIndex:54},{value:"无",paraId:365,tocIndex:54},{value:"在 ",paraId:365,tocIndex:54},{value:"局部坐标系",paraId:365,tocIndex:54},{value:" 下，旋转一定的欧拉角，顺时针方向为正，单位为 ",paraId:365,tocIndex:54},{value:"degree",paraId:365,tocIndex:54},{value:"rotate",paraId:365,tocIndex:54},{value:"number",paraId:365,tocIndex:54},{value:"无",paraId:365,tocIndex:54},{value:"在 ",paraId:365,tocIndex:54},{value:"世界坐标系",paraId:365,tocIndex:54},{value:" 下，旋转一定的欧拉角",paraId:365,tocIndex:54},{value:"setEulerAngles",paraId:365,tocIndex:54},{value:"number",paraId:365,tocIndex:54},{value:"无",paraId:365,tocIndex:54},{value:"设置 ",paraId:365,tocIndex:54},{value:"世界坐标系",paraId:365,tocIndex:54},{value:" 下的欧拉角",paraId:365,tocIndex:54},{value:"setLocalEulerAngles",paraId:365,tocIndex:54},{value:"number",paraId:365,tocIndex:54},{value:"无",paraId:365,tocIndex:54},{value:"设置 ",paraId:365,tocIndex:54},{value:"局部坐标系",paraId:365,tocIndex:54},{value:" 下的欧拉角",paraId:365,tocIndex:54},{value:"setLocalRotation",paraId:365,tocIndex:54},{value:"quat",paraId:365,tocIndex:54},{value:"无",paraId:365,tocIndex:54},{value:"设置 ",paraId:365,tocIndex:54},{value:"局部坐标系",paraId:365,tocIndex:54},{value:" 下的四元数",paraId:365,tocIndex:54},{value:"setRotation",paraId:365,tocIndex:54},{value:"quat",paraId:365,tocIndex:54},{value:"无",paraId:365,tocIndex:54},{value:"设置 ",paraId:365,tocIndex:54},{value:"世界坐标系",paraId:365,tocIndex:54},{value:" 下的四元数",paraId:365,tocIndex:54},{value:"getEulerAngles",paraId:365,tocIndex:54},{value:"无",paraId:365,tocIndex:54},{value:"number",paraId:365,tocIndex:54},{value:"获取 ",paraId:365,tocIndex:54},{value:"世界坐标系",paraId:365,tocIndex:54},{value:" 下的欧拉角",paraId:365,tocIndex:54},{value:"getLocalEulerAngles",paraId:365,tocIndex:54},{value:"无",paraId:365,tocIndex:54},{value:"number",paraId:365,tocIndex:54},{value:"获取 ",paraId:365,tocIndex:54},{value:"局部坐标系",paraId:365,tocIndex:54},{value:" 下的欧拉角",paraId:365,tocIndex:54},{value:"getLocalRotation",paraId:365,tocIndex:54},{value:"无",paraId:365,tocIndex:54},{value:"quat",paraId:365,tocIndex:54},{value:"获取 ",paraId:365,tocIndex:54},{value:"局部坐标系",paraId:365,tocIndex:54},{value:" 下的四元数",paraId:365,tocIndex:54},{value:"getRotation",paraId:365,tocIndex:54},{value:"无",paraId:365,tocIndex:54},{value:"quat",paraId:365,tocIndex:54},{value:"获取 ",paraId:365,tocIndex:54},{value:"世界坐标系",paraId:365,tocIndex:54},{value:" 下的四元数",paraId:365,tocIndex:54},{value:"在 2D 场景中，可以进行拉伸，在一定方向上以一定角度扭曲元素上的每个点。可参考 ",paraId:366,tocIndex:55},{value:"CSS 同名变换函数",paraId:366,tocIndex:55},{value:"。",paraId:366,tocIndex:55},{value:"名称",paraId:367,tocIndex:55},{value:"参数",paraId:367,tocIndex:55},{value:"返回值",paraId:367,tocIndex:55},{value:"备注",paraId:367,tocIndex:55},{value:"setLocalSkew",paraId:367,tocIndex:55},{value:"vec2",paraId:367,tocIndex:55},{value:"无",paraId:367,tocIndex:55},{value:"在 ",paraId:367,tocIndex:55},{value:"局部坐标系",paraId:367,tocIndex:55},{value:" 下，沿着横/纵坐标扭曲元素的角度，单位为 ",paraId:367,tocIndex:55},{value:"rad",paraId:367,tocIndex:55},{value:"getLocalSkew",paraId:367,tocIndex:55},{value:"无",paraId:367,tocIndex:55},{value:"vec2",paraId:367,tocIndex:55},{value:"获取 ",paraId:367,tocIndex:55},{value:"局部坐标系",paraId:367,tocIndex:55},{value:" 下的扭曲角度，单位为 ",paraId:367,tocIndex:55},{value:"rad",paraId:367,tocIndex:55},{value:"除了使用 ",paraId:368,tocIndex:56},{value:"transformOrigin",paraId:369,tocIndex:56},{value:" 属性，还可以通过 ",paraId:368,tocIndex:56},{value:"setOrigin",paraId:368,tocIndex:56},{value:" 重新设置变换中心。",paraId:368,tocIndex:56},{value:"名称",paraId:370,tocIndex:56},{value:"参数",paraId:370,tocIndex:56},{value:"返回值",paraId:370,tocIndex:56},{value:"备注",paraId:370,tocIndex:56},{value:"setOrigin",paraId:370,tocIndex:56},{value:"[number, number]",paraId:370,tocIndex:56},{value:" 或 ",paraId:370,tocIndex:56},{value:"[number, number, number]",paraId:370,tocIndex:56},{value:" 或 ",paraId:370,tocIndex:56},{value:"number, number",paraId:370,tocIndex:56},{value:" 或 ",paraId:370,tocIndex:56},{value:"number, number, number",paraId:370,tocIndex:56},{value:"无",paraId:370,tocIndex:56},{value:"设置局部坐标系下的缩放和旋转中心",paraId:370,tocIndex:56},{value:"getOrigin",paraId:370,tocIndex:56},{value:"[number, number, number]",paraId:370,tocIndex:56},{value:"无",paraId:370,tocIndex:56},{value:"获取局部坐标系下的缩放和旋转中心",paraId:370,tocIndex:56},{value:"设置局部坐标系下的缩放和旋转中心，",paraId:371,tocIndex:56},{value:"示例",paraId:372,tocIndex:56},{value:"默认值为 ",paraId:373,tocIndex:56},{value:"[0, 0]",paraId:373,tocIndex:56},{value:"。",paraId:373,tocIndex:56},{value:"在下面的例子中，我们在 ",paraId:374,tocIndex:56},{value:"[100, 100]",paraId:374,tocIndex:56},{value:" 处放置了一个半径为 100 的圆：",paraId:374,tocIndex:56},{value:"const circle = new Circle({\n    style: {\n        cx: 100,\n        cy: 100,\n        r: 100,\n    },\n});\n",paraId:375,tocIndex:56},{value:"如果我们想让圆以圆心作为变换中心进行缩放，发生变化的是包围盒：",paraId:376,tocIndex:56},{value:"circle.setOrigin(100, 100);\ncircle.scale(0.5);\ncircle.getBounds(); // { center: [100, 100], halfExtents: [50, 50] }\n",paraId:377,tocIndex:56},{value:"但假如我们想让这个圆以自身包围盒左上角进行缩放：",paraId:378,tocIndex:56},{value:"circle.setOrigin(0, 0);\ncircle.scale(0.5);\ncircle.getBounds(); // { center: [50, 50], halfExtents: [50, 50] }\n",paraId:379,tocIndex:56},{value:"在下面的",paraId:380,tocIndex:56},{value:"示例",paraId:381,tocIndex:56},{value:"中，我们创建了一个矩形，它的默认锚点为局部坐标系下包围盒的左上角。如果我们想让它以包围盒中心进行旋转，就需要设置变换中心相对于锚点偏移长宽各一半，即 ",paraId:380,tocIndex:56},{value:"[150, 100]",paraId:380,tocIndex:56},{value:"：",paraId:380,tocIndex:56},{value:"const rect = new Rect({\n    id: 'rect',\n    style: {\n        width: 300,\n        height: 200,\n    },\n});\nrect.setOrigin(150, 100); // 设置旋转与缩放中心为自身包围盒中心点\n",paraId:382,tocIndex:56},{value:"例如我们想修改一个圆的变换中心到左上角而非圆心，可以这样做：",paraId:383,tocIndex:56},{value:"const circle = new Circle({\n    style: {\n        cx: 100,\n        cy: 100,\n        r: 100,\n    },\n});\n\ncircle.setOrigin(0, 0);\n// 或者\ncircle.style.transformOrigin = 'left top'; // 包围盒左上角\n// 或者\ncircle.style.transformOrigin = '0px 0px';\n// 或者\ncircle.style.transformOrigin = '0% 0%';\n",paraId:384,tocIndex:56},{value:"基于不同的",paraId:385,tocIndex:57},{value:"包围盒定义",paraId:386,tocIndex:57},{value:"，我们提供了以下获取方法。",paraId:385,tocIndex:57},{value:"获取基础图形的几何包围盒，除了定义所需的样式属性（例如 Circle 的 r，Rect 的 width/height），它不受其他绘图属性（例如 lineWidth，fitler，shadowBlur 等）影响：",paraId:387,tocIndex:58},{value:"const circle = new Circle({\n    style: {\n        cx: 100, // 局部坐标系下的坐标不会影响 Geometry Bounds\n        cy: 100, // 局部坐标系下的坐标不会影响 Geometry Bounds\n        r: 100,\n        lineWidth: 20, // 样式属性不会影响 Geometry Bounds\n        shadowBlur: 10, // 样式属性不会影响 Geometry Bounds\n    },\n});\ncircle.getGeometryBounds(); // { center: [0, 0], halfExtents: [100, 100] }\n",paraId:388,tocIndex:58},{value:"Group 由于没有几何定义，因此会返回 null：",paraId:389,tocIndex:58},{value:"const group = new Group();\ngroup.getGeometryBounds(); // null\n",paraId:390,tocIndex:58},{value:"合并自身以及子节点在世界坐标系下的 Geometry Bounds。这应当是最常用的计算方式：",paraId:391,tocIndex:59},{value:"const circle = new Circle({\n    style: {\n        cx: 100, // 应用世界坐标系下的变换\n        cy: 100,\n        r: 100,\n    },\n});\ncircle.getBounds(); // { center: [100, 100], halfExtents: [100, 100] }\n",paraId:392,tocIndex:59},{value:"合并自身以及子节点在世界坐标系下的 Render Bounds，在 Geometry Bounds 基础上，受以下样式属性影响： lineWidth，shadowBlur，filter：",paraId:393,tocIndex:60},{value:"const circle = new Circle({\n    style: {\n        cx: 100, // 应用世界坐标系下的变换\n        cy: 100,\n        r: 100,\n        lineWidth: 20, // 考虑样式属性\n    },\n});\n// r + lineWidth / 2\ncircle.getRenderBounds(); // { center: [100, 100], halfExtents: [110, 110] }\n",paraId:394,tocIndex:60},{value:"getBounds 的唯一区别是在父节点的局部坐标系下计算。",paraId:395,tocIndex:61},{value:"兼容 ",paraId:396,tocIndex:62},{value:"SVG 同名方法",paraId:396,tocIndex:62},{value:"，计算方式等同于 getBounds，区别仅在于返回值类型不同，后者返回的是 AABB，而该方法返回一个 ",paraId:396,tocIndex:62},{value:"DOMRect",paraId:396,tocIndex:62},{value:"：",paraId:396,tocIndex:62},{value:"interface DOMRect {\n  top: number;\n  left: number;\n  right: number;\n  bottom: number;\n  width: number;\n  height: number;\n}\n",paraId:397,tocIndex:62},{value:"获取浏览器坐标系下的 Geometry Bounds，应用世界坐标系下的变换后，再加上画布相对于浏览器的偏移量。",paraId:398,tocIndex:63},{value:"在场景图中，我们需要构建父子关系，快速获取父子节点，有时还需要在子树中查询某一类型的节点列表。基于继承关系，每个 DisplayObject 都拥有 ",paraId:399,tocIndex:64},{value:"Node",paraId:400,tocIndex:64},{value:" 和 ",paraId:399,tocIndex:64},{value:"Element",paraId:401,tocIndex:64},{value:" 能力。",paraId:399,tocIndex:64},{value:"名称",paraId:402,tocIndex:65},{value:"属性/方法",paraId:402,tocIndex:65},{value:"返回值",paraId:402,tocIndex:65},{value:"备注",paraId:402,tocIndex:65},{value:"parentNode",paraId:402,tocIndex:65},{value:"属性",paraId:402,tocIndex:65},{value:"DisplayObject | null",paraId:402,tocIndex:65},{value:"父节点（如有）",paraId:402,tocIndex:65},{value:"parentElement",paraId:402,tocIndex:65},{value:"属性",paraId:402,tocIndex:65},{value:"DisplayObject | null",paraId:402,tocIndex:65},{value:"父节点（如有）",paraId:402,tocIndex:65},{value:"childNodes",paraId:402,tocIndex:65},{value:"属性",paraId:402,tocIndex:65},{value:"DisplayObject[]",paraId:402,tocIndex:65},{value:"子节点列表",paraId:402,tocIndex:65},{value:"children",paraId:402,tocIndex:65},{value:"属性",paraId:402,tocIndex:65},{value:"DisplayObject[]",paraId:402,tocIndex:65},{value:"子节点列表",paraId:402,tocIndex:65},{value:"firstChild",paraId:402,tocIndex:65},{value:"属性",paraId:402,tocIndex:65},{value:"DisplayObject | null",paraId:402,tocIndex:65},{value:"返回子节点列表中第一个节点（如有）",paraId:402,tocIndex:65},{value:"lastChild",paraId:402,tocIndex:65},{value:"属性",paraId:402,tocIndex:65},{value:"DisplayObject | null",paraId:402,tocIndex:65},{value:"返回子节点列表中最后一个节点（如有）",paraId:402,tocIndex:65},{value:"nextSibling",paraId:402,tocIndex:65},{value:"属性",paraId:402,tocIndex:65},{value:"DisplayObject | null",paraId:402,tocIndex:65},{value:"返回后一个兄弟节点（如有）",paraId:402,tocIndex:65},{value:"previousSibling",paraId:402,tocIndex:65},{value:"属性",paraId:402,tocIndex:65},{value:"DisplayObject | null",paraId:402,tocIndex:65},{value:"返回前一个兄弟节点（如有）",paraId:402,tocIndex:65},{value:"contains",paraId:402,tocIndex:65},{value:"方法",paraId:402,tocIndex:65},{value:"boolean",paraId:402,tocIndex:65},{value:"子树中是否包含某个节点（入参）",paraId:402,tocIndex:65},{value:"getRootNode",paraId:402,tocIndex:65},{value:"方法",paraId:402,tocIndex:65},{value:"Node",paraId:402,tocIndex:65},{value:"返回当前节点的根节点",paraId:402,tocIndex:65},{value:"ownerDocument",paraId:402,tocIndex:65},{value:"属性",paraId:402,tocIndex:65},{value:"Document",paraId:402,tocIndex:65},{value:"返回画布入口 Document",paraId:402,tocIndex:65},{value:"isConnected",paraId:402,tocIndex:65},{value:"属性",paraId:402,tocIndex:65},{value:"boolean",paraId:402,tocIndex:65},{value:"节点是否被添加到画布中",paraId:402,tocIndex:65},{value:"参考 CSS 选择器，我们提供了以下查询方法，查询范围是当前节点的",paraId:403,tocIndex:66},{value:"整棵子树",paraId:403,tocIndex:66},{value:"，并不仅仅是直接的子节点列表，而是所有子孙节点。",paraId:403,tocIndex:66},{value:"名称",paraId:404,tocIndex:66},{value:"参数",paraId:404,tocIndex:66},{value:"返回值",paraId:404,tocIndex:66},{value:"备注",paraId:404,tocIndex:66},{value:"getElementById",paraId:404,tocIndex:66},{value:"(id: string)",paraId:404,tocIndex:66},{value:"DisplayObject | null",paraId:404,tocIndex:66},{value:"通过 ",paraId:404,tocIndex:66},{value:"id",paraId:404,tocIndex:66},{value:" 查询子节点",paraId:404,tocIndex:66},{value:"getElementsByName",paraId:404,tocIndex:66},{value:"(name: string)",paraId:404,tocIndex:66},{value:"DisplayObject[]",paraId:404,tocIndex:66},{value:"通过 ",paraId:404,tocIndex:66},{value:"name",paraId:404,tocIndex:66},{value:" 查询子节点列表",paraId:404,tocIndex:66},{value:"getElementsByClassName",paraId:404,tocIndex:66},{value:"(className: string)",paraId:404,tocIndex:66},{value:"DisplayObject[]",paraId:404,tocIndex:66},{value:"通过 ",paraId:404,tocIndex:66},{value:"className",paraId:404,tocIndex:66},{value:" 查询子节点列表",paraId:404,tocIndex:66},{value:"getElementsByTagName",paraId:404,tocIndex:66},{value:"(tagName: string)",paraId:404,tocIndex:66},{value:"DisplayObject[]",paraId:404,tocIndex:66},{value:"通过 ",paraId:404,tocIndex:66},{value:"tagName",paraId:404,tocIndex:66},{value:" 查询子节点列表",paraId:404,tocIndex:66},{value:"querySelector",paraId:404,tocIndex:66},{value:"(selector: string)",paraId:404,tocIndex:66},{value:"DisplayObject | null",paraId:404,tocIndex:66},{value:"查询满足条件的第一个子节点",paraId:404,tocIndex:66},{value:"querySelectorAll",paraId:404,tocIndex:66},{value:"(selector: string)",paraId:404,tocIndex:66},{value:"DisplayObject[]",paraId:404,tocIndex:66},{value:"查询满足条件的所有子节点列表",paraId:404,tocIndex:66},{value:"find",paraId:404,tocIndex:66},{value:"(filter: Function)",paraId:404,tocIndex:66},{value:"DisplayObject | null",paraId:404,tocIndex:66},{value:"查询满足条件的第一个子节点",paraId:404,tocIndex:66},{value:"findAll",paraId:404,tocIndex:66},{value:"(filter: Function)",paraId:404,tocIndex:66},{value:"DisplayObject[]",paraId:404,tocIndex:66},{value:"查询满足条件的所有子节点列表",paraId:404,tocIndex:66},{value:"下面我们以上面太阳系的例子，演示如何使用这些查询方法。",paraId:405,tocIndex:66},{value:"solarSystem.getElementsByName('sun');\n// sun\n\nsolarSystem.getElementsByTagName('circle');\nsolarSystem.getElementsByTagName(Shape.CIRCLE);\n// [sun, earth, moon]\n\nsolarSystem.querySelector('[name=sun]');\n// sun\n\nsolarSystem.querySelectorAll('[r=25]');\n// [moon]\n",paraId:406,tocIndex:66},{value:"有时查询条件不好用 CSS 选择器描述，此时可以使用自定义查询方法：find/findAll。它们可以类比成 querySelector/querySelectorAll。不同之处在于前者需要传入一个 filter，例如以下写法等价：",paraId:407,tocIndex:66},{value:"solarSystem.querySelector('[name=sun]');\nsolarSystem.find((element) => element.name === 'sun');\n\nsolarSystem.querySelectorAll('[r=25]');\nsolarSystem.findAll((element) => element.style.r === 25);\n",paraId:408,tocIndex:66},{value:"以下添加/删除节点能力来自继承的 ",paraId:409,tocIndex:67},{value:"Element",paraId:410,tocIndex:67},{value:" 基类。",paraId:409,tocIndex:67},{value:"名称",paraId:411,tocIndex:67},{value:"参数",paraId:411,tocIndex:67},{value:"返回值",paraId:411,tocIndex:67},{value:"备注",paraId:411,tocIndex:67},{value:"appendChild",paraId:411,tocIndex:67},{value:"child: DisplayObject",paraId:411,tocIndex:67},{value:"DisplayObject",paraId:411,tocIndex:67},{value:"添加子节点，返回添加的节点",paraId:411,tocIndex:67},{value:"insertBefore",paraId:411,tocIndex:67},{value:"child: DisplayObject",paraId:411,tocIndex:67},{value:"reference?: DisplayObject",paraId:411,tocIndex:67},{value:"DisplayObject",paraId:411,tocIndex:67},{value:"添加子节点，在某个子节点之前（如有），返回添加的节点",paraId:411,tocIndex:67},{value:"append",paraId:411,tocIndex:67},{value:"...nodes: DisplayObject[]",paraId:411,tocIndex:67},{value:"在当前节点的子节点列表末尾批量添加一组节点",paraId:411,tocIndex:67},{value:"prepend",paraId:411,tocIndex:67},{value:"...nodes: DisplayObject[]",paraId:411,tocIndex:67},{value:"在当前节点的子节点列表头部批量添加一组节点",paraId:411,tocIndex:67},{value:"after",paraId:411,tocIndex:67},{value:"...nodes: DisplayObject[]",paraId:411,tocIndex:67},{value:"在当前节点之后批量添加一些兄弟节点",paraId:411,tocIndex:67},{value:"before",paraId:411,tocIndex:67},{value:"...nodes: DisplayObject[]",paraId:411,tocIndex:67},{value:"在当前节点之前批量添加一些兄弟节点",paraId:411,tocIndex:67},{value:"removeChild",paraId:411,tocIndex:67},{value:"child: DisplayObject",paraId:411,tocIndex:67},{value:"DisplayObject",paraId:411,tocIndex:67},{value:"删除子节点，返回被删除的节点。",paraId:411,tocIndex:67},{value:"removeChildren",paraId:411,tocIndex:67},{value:"删除全部子节点。",paraId:411,tocIndex:67},{value:"remove",paraId:411,tocIndex:67},{value:"destroy = true",paraId:411,tocIndex:67},{value:"DisplayObject",paraId:411,tocIndex:67},{value:"从父节点（如有）中移除自身，",paraId:411,tocIndex:67},{value:"destroy",paraId:411,tocIndex:67},{value:" 表示是否要销毁",paraId:411,tocIndex:67},{value:"replaceChild",paraId:411,tocIndex:67},{value:"child: DisplayObject",paraId:411,tocIndex:67},{value:"DisplayObject",paraId:411,tocIndex:67},{value:"用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点",paraId:411,tocIndex:67},{value:"replaceWith",paraId:411,tocIndex:67},{value:"...nodes: DisplayObject[]",paraId:411,tocIndex:67},{value:"在父节点的子节点列表中，用传入的节点列表替换该节点",paraId:411,tocIndex:67},{value:"replaceChildren",paraId:411,tocIndex:67},{value:"...nodes: DisplayObject[]",paraId:411,tocIndex:67},{value:"替换该节点的所有子节点。不传参数时则会清空该节点的所有子节点",paraId:411,tocIndex:67},{value:"从父节点中删除子节点并销毁有以下两种方式：",paraId:412,tocIndex:67},{value:"// parent -> child\nparent.removeChild(child);\n\n// 等价于\nchild.remove();\n",paraId:413,tocIndex:67},{value:"删除所有子节点有以下三种方式：",paraId:414,tocIndex:67},{value:"parent.removeChildren();\n\n// 等价于\n[...parent.children].forEach((child) => parent.removeChild(child));\n[...parent.children].forEach((child) => child.remove());\n\n// 等价于\nparent.replaceChildren();\n",paraId:415,tocIndex:67},{value:"在添加/删除节点时有以下注意点：",paraId:416,tocIndex:67},{value:"添加节点时会依次触发 ChildInserted 和 Inserted 事件",paraId:417,tocIndex:67},{value:"删除节点时会依次触发 Removed 和 ChildRemoved 事件，默认会调用 ",paraId:417,tocIndex:67},{value:"destroy",paraId:418,tocIndex:67},{value:" 销毁自身。如果只是暂时从场景图中移除，后续还可能继续添加回来，可以使用 ",paraId:417,tocIndex:67},{value:"remove(false)",paraId:417,tocIndex:67},{value:"方法签名为 ",paraId:419,tocIndex:68},{value:"cloneNode(deep?: boolean): this",paraId:419,tocIndex:68},{value:"，可选参数为是否需要深拷贝，返回克隆得到的新节点。",paraId:419,tocIndex:68},{value:"在下面的例子中，我们创建了一个圆，设置了它的半径与位置。拷贝得到的新节点拥有同样的样式属性与位置：",paraId:420,tocIndex:68},{value:"circle.style.r = 20;\ncircle.setPosition(10, 20);\n\nconst clonedCircle = circle.cloneNode();\nclonedCircle instanceof Circle; // true\nclonedCircle.style.r; // 20\nclonedCircle.getPosition(); // [10, 20]\n",paraId:421,tocIndex:68},{value:"注意事项：",paraId:422,tocIndex:68},{value:"支持深拷贝，即自身以及整棵子树",paraId:423,tocIndex:68},{value:"克隆的新节点不会保留原始节点的父子关系，需要使用 ",paraId:423,tocIndex:68},{value:"appendChild",paraId:423,tocIndex:68},{value:" 将其加入画布才会被渲染",paraId:423,tocIndex:68},{value:"与 ",paraId:423,tocIndex:68},{value:"DOM API",paraId:423,tocIndex:68},{value:" 保持一致，不会拷贝原图形上的事件监听器",paraId:423,tocIndex:68},{value:"在这个",paraId:424,tocIndex:68},{value:"示例",paraId:425,tocIndex:68},{value:"中，我们展示了以上特性：",paraId:424,tocIndex:68},{value:"可以随时更改原始节点的样式属性，得到的拷贝都会是最新的，新节点同样需要被加入到场景图中才会被渲染",paraId:426,tocIndex:68},{value:"但由于不会拷贝事件监听器，因此只有原始节点可以进行拖拽",paraId:426,tocIndex:68},{value:"非深拷贝模式下，Text（Drag me 文本） 作为 Circle 的子节点不会被拷贝",paraId:426,tocIndex:68},{value:"名称",paraId:427,tocIndex:69},{value:"参数",paraId:427,tocIndex:69},{value:"返回值",paraId:427,tocIndex:69},{value:"备注",paraId:427,tocIndex:69},{value:"getAttribute",paraId:427,tocIndex:69},{value:"(name: string)",paraId:427,tocIndex:69},{value:"null | any",paraId:427,tocIndex:69},{value:"根据属性名获取属性值",paraId:427,tocIndex:69},{value:"setAttribute",paraId:427,tocIndex:69},{value:"(name: string, value: any)",paraId:427,tocIndex:69},{value:"无",paraId:427,tocIndex:69},{value:"设置属性值",paraId:427,tocIndex:69},{value:"⚠️ 兼容旧版 ",paraId:428,tocIndex:69},{value:"attr(name: string, value?: any)",paraId:428,tocIndex:69},{value:"，获取以及设置属性值。",paraId:428,tocIndex:69},{value:"⚠️ 兼容 ",paraId:429,tocIndex:69},{value:"HTMLElement Style",paraId:429,tocIndex:69},{value:"，因此可以使用以下方法：",paraId:429,tocIndex:69},{value:"style.",paraId:430,tocIndex:69},{value:"getPropertyValue",paraId:430,tocIndex:69},{value:"style.",paraId:430,tocIndex:69},{value:"setProperty",paraId:430,tocIndex:69},{value:"style.",paraId:430,tocIndex:69},{value:"removeProperty",paraId:430,tocIndex:69},{value:"以下用法等价：",paraId:431,tocIndex:69},{value:"const circle = new Circle({\n    style: {\n        // 或者使用 attrs\n        r: 10,\n        fill: 'red',\n    },\n});\n\n// 获取属性值\ncircle.getAttribute('fill'); // red\ncircle.attr('fill'); // red\ncircle.style.fill; // red\ncircle.style.getPropertyValue('fill');\n\n// 设置属性值\ncircle.setAttribute('r', 20);\ncircle.attr('r', 20);\ncircle.style.r = 20;\ncircle.style.setProperty('r', 20);\n",paraId:432,tocIndex:69},{value:"部分属性例如 ",paraId:433,tocIndex:70},{value:"Rect",paraId:434,tocIndex:70},{value:" 的 width / height 是支持单位的，如果想获取",paraId:433,tocIndex:70},{value:"计算后的值",paraId:435,tocIndex:70},{value:"，可以使用 ",paraId:433,tocIndex:70},{value:"parsedStyle",paraId:433,tocIndex:70},{value:"：",paraId:433,tocIndex:70},{value:"rect.style.width = '100px';\nrect.parsedStyle.width; // CSSUnitValue { unit: 'px', value: 100 }\n",paraId:436,tocIndex:70},{value:"需要注意的是，目前在使用",paraId:437,tocIndex:70},{value:"动画",paraId:438,tocIndex:70},{value:"时，我们也会将待插值的属性值进行转换，因此如果想获取以 px 为单位的绝对值，需要使用 ",paraId:437,tocIndex:70},{value:"parsedStyle",paraId:437,tocIndex:70},{value:" ",paraId:437,tocIndex:70},{value:"示例",paraId:439,tocIndex:70},{value:"：",paraId:437,tocIndex:70},{value:"animation.onframe = () => {\n    rect.style.width; // '100px'\n    rect.parsedStyle.width; // CSSUnitValue { unit: 'px', value: 100 }\n};\n",paraId:440,tocIndex:70},{value:"调用 ",paraId:441,tocIndex:71},{value:"destroy()",paraId:441,tocIndex:71},{value:" 将销毁节点。被销毁的节点将无法被再次加入画布渲染。通过 ",paraId:441,tocIndex:71},{value:"destroyed",paraId:442,tocIndex:71},{value:" 属性可以判断一个节点是否已经被销毁。",paraId:441,tocIndex:71},{value:"circle.destroy();\n",paraId:443,tocIndex:71},{value:"在调用用该方法时，会依次执行以下操作：",paraId:444,tocIndex:71},{value:"触发 Destroy 事件",paraId:445,tocIndex:71},{value:"调用 ",paraId:445,tocIndex:71},{value:"remove()",paraId:445,tocIndex:71},{value:" 将自身从场景图中移除，因此会触发 Removed 和 ChildRemoved 事件",paraId:445,tocIndex:71},{value:"移除该节点上的所有事件监听器和动画对象",paraId:445,tocIndex:71},{value:"将 ",paraId:445,tocIndex:71},{value:"destroyed",paraId:446,tocIndex:71},{value:" 标志置为 true",paraId:445,tocIndex:71},{value:"通过以下属性可以判断图形当前的状态，例如是否被加入到画布中，是否已经被销毁等。",paraId:447,tocIndex:72},{value:"用于判断一个图形是否已经被加入到画布中。",paraId:448,tocIndex:73},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/isConnected",paraId:449,tocIndex:73},{value:"circle.isConnected; // false\ncanvas.appendChild(circle); // add to canvas\ncircle.isConnected; // true\n",paraId:450,tocIndex:73},{value:"指向画布的入口 Document。如果还未加入到画布中，返回 null。",paraId:451,tocIndex:74},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Node/ownerDocument",paraId:452,tocIndex:74},{value:"circle.ownerDocument; // null\ncanvas.appendChild(circle); // add to canvas\ncircle.ownerDocument; // canvas.document\n",paraId:453,tocIndex:74},{value:"用于判断一个图形是否已经被销毁。",paraId:454,tocIndex:75},{value:"通过调用 ",paraId:455,tocIndex:75},{value:"destroy()",paraId:455,tocIndex:75},{value:" 主动销毁自身，或者父节点通过 ",paraId:455,tocIndex:75},{value:"destroyChildren()",paraId:455,tocIndex:75},{value:" 主动移除并销毁所有子节点等：",paraId:455,tocIndex:75},{value:"circle.destroyed; // false\ncircle.destroy();\ncircle.destroyed; // true\n",paraId:456,tocIndex:75},{value:"在",paraId:457,tocIndex:76},{value:"事件系统",paraId:458,tocIndex:76},{value:"中，我们可以使用类似 DOM Event API 的方式给添加到画布中的节点增加事件监听器。",paraId:457,tocIndex:76},{value:"除了例如 click、mouseenter 这样的交互事件，我们还提供了一系列内置的节点生命周期事件，例如可以监听节点的添加和删除事件，这些事件同样有完整的传播路径（冒泡、捕获），",paraId:459,tocIndex:76},{value:"示例",paraId:460,tocIndex:76},{value:"：",paraId:459,tocIndex:76},{value:"import { ElementEvent, MutationEvent } from '@antv/g';\n\nchild.on(ElementEvent.INSERTED, (e: MutationEvent) => {\n  e.target; // child\n  e.relatedNode; // parent\n});\nchild.on(ElementEvent.REMOVED, (e) => {\n  e.target; // child\n  e.relatedNode; // parent\n});\nchild.on(ElementEvent.ATTR_MODIFIED, (e) => {\n  e.target; // child\n  e.attrName; // 属性名\n  e.prevValue; // 旧值\n  e.newValue; // 新值\n});\n\nparent.appendChild(child);\n",paraId:461,tocIndex:76},{value:"目前我们支持如下场景图相关事件：",paraId:462,tocIndex:76},{value:"INSERTED 作为子节点被添加时触发",paraId:463,tocIndex:76},{value:"REMOVED 作为子节点被移除时触发",paraId:463,tocIndex:76},{value:"MOUNTED 首次进入画布时触发",paraId:463,tocIndex:76},{value:"UNMOUNTED 从画布中移除时触发",paraId:463,tocIndex:76},{value:"ATTR_MODIFIED 修改属性时触发",paraId:463,tocIndex:76},{value:"DESTROY 销毁时触发",paraId:463,tocIndex:76},{value:"参考 Web Animations API，可以使用 animate 完成 keyframe 动画，下面是一个 ScaleIn 动画效果：",paraId:464,tocIndex:77},{value:"circle.animate(\n    [\n        {\n            transform: 'scale(0)',\n        },\n        {\n            transform: 'scale(1)',\n        },\n    ],\n    {\n        duration: 500,\n        easing: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)',\n        iterations: Infinity,\n    },\n);\n",paraId:465,tocIndex:77},{value:"更多用法详见",paraId:466,tocIndex:77},{value:"动画系统",paraId:467,tocIndex:77},{value:"https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Howto/Use_data_attributes",paraId:468,tocIndex:78},{value:"提供 ",paraId:469,tocIndex:78},{value:"data-*",paraId:469,tocIndex:78},{value:" 属性用于存储额外信息。",paraId:469,tocIndex:78},{value:"group.dataset.type = 'a';\ngroup.getAttribute('data-type'); // 'a'\n",paraId:470,tocIndex:78},{value:"需要注意的是，",paraId:471,tocIndex:78},{value:"data-",paraId:471,tocIndex:78},{value:" 前缀之后的部分通过 ",paraId:471,tocIndex:78},{value:"dataset",paraId:471,tocIndex:78},{value:" 访问时需要使用驼峰形式：",paraId:471,tocIndex:78},{value:"group.setAttribute('data-a-b-c');\ngroup.dataset.aBC;\n\n// Wrong\ngroup.dataset.abc;\ngroup.dataset.abC;\n",paraId:472,tocIndex:78}]},25252:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(31133);const d=[{value:"可以参考 SVG 的 ",paraId:0},{value:"<ellipse>",paraId:0},{value:" 元素。",paraId:0},{value:"如下 ",paraId:1},{value:"示例",paraId:2},{value:" 绘制了一个圆心在 ",paraId:1},{value:"[100, 100]",paraId:1},{value:"，半径为 ",paraId:1},{value:"100",paraId:1},{value:" 的椭圆：",paraId:1},{value:"const ellipse = new Ellipse({\n    style: {\n        cx: 100,\n        cy: 100,\n        rx: 100,\n        ry: 100,\n    },\n});\n",paraId:3},{value:"继承了 ",paraId:4,tocIndex:0},{value:"DisplayObject",paraId:5,tocIndex:0},{value:" 的 ",paraId:4,tocIndex:0},{value:"样式属性",paraId:6,tocIndex:0},{value:"。",paraId:4,tocIndex:0},{value:"默认值为 ",paraId:7,tocIndex:1},{value:"[0.5, 0.5]",paraId:7,tocIndex:1},{value:"。详见 ",paraId:7,tocIndex:1},{value:"DisplayObject anchor",paraId:8,tocIndex:1},{value:"默认值为 ",paraId:9,tocIndex:2},{value:"center",paraId:9,tocIndex:2},{value:"。详见 ",paraId:9,tocIndex:2},{value:"DisplayObject transformOrigin",paraId:10,tocIndex:2},{value:"圆心在局部坐标系下的 x 轴坐标。",paraId:11,tocIndex:4},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/cx",paraId:12,tocIndex:4},{value:"初始值",paraId:13,tocIndex:4},{value:"适用元素",paraId:14,tocIndex:4},{value:"是否可继承",paraId:15,tocIndex:4},{value:"是否支持动画",paraId:14,tocIndex:4},{value:"计算值",paraId:16,tocIndex:4},{value:"'0'",paraId:14,tocIndex:4},{value:"-",paraId:14,tocIndex:4},{value:"否",paraId:14,tocIndex:4},{value:"是",paraId:14,tocIndex:4},{value:"<percentage>",paraId:17,tocIndex:4},{value:" ",paraId:14,tocIndex:4},{value:"<length>",paraId:18,tocIndex:4},{value:"圆心在局部坐标系下的 y 轴坐标。",paraId:19,tocIndex:5},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/cy",paraId:20,tocIndex:5},{value:"初始值",paraId:21,tocIndex:5},{value:"适用元素",paraId:22,tocIndex:5},{value:"是否可继承",paraId:23,tocIndex:5},{value:"是否支持动画",paraId:22,tocIndex:5},{value:"计算值",paraId:24,tocIndex:5},{value:"'0'",paraId:22,tocIndex:5},{value:"-",paraId:22,tocIndex:5},{value:"否",paraId:22,tocIndex:5},{value:"是",paraId:22,tocIndex:5},{value:"<percentage>",paraId:25,tocIndex:5},{value:" ",paraId:22,tocIndex:5},{value:"<length>",paraId:26,tocIndex:5},{value:"椭圆的水平半径",paraId:27,tocIndex:6},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/rx",paraId:28,tocIndex:6},{value:"初始值",paraId:29,tocIndex:6},{value:"适用元素",paraId:30,tocIndex:6},{value:"是否可继承",paraId:31,tocIndex:6},{value:"是否支持动画",paraId:30,tocIndex:6},{value:"计算值",paraId:32,tocIndex:6},{value:"'0'",paraId:30,tocIndex:6},{value:"-",paraId:30,tocIndex:6},{value:"否",paraId:30,tocIndex:6},{value:"是",paraId:30,tocIndex:6},{value:"<percentage>",paraId:33,tocIndex:6},{value:" ",paraId:30,tocIndex:6},{value:"<length>",paraId:34,tocIndex:6},{value:"椭圆的垂直半径",paraId:35,tocIndex:7},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/ry",paraId:36,tocIndex:7},{value:"初始值",paraId:37,tocIndex:7},{value:"适用元素",paraId:38,tocIndex:7},{value:"是否可继承",paraId:39,tocIndex:7},{value:"是否支持动画",paraId:38,tocIndex:7},{value:"计算值",paraId:40,tocIndex:7},{value:"'0'",paraId:38,tocIndex:7},{value:"-",paraId:38,tocIndex:7},{value:"否",paraId:38,tocIndex:7},{value:"是",paraId:38,tocIndex:7},{value:"<percentage>",paraId:41,tocIndex:7},{value:" ",paraId:38,tocIndex:7},{value:"<length>",paraId:42,tocIndex:7}]},24498:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(70627);const d=[{value:"虽然我们支持在所有基础图形上添加子节点表达层次关系，但有时还是需要一种类似“容器”的概念，它本身并无实体，只容纳其他子元素。例如典型的太阳系例子中，太阳轨道、地球轨道就使用了 Group 来创建。",paraId:0},{value:"虽然 Group 没有绘图属性，但 ",paraId:1},{value:"DisplayObject",paraId:2},{value:" 的通用能力它都具有。例如查询子节点、变换、获取包围盒等。",paraId:1},{value:"group.appendChild(circle);\ngroup.getBounds(); // circle's bounds\n\n// transform\ngroup.translate(100, 0);\n\n// query\ngroup.getElementsByTagName('circle'); // [circle]\n",paraId:3},{value:"DisplayObject",paraId:4,tocIndex:0}]},3806:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(6174);const d=[{value:"有时我们需要在画布上增加一些 HUD（Head-Up Display），例如 Tooltip。此时用 HTML + CSS 展现相比使用基础图形绘制有以下优势：",paraId:0},{value:"很多原生 HTML 组件难以绘制，例如一些输入类组件 ",paraId:1},{value:"<input>",paraId:1},{value:" ",paraId:1},{value:"<select>",paraId:1},{value:"部分 HTML 原生特性难以实现，例如使用 g-canvas/webgl 绘制文本后无法选中，而如果用 HTML 展示文本就可以，下图展示了文本选中效果，",paraId:1},{value:"示例",paraId:2},{value:"：",paraId:1},{value:"HTML 内容以及宽高为必填项，其中 HTML 内容可以为字符串或者 HTMLElement：",paraId:3},{value:"const html = new HTML({\n    style: {\n        x: 0,\n        y: 0,\n        width: 100,\n        height: 100,\n        innerHTML: '<h1>This is Title</h1>',\n    },\n});\ncanvas.appendChild(html);\n",paraId:4},{value:"之所以一定要指定宽高（至少是初始宽高），是由于 SVG 的 ",paraId:5},{value:"<foreignObject>",paraId:5},{value:" 元素必须指定否则无法显示。",paraId:5},{value:"在实现中 g-canvas/webgl 会将 HTML 内容包裹在 ",paraId:6,tocIndex:0},{value:"<div>",paraId:6,tocIndex:0},{value:" 中，以 ",paraId:6,tocIndex:0},{value:"<canvas>",paraId:6,tocIndex:0},{value:" 的兄弟节点放在容器内。而在 g-svg 中使用 ",paraId:6,tocIndex:0},{value:"<foreignObject>",paraId:6,tocIndex:0},{value:" 包裹内容：",paraId:6,tocIndex:0},{value:'// g-canvas/webgl 的 DOM 结构\n<div id="container">\n    <canvas></canvas>\n    <div name="容器元素">\n        \x3c!-- content --\x3e\n    </div>\n</div>\n\n// g-svg 的 DOM 结构\n<div id="container">\n    <svg>\n        <foreignObject name="容器元素">\n            \x3c!-- content --\x3e\n        </foreignObject>\n    </svg>\n</div>\n',paraId:7,tocIndex:0},{value:"DisplayObject",paraId:8,tocIndex:1},{value:"其中的 ",paraId:9,tocIndex:1},{value:"id",paraId:10,tocIndex:1},{value:"，",paraId:9,tocIndex:1},{value:"name",paraId:11,tocIndex:1},{value:"，",paraId:9,tocIndex:1},{value:"className",paraId:12,tocIndex:1},{value:" 如果传入都会被应用在容器元素上，因此有两种方式获取到容器元素：",paraId:9,tocIndex:1},{value:"通过类似 ",paraId:13,tocIndex:1},{value:"getElementById",paraId:13,tocIndex:1},{value:" 这样的 DOM API 获取",paraId:13,tocIndex:1},{value:"使用 ",paraId:13,tocIndex:1},{value:"getDomElement()",paraId:14,tocIndex:1},{value:"其他样式属性通过 CSS 应用。",paraId:15,tocIndex:1},{value:"对应 CSS ",paraId:16,tocIndex:2},{value:"background",paraId:16,tocIndex:2},{value:" 属性。",paraId:16,tocIndex:2},{value:"对应 CSS ",paraId:17,tocIndex:3},{value:"border-color",paraId:17,tocIndex:3},{value:" 属性。",paraId:17,tocIndex:3},{value:"对应 CSS ",paraId:18,tocIndex:4},{value:"border-width",paraId:18,tocIndex:4},{value:" 属性。",paraId:18,tocIndex:4},{value:"对应 CSS ",paraId:19,tocIndex:5},{value:"border-style",paraId:19,tocIndex:5},{value:" 属性。",paraId:19,tocIndex:5},{value:"使用 ",paraId:20,tocIndex:5},{value:"dashed",paraId:20,tocIndex:5},{value:" 值，但无法精确控制 ",paraId:20,tocIndex:5},{value:"dash",paraId:20,tocIndex:5},{value:" 和 ",paraId:20,tocIndex:5},{value:"gap",paraId:20,tocIndex:5},{value:" 的长度。",paraId:20,tocIndex:5},{value:"对应 CSS ",paraId:21,tocIndex:6},{value:"opacity",paraId:21,tocIndex:6},{value:" 属性。",paraId:21,tocIndex:6},{value:"对应 CSS ",paraId:22,tocIndex:7},{value:"visibility",paraId:22,tocIndex:7},{value:" 属性。",paraId:22,tocIndex:7},{value:"对应 CSS ",paraId:23,tocIndex:8},{value:"pointer-events",paraId:23,tocIndex:8},{value:" 属性。",paraId:23,tocIndex:8},{value:"当我们在实现类似 tooltip 这样的需求时，可以让鼠标事件穿透它，",paraId:24,tocIndex:8},{value:"示例",paraId:25,tocIndex:8},{value:"：",paraId:24,tocIndex:8},{value:"const tooltip = new HTML({\n    style: {\n        x: 0,\n        y: 0,\n        innerHTML: 'Tooltip',\n        fill: 'white',\n        stroke: 'black',\n        lineWidth: 6,\n        width: 100,\n        height: 30,\n        pointerEvents: 'none', // 让事件穿透它\n        visibility: 'hidden',\n    },\n});\n",paraId:26,tocIndex:8},{value:"对应 CSS ",paraId:27,tocIndex:9},{value:"transform",paraId:27,tocIndex:9},{value:" 属性。",paraId:27,tocIndex:9},{value:"使用生成全局坐标系下的 matrix 字符串形式。",paraId:28,tocIndex:9},{value:"对应 CSS ",paraId:29,tocIndex:10},{value:"transform-origin",paraId:29,tocIndex:10},{value:" 属性。",paraId:29,tocIndex:10},{value:"局部坐标系下，容器左上角顶点的 x 轴坐标。",paraId:30,tocIndex:12},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/x",paraId:31,tocIndex:12},{value:"初始值",paraId:32,tocIndex:12},{value:"适用元素",paraId:33,tocIndex:12},{value:"是否可继承",paraId:34,tocIndex:12},{value:"是否支持动画",paraId:33,tocIndex:12},{value:"计算值",paraId:35,tocIndex:12},{value:"'0'",paraId:33,tocIndex:12},{value:"-",paraId:33,tocIndex:12},{value:"否",paraId:33,tocIndex:12},{value:"是",paraId:33,tocIndex:12},{value:"<percentage>",paraId:36,tocIndex:12},{value:" ",paraId:33,tocIndex:12},{value:"<length>",paraId:37,tocIndex:12},{value:"局部坐标系下，容器左上角顶点的 y 轴坐标。",paraId:38,tocIndex:13},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/y",paraId:39,tocIndex:13},{value:"初始值",paraId:40,tocIndex:13},{value:"适用元素",paraId:41,tocIndex:13},{value:"是否可继承",paraId:42,tocIndex:13},{value:"是否支持动画",paraId:41,tocIndex:13},{value:"计算值",paraId:43,tocIndex:13},{value:"'0'",paraId:41,tocIndex:13},{value:"-",paraId:41,tocIndex:13},{value:"否",paraId:41,tocIndex:13},{value:"是",paraId:41,tocIndex:13},{value:"<percentage>",paraId:44,tocIndex:13},{value:" ",paraId:41,tocIndex:13},{value:"<length>",paraId:45,tocIndex:13},{value:"类型",paraId:46,tocIndex:14},{value:"： ",paraId:46,tocIndex:14},{value:"string | HTMLElement",paraId:46,tocIndex:14},{value:"默认值",paraId:47,tocIndex:14},{value:"：无",paraId:47,tocIndex:14},{value:"是否必须",paraId:48,tocIndex:14},{value:"：",paraId:48,tocIndex:14},{value:"true",paraId:48,tocIndex:14},{value:"说明",paraId:49,tocIndex:14},{value:"：HTML 内容，可以为字符串或者 HTMLElement",paraId:49,tocIndex:14},{value:"const html = new HTML({\n    style: {\n        width: 100,\n        height: 100,\n        innerHTML: '<h1>This is Title</h1>',\n        // innerHTML: 'content',\n        // innerHTML: document.createElement('div'),\n    },\n});\n\nhtml.style.innerHTML = '<h1>This is Title</h1>';\n",paraId:50,tocIndex:14},{value:"容器宽度，默认值为 ",paraId:51,tocIndex:15},{value:"'auto'",paraId:51,tocIndex:15},{value:"。",paraId:51,tocIndex:15},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/width",paraId:52,tocIndex:15},{value:"初始值",paraId:53,tocIndex:15},{value:"适用元素",paraId:54,tocIndex:15},{value:"是否可继承",paraId:55,tocIndex:15},{value:"是否支持动画",paraId:54,tocIndex:15},{value:"计算值",paraId:56,tocIndex:15},{value:"'0'",paraId:54,tocIndex:15},{value:"-",paraId:54,tocIndex:15},{value:"否",paraId:54,tocIndex:15},{value:"是",paraId:54,tocIndex:15},{value:"<percentage>",paraId:57,tocIndex:15},{value:" ",paraId:54,tocIndex:15},{value:"<length>",paraId:58,tocIndex:15},{value:"容器宽度，默认值为 ",paraId:59,tocIndex:16},{value:"'auto'",paraId:59,tocIndex:16},{value:"。",paraId:59,tocIndex:16},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/height",paraId:60,tocIndex:16},{value:"初始值",paraId:61,tocIndex:16},{value:"适用元素",paraId:62,tocIndex:16},{value:"是否可继承",paraId:63,tocIndex:16},{value:"是否支持动画",paraId:62,tocIndex:16},{value:"计算值",paraId:64,tocIndex:16},{value:"'0'",paraId:62,tocIndex:16},{value:"-",paraId:62,tocIndex:16},{value:"否",paraId:62,tocIndex:16},{value:"是",paraId:62,tocIndex:16},{value:"<percentage>",paraId:65,tocIndex:16},{value:" ",paraId:62,tocIndex:16},{value:"<length>",paraId:66,tocIndex:16},{value:"CSS 属性将被透传并直接应用到 DOM 容器的 style 上，在下面的",paraId:67,tocIndex:17},{value:"示例",paraId:68,tocIndex:17},{value:"中，",paraId:67,tocIndex:17},{value:"fontSize",paraId:67,tocIndex:17},{value:" ",paraId:67,tocIndex:17},{value:"textAlign",paraId:67,tocIndex:17},{value:" ",paraId:67,tocIndex:17},{value:"color",paraId:67,tocIndex:17},{value:" 等 CSS 属性将直接体现在样式上：",paraId:67,tocIndex:17},{value:"const html = new HTML({\n    style: {\n        x: 200,\n        y: 100,\n        width: 200,\n        height: 200,\n        innerHTML: 'p1',\n        // The followin will override the CSS properties.\n        fontSize: '20px',\n        textAlign: 'center',\n        color: 'red',\n    },\n});\n",paraId:69,tocIndex:17},{value:"获取容器元素，例如在 g-canvas/webgl 中会得到 ",paraId:70,tocIndex:19},{value:"<div>",paraId:70,tocIndex:19},{value:"，而在 g-svg 中会得到 ",paraId:70,tocIndex:19},{value:"<foreignObject>",paraId:70,tocIndex:19},{value:"：",paraId:70,tocIndex:19},{value:"// g-canvas/webgl\nconst $div = html.getDomElement(); // HTMLDivElement\n\n// g-svg\nconst $foreignObject = html.getDomElement(); // <foreignObject>\n",paraId:71,tocIndex:19},{value:"绝大部分场景图能力都可以在 HTML 上使用，例如",paraId:72,tocIndex:22},{value:"变换操作",paraId:73,tocIndex:22},{value:"：",paraId:72,tocIndex:22},{value:"html.translate(100, 0); // 平移\nhtml.scale(2); // 缩放\nhtml.rotate(30); // 旋转\n",paraId:74,tocIndex:22},{value:"在获取包围盒时，我们会使用原生 DOM API ",paraId:75,tocIndex:22},{value:"getBoundingClientRect",paraId:75,tocIndex:22},{value:"，因此在首次渲染完成之前调用会得到不正确的结果。",paraId:75,tocIndex:22},{value:"对于 HTML 元素，添加其他基础图形作为它的子元素意义不大。此时可以使用 ",paraId:76,tocIndex:23},{value:"getDomElement",paraId:77,tocIndex:23},{value:" 获取容器元素后再进行后续的 DOM 操作，例如添加子节点：",paraId:76,tocIndex:23},{value:"const $div = document.createElement('div');\n\n// wrong\nhtml.appendChild($div);\n\n// correct\nhtml.getDomElement().appendChild($div);\n",paraId:78,tocIndex:23},{value:"隐藏展示都可以正常使用：",paraId:79,tocIndex:24},{value:"html.show();\nhtml.style.visibility = 'visible';\n\nhtml.hide();\nhtml.style.visibility = 'hidden';\n",paraId:80,tocIndex:24},{value:"但是在通过 ",paraId:81,tocIndex:24},{value:"z-index",paraId:82,tocIndex:24},{value:" 指定渲染顺序时，受限于具体实现，仅在各个 HTML 内容间生效。在下面的例子中，html1 无法在 circle1 和 circle2 之间展示：",paraId:81,tocIndex:24},{value:"// 在 <canvas> 中渲染的两个 circle\ncircle1.style.zIndex = 1;\ncircle2.style.zIndex = 3;\n\nhtml1.style.zIndex = 2;\nhtml2.style.zIndex = 100;\n",paraId:83,tocIndex:24},{value:"由于 ",paraId:84,tocIndex:25},{value:"foreignObject",paraId:84,tocIndex:25},{value:" 需要指定宽高才能渲染，在创建时指定后也可以进行修改：",paraId:84,tocIndex:25},{value:"html.style.width = 100;\nhtml.style.height = 100;\n",paraId:85,tocIndex:25},{value:"目前其他基础图形动画都是通过 Keyframe 插值后重绘完成。对于 HTML 图形，理想状况显然是直接使用 CSS Animation。",paraId:86,tocIndex:26}]},67705:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(77334);const d=[{value:"可以参考 SVG 的 ",paraId:0},{value:"<image>",paraId:0},{value:" 元素。",paraId:0},{value:"如下 ",paraId:1},{value:"示例",paraId:2},{value:" 定义了一个图片，左上角顶点位置为 ",paraId:1},{value:"(200, 100)",paraId:1},{value:"：",paraId:1},{value:"const image = new Image({\n    style: {\n        x: 200,\n        y: 100,\n        width: 200,\n        height: 200,\n        src: 'https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*N4ZMS7gHsUIAAAAAAAAAAABkARQnAQ',\n    },\n});\n",paraId:3},{value:"通常我们习惯以图片中心，此时可以通过锚点 ",paraId:4},{value:"anchor",paraId:5},{value:" 进行修改：",paraId:4},{value:"const image = new Image({\n    style: {\n        // 省略其他属性\n        anchor: [0.5, 0.5],\n    },\n});\n",paraId:6},{value:"对于大尺寸图片，如果遇到性能问题，可以尝试打开 ",paraId:7},{value:"enableLargeImageOptimization",paraId:8},{value:" 配置。",paraId:7},{value:"继承了 ",paraId:9,tocIndex:0},{value:"DisplayObject",paraId:10,tocIndex:0},{value:" 的 ",paraId:9,tocIndex:0},{value:"样式属性",paraId:11,tocIndex:0},{value:"。",paraId:9,tocIndex:0},{value:"默认值为 ",paraId:12,tocIndex:1},{value:"[0, 0]",paraId:12,tocIndex:1},{value:"。详见 ",paraId:12,tocIndex:1},{value:"DisplayObject anchor",paraId:13,tocIndex:1},{value:"默认值为 ",paraId:14,tocIndex:2},{value:"left top",paraId:14,tocIndex:2},{value:"。详见 ",paraId:14,tocIndex:2},{value:"DisplayObject transformOrigin",paraId:15,tocIndex:2},{value:"局部坐标系下，图片左上角顶点的 x 轴坐标。",paraId:16,tocIndex:4},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/x",paraId:17,tocIndex:4},{value:"初始值",paraId:18,tocIndex:4},{value:"适用元素",paraId:19,tocIndex:4},{value:"是否可继承",paraId:20,tocIndex:4},{value:"是否支持动画",paraId:19,tocIndex:4},{value:"计算值",paraId:21,tocIndex:4},{value:"'0'",paraId:19,tocIndex:4},{value:"-",paraId:19,tocIndex:4},{value:"否",paraId:19,tocIndex:4},{value:"是",paraId:19,tocIndex:4},{value:"<percentage>",paraId:22,tocIndex:4},{value:" ",paraId:19,tocIndex:4},{value:"<length>",paraId:23,tocIndex:4},{value:"局部坐标系下，图片左上角顶点的 y 轴坐标。",paraId:24,tocIndex:5},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/y",paraId:25,tocIndex:5},{value:"初始值",paraId:26,tocIndex:5},{value:"适用元素",paraId:27,tocIndex:5},{value:"是否可继承",paraId:28,tocIndex:5},{value:"是否支持动画",paraId:27,tocIndex:5},{value:"计算值",paraId:29,tocIndex:5},{value:"'0'",paraId:27,tocIndex:5},{value:"-",paraId:27,tocIndex:5},{value:"否",paraId:27,tocIndex:5},{value:"是",paraId:27,tocIndex:5},{value:"<percentage>",paraId:30,tocIndex:5},{value:" ",paraId:27,tocIndex:5},{value:"<length>",paraId:31,tocIndex:5},{value:"图片来源，支持以下类型：",paraId:32,tocIndex:6},{value:"string",paraId:33,tocIndex:6},{value:" 图片链接地址",paraId:33,tocIndex:6},{value:"HTMLImageElement",paraId:33,tocIndex:6},{value:" 创建 ",paraId:33,tocIndex:6},{value:"Image",paraId:33,tocIndex:6},{value:" 对象实例，在 ",paraId:33,tocIndex:6},{value:"onload",paraId:33,tocIndex:6},{value:" 回调中创建 G Image 对象，示例如下：",paraId:33,tocIndex:6},{value:"import { Image as GImage, Canvas } from '@antv/g';\n\nlet image;\nconst img = new Image();\n\nimg.src =\n    'https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*N4ZMS7gHsUIAAAAAAAAAAABkARQnAQ';\nimg.crossOrigin = 'Anonymous';\nimg.onload = () => {\n    // 图片加载成功后创建\n    image = new GImage({\n        style: {\n            x: 200,\n            y: 100,\n            width: 200,\n            height: 200,\n            src: img, // 传入 Image 对象\n        },\n    });\n    canvas.appendChild(image);\n};\n",paraId:34,tocIndex:6},{value:"图片宽度。",paraId:35,tocIndex:7},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/width",paraId:36,tocIndex:7},{value:"初始值",paraId:37,tocIndex:7},{value:"适用元素",paraId:38,tocIndex:7},{value:"是否可继承",paraId:39,tocIndex:7},{value:"是否支持动画",paraId:38,tocIndex:7},{value:"计算值",paraId:40,tocIndex:7},{value:"'0'",paraId:38,tocIndex:7},{value:"-",paraId:38,tocIndex:7},{value:"否",paraId:38,tocIndex:7},{value:"是",paraId:38,tocIndex:7},{value:"<percentage>",paraId:41,tocIndex:7},{value:" ",paraId:38,tocIndex:7},{value:"<length>",paraId:42,tocIndex:7},{value:"图片高度。",paraId:43,tocIndex:8},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/height",paraId:44,tocIndex:8},{value:"初始值",paraId:45,tocIndex:8},{value:"适用元素",paraId:46,tocIndex:8},{value:"是否可继承",paraId:47,tocIndex:8},{value:"是否支持动画",paraId:46,tocIndex:8},{value:"计算值",paraId:48,tocIndex:8},{value:"'0'",paraId:46,tocIndex:8},{value:"-",paraId:46,tocIndex:8},{value:"否",paraId:46,tocIndex:8},{value:"是",paraId:46,tocIndex:8},{value:"<percentage>",paraId:49,tocIndex:8},{value:" ",paraId:46,tocIndex:8},{value:"<length>",paraId:50,tocIndex:8},{value:"保持宽高比。开启后，只需要传入宽高任意一项，加载完成后根据原始图片的宽高比计算缺失项。",paraId:51,tocIndex:9},{value:"示例",paraId:52,tocIndex:9},{value:"const image = new Image({\n    style: {\n        width: 200,\n        keepAspectRatio: true,\n        src: 'https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*N4ZMS7gHsUIAAAAAAAAAAABkARQnAQ',\n    },\n});\n",paraId:53,tocIndex:9},{value:"在 3D 场景下是否永远面朝相机，默认为 ",paraId:54,tocIndex:10},{value:"false",paraId:54,tocIndex:10},{value:"，也称作“公告牌效果”。",paraId:54,tocIndex:10},{value:"在",paraId:55,tocIndex:10},{value:"示例",paraId:56,tocIndex:10},{value:"中，未开启情况下在相机发生旋转时，图片会呈现被压缩的效果：",paraId:55,tocIndex:10},{value:"开启后并不会改变图片的位置，但它会始终面朝相机。这也符合通常 3D 场景下对于图片这类 2D 图形的需求：",paraId:57,tocIndex:10},{value:"公告牌模式下的旋转角度，顺时针方向以 radians 为单位。",paraId:58,tocIndex:11},{value:"在",paraId:59,tocIndex:11},{value:"示例",paraId:60,tocIndex:11},{value:"中，我们为图片增加一个旋转角度：",paraId:59,tocIndex:11},{value:"image.style.isBillboard = true;\nimage.style.billboardRotation = Math.PI / 8;\n",paraId:61,tocIndex:11},{value:"在透视投影下，是否进行尺寸衰减。在透视投影中遵循“近大远小”的视觉效果，如果希望保持大小始终一致不受深度影响，可以开启该选项。",paraId:62,tocIndex:12},{value:"在",paraId:63,tocIndex:12},{value:"示例",paraId:64,tocIndex:12},{value:"中，我们为图片开启了尺寸衰减：",paraId:63,tocIndex:12},{value:"image.style.isSizeAttenuation = true;\n",paraId:65,tocIndex:12}]},43440:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(33381);const d=[{value:"可以参考 SVG 的 ",paraId:0},{value:"<line>",paraId:0},{value:" 元素。",paraId:0},{value:"如下 ",paraId:1},{value:"示例",paraId:2},{value:" 定义了一条直线，两个端点分别为 ",paraId:1},{value:"[200, 100]",paraId:1},{value:" 和 ",paraId:1},{value:"[400, 100]",paraId:1},{value:"，线宽为 2，而且是一条虚线：",paraId:1},{value:"const line1 = new Line({\n    style: {\n        x1: 200,\n        y1: 100,\n        x2: 400,\n        y2: 100,\n        stroke: '#1890FF',\n        lineWidth: 2,\n        lineDash: [10, 10],\n    },\n});\n",paraId:3},{value:"对于直线，默认锚点定义的位置为包围盒左上角顶点，其中两个端点坐标 ",paraId:4},{value:"[x1, y1]",paraId:4},{value:" ",paraId:4},{value:"[x2, y2]",paraId:4},{value:" 定义在局部坐标系下，因此如果此时获取该直线在局部坐标系的坐标，会得到 ",paraId:4},{value:"[x1, y1]",paraId:4},{value:" 的坐标，即 ",paraId:4},{value:"[200, 100]",paraId:4},{value:"：",paraId:4},{value:"line1.getLocalPosition(); // [200, 100]\n",paraId:5},{value:"对于上面的直线为 ",paraId:6},{value:"(200, 100)",paraId:6},{value:"。当我们想沿 X 轴向右移动该直线 100 距离时，可以有以下三种做法：",paraId:6},{value:"使用 translate 在世界坐标系下平移一段相对距离",paraId:7},{value:"使用 setPosition 设置世界坐标系下的绝对坐标",paraId:7},{value:"直接修改直线定义中的 x1/x2 属性",paraId:7},{value:"// 平移相对距离，此时 x1/x2 不变\nline1.translate(100, 0);\n// 或者，直接设置锚点位置\nline1.setPosition(200 + 100, 0);\n// 或者，直接移动两个端点\nline1.style.x1 = 200 + 100;\nline1.style.x2 = 400 + 100;\n",paraId:8},{value:"如果想更改默认的锚点位置，可以通过 ",paraId:9},{value:"anchor",paraId:9},{value:" 属性修改，例如把直线的中点作为锚点，此时直线局部坐标系下的坐标不变，但会把锚点移动到 ",paraId:9},{value:"[200, 100]",paraId:9},{value:"，因此展示效果会发生改变：",paraId:9},{value:"line.style.anchor = [0.5, 0.5];\nline.getLocalPosition(); // [200, 100]\n",paraId:10},{value:"继承了 ",paraId:11,tocIndex:0},{value:"DisplayObject",paraId:12,tocIndex:0},{value:" 的 ",paraId:11,tocIndex:0},{value:"样式属性",paraId:13,tocIndex:0},{value:"。",paraId:11,tocIndex:0},{value:"默认值为 ",paraId:14,tocIndex:1},{value:"[0, 0]",paraId:14,tocIndex:1},{value:"。详见 ",paraId:14,tocIndex:1},{value:"DisplayObject anchor",paraId:15,tocIndex:1},{value:"默认值为 ",paraId:16,tocIndex:2},{value:"left top",paraId:16,tocIndex:2},{value:"。详见 ",paraId:16,tocIndex:2},{value:"DisplayObject transformOrigin",paraId:17,tocIndex:2},{value:"默认值为 ",paraId:18,tocIndex:3},{value:"'1'",paraId:18,tocIndex:3},{value:"。详见 ",paraId:18,tocIndex:3},{value:"DisplayObject lineWidth",paraId:19,tocIndex:3},{value:"局部坐标系下，第一个端点的 x 轴坐标。",paraId:20,tocIndex:5},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/x1",paraId:21,tocIndex:5},{value:"初始值",paraId:22,tocIndex:5},{value:"适用元素",paraId:23,tocIndex:5},{value:"是否可继承",paraId:24,tocIndex:5},{value:"是否支持动画",paraId:23,tocIndex:5},{value:"计算值",paraId:25,tocIndex:5},{value:"'0'",paraId:23,tocIndex:5},{value:"-",paraId:23,tocIndex:5},{value:"否",paraId:23,tocIndex:5},{value:"是",paraId:23,tocIndex:5},{value:"<percentage>",paraId:26,tocIndex:5},{value:" ",paraId:23,tocIndex:5},{value:"<length>",paraId:27,tocIndex:5},{value:"局部坐标系下，第一个端点的 y 轴坐标。",paraId:28,tocIndex:6},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/y1",paraId:29,tocIndex:6},{value:"初始值",paraId:30,tocIndex:6},{value:"适用元素",paraId:31,tocIndex:6},{value:"是否可继承",paraId:32,tocIndex:6},{value:"是否支持动画",paraId:31,tocIndex:6},{value:"计算值",paraId:33,tocIndex:6},{value:"'0'",paraId:31,tocIndex:6},{value:"-",paraId:31,tocIndex:6},{value:"否",paraId:31,tocIndex:6},{value:"是",paraId:31,tocIndex:6},{value:"<percentage>",paraId:34,tocIndex:6},{value:" ",paraId:31,tocIndex:6},{value:"<length>",paraId:35,tocIndex:6},{value:"局部坐标系下，第一个端点的 z 轴坐标。",paraId:36,tocIndex:7},{value:"初始值",paraId:37,tocIndex:7},{value:"适用元素",paraId:38,tocIndex:7},{value:"是否可继承",paraId:39,tocIndex:7},{value:"是否支持动画",paraId:38,tocIndex:7},{value:"计算值",paraId:40,tocIndex:7},{value:"'0'",paraId:38,tocIndex:7},{value:"-",paraId:38,tocIndex:7},{value:"否",paraId:38,tocIndex:7},{value:"是",paraId:38,tocIndex:7},{value:"<percentage>",paraId:41,tocIndex:7},{value:" ",paraId:38,tocIndex:7},{value:"<length>",paraId:42,tocIndex:7},{value:"局部坐标系下，第二个端点的 x 轴坐标。",paraId:43,tocIndex:8},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/x2",paraId:44,tocIndex:8},{value:"初始值",paraId:45,tocIndex:8},{value:"适用元素",paraId:46,tocIndex:8},{value:"是否可继承",paraId:47,tocIndex:8},{value:"是否支持动画",paraId:46,tocIndex:8},{value:"计算值",paraId:48,tocIndex:8},{value:"'0'",paraId:46,tocIndex:8},{value:"-",paraId:46,tocIndex:8},{value:"否",paraId:46,tocIndex:8},{value:"是",paraId:46,tocIndex:8},{value:"<percentage>",paraId:49,tocIndex:8},{value:" ",paraId:46,tocIndex:8},{value:"<length>",paraId:50,tocIndex:8},{value:"局部坐标系下，第二个端点的 y 轴坐标。",paraId:51,tocIndex:9},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/y2",paraId:52,tocIndex:9},{value:"初始值",paraId:53,tocIndex:9},{value:"适用元素",paraId:54,tocIndex:9},{value:"是否可继承",paraId:55,tocIndex:9},{value:"是否支持动画",paraId:54,tocIndex:9},{value:"计算值",paraId:56,tocIndex:9},{value:"'0'",paraId:54,tocIndex:9},{value:"-",paraId:54,tocIndex:9},{value:"否",paraId:54,tocIndex:9},{value:"是",paraId:54,tocIndex:9},{value:"<percentage>",paraId:57,tocIndex:9},{value:" ",paraId:54,tocIndex:9},{value:"<length>",paraId:58,tocIndex:9},{value:"局部坐标系下，第二个端点的 z 轴坐标。",paraId:59,tocIndex:10},{value:"初始值",paraId:60,tocIndex:10},{value:"适用元素",paraId:61,tocIndex:10},{value:"是否可继承",paraId:62,tocIndex:10},{value:"是否支持动画",paraId:61,tocIndex:10},{value:"计算值",paraId:63,tocIndex:10},{value:"'0'",paraId:61,tocIndex:10},{value:"-",paraId:61,tocIndex:10},{value:"否",paraId:61,tocIndex:10},{value:"是",paraId:61,tocIndex:10},{value:"<percentage>",paraId:64,tocIndex:10},{value:" ",paraId:61,tocIndex:10},{value:"<length>",paraId:65,tocIndex:10},{value:"3D 场景中生效，始终朝向屏幕，因此线宽不受透视投影影像。默认值为 ",paraId:66,tocIndex:11},{value:"false",paraId:66,tocIndex:11},{value:"。",paraId:66,tocIndex:11},{value:"示例",paraId:67,tocIndex:11},{value:"可以参考 SVG 的 ",paraId:68,tocIndex:12},{value:"同名属性",paraId:68,tocIndex:12},{value:"。",paraId:68,tocIndex:12},{value:"在直线的 “起始点” 处添加一个标记图形，其中 “起始点” 为 ",paraId:69,tocIndex:12},{value:"x1/y1",paraId:70,tocIndex:12},{value:" 定义的端点。",paraId:69,tocIndex:12},{value:"在下面的 ",paraId:71,tocIndex:12},{value:"示例",paraId:72,tocIndex:12},{value:" 中，我们首先使用 ",paraId:71,tocIndex:12},{value:"Path",paraId:73,tocIndex:12},{value:" 创建了一个箭头，然后通过该属性把它添加到了直线的起点上：",paraId:71,tocIndex:12},{value:"// 创建一个标记图形\nconst arrowMarker = new Path({\n    style: {\n        path: 'M 10,10 L -10,0 L 10,-10 Z',\n        stroke: '#1890FF',\n        anchor: '0.5 0.5',\n        transformOrigin: 'center',\n    },\n});\n\nconst arrowLine = new Line({\n    style: {\n        x1: 200,\n        y1: 250,\n        x2: 400,\n        y2: 250,\n        stroke: '#1890FF',\n        lineWidth: 2,\n        markerStart: arrowMarker, // 放置在直线的 “起始点” 上\n    },\n});\n",paraId:74,tocIndex:12},{value:"标记图形可以是任意图形，我们会将它放置在合适的位置并调整好朝向。当直线的定义改变时，也会随之自动调整。",paraId:75,tocIndex:12},{value:"当然你也可以手动调整它的 ",paraId:76,tocIndex:12},{value:"anchor",paraId:77,tocIndex:12},{value:", ",paraId:76,tocIndex:12},{value:"transformOrigin",paraId:78,tocIndex:12},{value:" 和 ",paraId:76,tocIndex:12},{value:"transform",paraId:79,tocIndex:12},{value:"，例如在该 ",paraId:76,tocIndex:12},{value:"示例",paraId:80,tocIndex:12},{value:" 中，我们将 ",paraId:76,tocIndex:12},{value:"Image",paraId:81,tocIndex:12},{value:" 作为标记图形，手动旋转了 90 度：",paraId:76,tocIndex:12},{value:"const imageMarker = new Image({\n    style: {\n        width: 50,\n        height: 50,\n        src: 'https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*N4ZMS7gHsUIAAAAAAAAAAABkARQnAQ',\n        anchor: [0.5, 0.5],\n        transformOrigin: 'center',\n        transform: 'rotate(90deg)',\n    },\n});\n",paraId:82,tocIndex:12},{value:"如果想取消设置标记图形，可以设置为 null 或者空字符串：",paraId:83,tocIndex:12},{value:"line.style.markerStart = null;\n",paraId:84,tocIndex:12},{value:"在实现中直线和标记图形的关系为父子关系：",paraId:85,tocIndex:12},{value:"Line\n  -> Path(#markerStart)\n  -> Path(#markerEnd)\n",paraId:86,tocIndex:12},{value:"使用 ",paraId:87,tocIndex:12},{value:"childNodes",paraId:88,tocIndex:12},{value:" 也能发现这一点：",paraId:87,tocIndex:12},{value:"line.style.markerStart = arrowHead;\nline.childNodes; // [Path]\n",paraId:89,tocIndex:12},{value:"“起始点” 和 “终止点” 可以设置为同一个标记图形，内部首先会使用 ",paraId:90,tocIndex:12},{value:"cloneNode",paraId:91,tocIndex:12},{value:" 生成新的图形。因此一旦我们指定了标记图形，后续想修改它的属性就不能在原始图形上操作，需要通过 ",paraId:90,tocIndex:12},{value:"childNodes",paraId:92,tocIndex:12},{value:" 获取：",paraId:90,tocIndex:12},{value:"line.style.markerStart = arrowhead;\nline.style.markerEnd = arrowhead;\n\n// wrong\narrowhead.style.stroke = 'red';\n\n// correct!\nline.childNodes[0].style.stroke = 'red';\n",paraId:93,tocIndex:12},{value:"可以参考 SVG 的 ",paraId:94,tocIndex:13},{value:"同名属性",paraId:94,tocIndex:13},{value:"。",paraId:94,tocIndex:13},{value:"在直线的 “终止点” 处添加一个标记图形，其中 “终止点” 为 ",paraId:95,tocIndex:13},{value:"x2/y2",paraId:96,tocIndex:13},{value:" 定义的端点。",paraId:95,tocIndex:13},{value:"有时我们想调整标记图形的位置，为此我们提供了该选项沿直线方向增加一定偏移量，正偏移量向内，负偏移量向外。",paraId:97,tocIndex:14},{value:"在 ",paraId:98,tocIndex:14},{value:"示例",paraId:99,tocIndex:14},{value:" 中，我们通过操作该属性让直线实现“伸缩效果”：",paraId:98,tocIndex:14},{value:"值得注意的是，虽然偏移量会让直线在视觉效果上发生变化，但并不会影响 ",paraId:100,tocIndex:14},{value:"x1/y1/x2/y2",paraId:101,tocIndex:14},{value:" 这些属性值。",paraId:100,tocIndex:14},{value:"在 ",paraId:102,tocIndex:14},{value:"示例",paraId:103,tocIndex:14},{value:" 中，直线端点与两端的圆心重合，但为了避免箭头与两端的节点重合，需要向内缩进一定距离：",paraId:102,tocIndex:14},{value:"初始值",paraId:104,tocIndex:14},{value:"适用元素",paraId:105,tocIndex:14},{value:"是否可继承",paraId:106,tocIndex:14},{value:"是否支持动画",paraId:105,tocIndex:14},{value:"计算值",paraId:107,tocIndex:14},{value:"'0'",paraId:105,tocIndex:14},{value:"-",paraId:105,tocIndex:14},{value:"否",paraId:105,tocIndex:14},{value:"是",paraId:105,tocIndex:14},{value:"<length>",paraId:108,tocIndex:14},{value:"调整 “终止点” 处标记图形的位置，正偏移量向内，负偏移量向外。",paraId:109,tocIndex:15},{value:"初始值",paraId:110,tocIndex:15},{value:"适用元素",paraId:111,tocIndex:15},{value:"是否可继承",paraId:112,tocIndex:15},{value:"是否支持动画",paraId:111,tocIndex:15},{value:"计算值",paraId:113,tocIndex:15},{value:"'0'",paraId:111,tocIndex:15},{value:"-",paraId:111,tocIndex:15},{value:"否",paraId:111,tocIndex:15},{value:"是",paraId:111,tocIndex:15},{value:"<length>",paraId:114,tocIndex:15},{value:"获取直线长度。",paraId:115,tocIndex:17},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/SVGGeometryElement/getTotalLength",paraId:116,tocIndex:17},{value:"line.getTotalLength(); // 200\n",paraId:117,tocIndex:17},{value:"沿路径返回给定距离的点，通过第二个可选参数控制在局部还是世界坐标系下：",paraId:118,tocIndex:18},{value:"参数如下：",paraId:119,tocIndex:18},{value:"distance",paraId:120,tocIndex:18},{value:" 必填，距离值",paraId:120,tocIndex:18},{value:"inWorldSpace",paraId:120,tocIndex:18},{value:" 可选，表示是否在世界坐标系下计算。默认值为 ",paraId:120,tocIndex:18},{value:"false",paraId:120,tocIndex:18},{value:"其中 ",paraId:121,tocIndex:18},{value:"Point",paraId:121,tocIndex:18},{value:" 的格式为:",paraId:121,tocIndex:18},{value:"export type Point = {\n    x: number;\n    y: number;\n};\n",paraId:122,tocIndex:18},{value:"https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getPointAtLength",paraId:123,tocIndex:18},{value:"例如获取直线上局部坐标系下从起点出发 100 距离的点坐标：",paraId:124,tocIndex:18},{value:"line.getPointAtLength(100); // Point {x: 300, y: 100}\n",paraId:125,tocIndex:18},{value:"根据长度比例（取值范围 ",paraId:126,tocIndex:19},{value:"[0-1]",paraId:126,tocIndex:19},{value:"）获取直线上局部或世界坐标系下的点坐标。",paraId:126,tocIndex:19},{value:"参数如下：",paraId:127,tocIndex:19},{value:"ratio",paraId:128,tocIndex:19},{value:" 必填，长度比例",paraId:128,tocIndex:19},{value:"inWorldSpace",paraId:128,tocIndex:19},{value:" 可选，表示是否在世界坐标系下计算。默认值为 ",paraId:128,tocIndex:19},{value:"false",paraId:128,tocIndex:19},{value:"例如获取上面定义直线的中点：",paraId:129,tocIndex:19},{value:"line.getPoint(0.5); // Point {x: 300, y: 100}\n",paraId:130,tocIndex:19},{value:"需要配合 ",paraId:131,tocIndex:20},{value:"g-webgl",paraId:131,tocIndex:20},{value:" 渲染器与 ",paraId:131,tocIndex:20},{value:"g-plugin-3d",paraId:131,tocIndex:20},{value:" 插件使用。",paraId:131,tocIndex:20},{value:"将端点坐标拓展到三维：",paraId:132,tocIndex:20},{value:"new Line({\n    style: {\n        x1: 200,\n        y1: 100,\n        z1: 0, // Z 轴坐标\n        x2: 400,\n        y2: 100,\n        z2: 100, // Z 轴坐标\n    },\n});\n",paraId:133,tocIndex:20},{value:"2D 的线在正交投影下可以保证一致的宽度，但是在透视投影下就无法保证了。在某些需要时刻保持线宽一致的 3D 场景下，可以开启 ",paraId:134,tocIndex:20},{value:"isBillboard",paraId:135,tocIndex:20},{value:"，",paraId:134,tocIndex:20},{value:"示例",paraId:136,tocIndex:20}]},40331:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(53926);const d=[{value:"使用 Path 可以定义直线、折线、圆弧、贝塞尔曲线等。路径中包含一组命令与参数，这些命令有不同的语义，具体用法可以参考：",paraId:0},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths",paraId:0},{value:"如下 ",paraId:1},{value:"示例",paraId:2},{value:" 定义了一条直线，在局部坐标系下从 ",paraId:1},{value:"[100, 100]",paraId:1},{value:" 到 ",paraId:1},{value:"[200, 200]",paraId:1},{value:"：",paraId:1},{value:"const line = new Path({\n    style: {\n        path: [\n            ['M', 100, 100],\n            ['L', 200, 200],\n        ],\n        stroke: '#F04864',\n    },\n});\n",paraId:3},{value:"继承了 ",paraId:4,tocIndex:0},{value:"DisplayObject",paraId:5,tocIndex:0},{value:" 的 ",paraId:4,tocIndex:0},{value:"样式属性",paraId:6,tocIndex:0},{value:"。",paraId:4,tocIndex:0},{value:"默认锚点定义的位置为包围盒左上角顶点，可以通过 ",paraId:7,tocIndex:0},{value:"anchor",paraId:8,tocIndex:0},{value:" 改变。",paraId:7,tocIndex:0},{value:"关于这一点我们参考了 SVG 的实际表现，以下图为例我们以 ",paraId:9,tocIndex:0},{value:"[100, 100]",paraId:9,tocIndex:0},{value:" 为起点定义了一段圆弧，显然它的包围盒左上角顶点并不是 ",paraId:9,tocIndex:0},{value:"[0, 0]",paraId:9,tocIndex:0},{value:" 或者 ",paraId:9,tocIndex:0},{value:"[100, 100]",paraId:9,tocIndex:0},{value:"，而是需要根据 path 的真实形状计算得出，我们将把这个计算结果作为默认锚点位置，也是局部坐标系下的坐标：",paraId:9,tocIndex:0},{value:"再比如这条直线路径 ",paraId:10,tocIndex:0},{value:"[ ['M', 100, 100], ['L', 200, 200] ]",paraId:10,tocIndex:0},{value:" 在局部坐标系下的 “位置” 为 ",paraId:10,tocIndex:0},{value:"[100, 100]",paraId:10,tocIndex:0},{value:"：",paraId:10,tocIndex:0},{value:"const line = new Path({\n    style: {\n        path: [\n            ['M', 100, 100],\n            ['L', 200, 200],\n        ],\n        stroke: '#F04864',\n    },\n});\n\nline.getLocalPosition(); // [100, 100];\nline.getBounds(); // 包围盒 { min: [100, 100], max: [200, 200] }\nline.translateLocal(100, 0); // 沿 X 轴平移\n",paraId:11,tocIndex:0},{value:"默认值为 ",paraId:12,tocIndex:1},{value:"[0, 0]",paraId:12,tocIndex:1},{value:"。详见 ",paraId:12,tocIndex:1},{value:"DisplayObject anchor",paraId:13,tocIndex:1},{value:"默认值为 ",paraId:14,tocIndex:2},{value:"left top",paraId:14,tocIndex:2},{value:"。详见 ",paraId:14,tocIndex:2},{value:"DisplayObject transformOrigin",paraId:15,tocIndex:2},{value:"默认值为 ",paraId:16,tocIndex:3},{value:"'1'",paraId:16,tocIndex:3},{value:"。详见 ",paraId:16,tocIndex:3},{value:"DisplayObject lineWidth",paraId:17,tocIndex:3},{value:"默认值 ",paraId:18,tocIndex:4},{value:"4",paraId:18,tocIndex:4},{value:"。详见 ",paraId:18,tocIndex:4},{value:"DisplayObject miterLimit",paraId:19,tocIndex:4},{value:"路径，支持 ",paraId:20,tocIndex:6},{value:"字符串",paraId:20,tocIndex:6},{value:"和 ",paraId:20,tocIndex:6},{value:"数组",paraId:20,tocIndex:6},{value:" 两种形式，可参考 ",paraId:20,tocIndex:6},{value:"SVG path",paraId:20,tocIndex:6},{value:"：",paraId:20,tocIndex:6},{value:"字符串形式: ",paraId:21,tocIndex:6},{value:"M 100,100 L 200,200",paraId:21,tocIndex:6},{value:"数组形式: ",paraId:21,tocIndex:6},{value:"[ [ 'M', 100, 100 ], [ 'L', 200, 200 ] ]",paraId:21,tocIndex:6},{value:"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/path",paraId:22,tocIndex:6},{value:"path",paraId:23,tocIndex:7},{value:" 属性的别名，与 SVG 中的 ",paraId:24,tocIndex:7},{value:"<path>",paraId:24,tocIndex:7},{value:" 命名保持一致。",paraId:24,tocIndex:7},{value:"由于 Path 可通过 ",paraId:25,tocIndex:8},{value:"Z",paraId:25,tocIndex:8},{value:" 命令闭合，因此对于 “起始点” 的定义在两种情况下有差别：",paraId:25,tocIndex:8},{value:"如果未闭合，可以参考 ",paraId:26,tocIndex:8},{value:"Polyline",paraId:27,tocIndex:8},{value:" 的 ",paraId:26,tocIndex:8},{value:"markerStart",paraId:28,tocIndex:8},{value:" 属性。",paraId:26,tocIndex:8},{value:"如果已闭合，可以参考 ",paraId:26,tocIndex:8},{value:"Polygon",paraId:29,tocIndex:8},{value:" 的 ",paraId:26,tocIndex:8},{value:"markerStart",paraId:30,tocIndex:8},{value:" 属性。",paraId:26,tocIndex:8},{value:"例如下图中，同样指定了 markerStart 和 markerEnd 为“箭头”，左侧展示了一个未闭合路径的效果，右侧展示了闭合路径的效果：",paraId:31,tocIndex:8},{value:"在该",paraId:32,tocIndex:8},{value:"示例",paraId:33,tocIndex:8},{value:"中，我们在 Path 的起始点上放置了一个箭头：",paraId:32,tocIndex:8},{value:"const arrowMarker = new Path({\n    style: {\n        path: 'M 10,10 L -10,0 L 10,-10 Z',\n        stroke: '#1890FF',\n        anchor: '0.5 0.5',\n        transformOrigin: 'center',\n    },\n});\n\npath.style.markerStart = arrowMarker;\n",paraId:34,tocIndex:8},{value:"可以参考 ",paraId:35,tocIndex:9},{value:"Polyline",paraId:36,tocIndex:9},{value:" 的 ",paraId:35,tocIndex:9},{value:"markerEnd",paraId:37,tocIndex:9},{value:" 属性。",paraId:35,tocIndex:9},{value:"由于 Path 可通过 ",paraId:38,tocIndex:9},{value:"Z",paraId:38,tocIndex:9},{value:" 命令闭合，因此对于 “终止点” 的定义在两种情况下有差别：",paraId:38,tocIndex:9},{value:"如果未闭合，可以参考 ",paraId:39,tocIndex:9},{value:"Polyline",paraId:40,tocIndex:9},{value:" 的 ",paraId:39,tocIndex:9},{value:"markerEnd",paraId:41,tocIndex:9},{value:" 属性。",paraId:39,tocIndex:9},{value:"如果已闭合，可以参考 ",paraId:39,tocIndex:9},{value:"Polygon",paraId:42,tocIndex:9},{value:" 的 ",paraId:39,tocIndex:9},{value:"markerEnd",paraId:43,tocIndex:9},{value:" 属性。",paraId:39,tocIndex:9},{value:"在该",paraId:44,tocIndex:9},{value:"示例",paraId:45,tocIndex:9},{value:"中，我们在多边形的终止点上放置了一个图片：",paraId:44,tocIndex:9},{value:"const imageMarker = new Image({\n    style: {\n        width: 50,\n        height: 50,\n        anchor: [0.5, 0.5],\n        transformOrigin: 'center',\n        transform: 'rotate(90deg)',\n        src: 'https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*N4ZMS7gHsUIAAAAAAAAAAABkARQnAQ',\n    },\n});\n\npath.style.markerEnd = imageMarker;\n",paraId:46,tocIndex:9},{value:"可以参考 SVG 的",paraId:47,tocIndex:10},{value:"同名属性",paraId:47,tocIndex:10},{value:"。",paraId:47,tocIndex:10},{value:"在路径除了 “起始点” 和 “终止点” 之外的每一个顶点上放置标记图形。在内部实现中，由于我们会把路径中部分命令转换成 C 命令，因此这些顶点实际是三阶贝塞尔曲线的控制点。",paraId:48,tocIndex:10},{value:"例如下图中在路径上除首尾的每个顶点上都放置了一个 ",paraId:49,tocIndex:10},{value:"Circle",paraId:50,tocIndex:10},{value:"：",paraId:49,tocIndex:10},{value:"const circleMarker = new Circle({\n    style: {\n        r: 10,\n        stroke: '#1890FF',\n    },\n});\n\npath.style.markerMid = circleMarker;\n",paraId:51,tocIndex:10},{value:"可以参考 ",paraId:52,tocIndex:11},{value:"Polyline",paraId:53,tocIndex:11},{value:" 的 ",paraId:52,tocIndex:11},{value:"markerStartOffset",paraId:54,tocIndex:11},{value:" 属性。marker 会沿路径中第一段的切线方向移动，同时主体路径也会进行相应延长或缩短。需要注意的是主体路径的伸缩距离也是有限的，当超过了第一段的长度，会产生“拐弯”的效果，如下图所示：",paraId:52,tocIndex:11},{value:"因此该属性适合“微调”，而非大幅改变路径定义。",paraId:55,tocIndex:11},{value:"初始值",paraId:56,tocIndex:11},{value:"适用元素",paraId:57,tocIndex:11},{value:"是否可继承",paraId:58,tocIndex:11},{value:"是否支持动画",paraId:57,tocIndex:11},{value:"计算值",paraId:59,tocIndex:11},{value:"'0'",paraId:57,tocIndex:11},{value:"-",paraId:57,tocIndex:11},{value:"否",paraId:57,tocIndex:11},{value:"是",paraId:57,tocIndex:11},{value:"<length>",paraId:60,tocIndex:11},{value:"可以参考 ",paraId:61,tocIndex:12},{value:"Polyline",paraId:62,tocIndex:12},{value:" 的 ",paraId:61,tocIndex:12},{value:"markerEndOffset",paraId:63,tocIndex:12},{value:" 属性。marker 会沿路径中最后一段的切线方向移动，同时主体路径也会进行相应延长或缩短。",paraId:61,tocIndex:12},{value:"初始值",paraId:64,tocIndex:12},{value:"适用元素",paraId:65,tocIndex:12},{value:"是否可继承",paraId:66,tocIndex:12},{value:"是否支持动画",paraId:65,tocIndex:12},{value:"计算值",paraId:67,tocIndex:12},{value:"'0'",paraId:65,tocIndex:12},{value:"-",paraId:65,tocIndex:12},{value:"否",paraId:65,tocIndex:12},{value:"是",paraId:65,tocIndex:12},{value:"<length>",paraId:68,tocIndex:12},{value:"3D 场景中生效，始终朝向屏幕，因此线宽不受透视投影影像。默认值为 ",paraId:69,tocIndex:13},{value:"false",paraId:69,tocIndex:13},{value:"。",paraId:69,tocIndex:13},{value:"开启 isBillboard 后，在透视投影下，是否进行尺寸衰减。在透视投影中遵循“近大远小”的视觉效果，如果希望保持大小始终一致不受深度影响，可以开启该选项。",paraId:70,tocIndex:14},{value:"获取路径长度。",paraId:71,tocIndex:16},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/SVGGeometryElement/getTotalLength",paraId:72,tocIndex:16},{value:"例如获取如下直线的长度：",paraId:73,tocIndex:16},{value:"const path = new Path({\n    style: {\n        path: [\n            ['M', 100, 100],\n            ['L', 100, 200],\n        ],\n        stroke: '#F04864',\n    },\n});\n\npath.getTotalLength(); // 100\n",paraId:74,tocIndex:16},{value:"如果是一个不合法的路径，返回 0：",paraId:75,tocIndex:16},{value:"const path = new Path({\n    style: {\n        path: [['XXXX', 100, 100]],\n        stroke: '#F04864',\n    },\n});\n\npath.getTotalLength(); // 0\n",paraId:76,tocIndex:16},{value:"根据长度比例（取值范围 ",paraId:77,tocIndex:17},{value:"[0-1]",paraId:77,tocIndex:17},{value:"）获取局部或世界坐标系下点的坐标。",paraId:77,tocIndex:17},{value:"参数如下：",paraId:78,tocIndex:17},{value:"ratio",paraId:79,tocIndex:17},{value:" 必填，长度比例",paraId:79,tocIndex:17},{value:"inWorldSpace",paraId:79,tocIndex:17},{value:" 可选，表示是否在世界坐标系下计算。默认值为 ",paraId:79,tocIndex:17},{value:"false",paraId:79,tocIndex:17},{value:"其中 ",paraId:80,tocIndex:17},{value:"Point",paraId:80,tocIndex:17},{value:" 的格式为:",paraId:80,tocIndex:17},{value:"export type Point = {\n    x: number;\n    y: number;\n};\n",paraId:81,tocIndex:17},{value:"例如获取如下直线的中点坐标：",paraId:82,tocIndex:17},{value:"const path = new Path({\n    style: {\n        path: [\n            ['M', 100, 100],\n            ['L', 100, 200],\n        ],\n        stroke: '#F04864',\n    },\n});\n\npath.getPoint(0.5); // Point {x: 100, y: 150}\n",paraId:83,tocIndex:17},{value:"值得注意的是，如果超出取值范围 ",paraId:84,tocIndex:17},{value:"[0-1]",paraId:84,tocIndex:17},{value:"，会返回路径头尾的点坐标。对于非法路径，该方法会返回 ",paraId:84,tocIndex:17},{value:"Point {x: NaN, y: NaN}",paraId:84,tocIndex:17},{value:"另外在原路径上应用的，在局部坐标系下的变换也会应用到返回的点上。例如在该",paraId:85,tocIndex:17},{value:"示例",paraId:86,tocIndex:17},{value:"中，路径本身经过了平移和缩放：",paraId:85,tocIndex:17},{value:"沿路径返回给定距离的点。",paraId:87,tocIndex:18},{value:"参数如下：",paraId:88,tocIndex:18},{value:"distance",paraId:89,tocIndex:18},{value:" 必填，从起点出发的距离值",paraId:89,tocIndex:18},{value:"inWorldSpace",paraId:89,tocIndex:18},{value:" 可选，表示是否在世界坐标系下计算。默认值为 ",paraId:89,tocIndex:18},{value:"false",paraId:89,tocIndex:18},{value:"https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getPointAtLength",paraId:90,tocIndex:18},{value:"path.getPointAtLength(100); // Point {x: 300, y: 100}\n",paraId:91,tocIndex:18},{value:"获取起点的切向量 ",paraId:92,tocIndex:19},{value:"number[][]",paraId:92,tocIndex:19},{value:"，形如: ",paraId:92,tocIndex:19},{value:"[[10, 10], [20, 20]]",paraId:92,tocIndex:19},{value:"获取终点的切向量 ",paraId:93,tocIndex:20},{value:"number[][]",paraId:93,tocIndex:20},{value:"，形如: ",paraId:93,tocIndex:20},{value:"[[10, 10], [20, 20]]",paraId:93,tocIndex:20}]},97194:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(24958);const d=[{value:"可以参考 SVG 的 ",paraId:0},{value:"<polygon>",paraId:0},{value:" 元素。",paraId:0},{value:"如下 ",paraId:1},{value:"示例",paraId:2},{value:" 定义了一个多边形：",paraId:1},{value:"const polygon = new Polygon({\n    style: {\n        points: [\n            [0, 0],\n            [100, 0],\n            [100, 100],\n            [0, 100],\n        ],\n        stroke: '#1890FF',\n        lineWidth: 2,\n    },\n});\n",paraId:3},{value:"继承了 ",paraId:4,tocIndex:0},{value:"DisplayObject",paraId:5,tocIndex:0},{value:" 的 ",paraId:4,tocIndex:0},{value:"样式属性",paraId:6,tocIndex:0},{value:"。",paraId:4,tocIndex:0},{value:"默认值为 ",paraId:7,tocIndex:1},{value:"[0, 0]",paraId:7,tocIndex:1},{value:"。详见 ",paraId:7,tocIndex:1},{value:"DisplayObject anchor",paraId:8,tocIndex:1},{value:"默认值为 ",paraId:9,tocIndex:2},{value:"left top",paraId:9,tocIndex:2},{value:"。详见 ",paraId:9,tocIndex:2},{value:"DisplayObject transformOrigin",paraId:10,tocIndex:2},{value:"默认值为 ",paraId:11,tocIndex:3},{value:"'1'",paraId:11,tocIndex:3},{value:"。详见 ",paraId:11,tocIndex:3},{value:"DisplayObject lineWidth",paraId:12,tocIndex:3},{value:"默认值 ",paraId:13,tocIndex:4},{value:"4",paraId:13,tocIndex:4},{value:"。详见 ",paraId:13,tocIndex:4},{value:"DisplayObject miterLimit",paraId:14,tocIndex:4},{value:"支持以下两种写法：",paraId:15,tocIndex:6},{value:"[number, number][]",paraId:16,tocIndex:6},{value:" 点数组",paraId:16,tocIndex:6},{value:"string",paraId:16,tocIndex:6},{value:" 点之间使用空格分隔，形如：",paraId:16,tocIndex:6},{value:"'100,10 250,150 200,110'",paraId:16,tocIndex:6},{value:"因此以下两种写法等价：",paraId:17,tocIndex:6},{value:"polygon.style.points = '100,10 250,150 200,110';\npolygon.style.points = [\n    [100, 10],\n    [250, 150],\n    [200, 110],\n];\n",paraId:18,tocIndex:6},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/points",paraId:19,tocIndex:6},{value:"可以参考 ",paraId:20,tocIndex:7},{value:"Polyline",paraId:21,tocIndex:7},{value:" 的 ",paraId:20,tocIndex:7},{value:"markerStart",paraId:22,tocIndex:7},{value:" 属性。",paraId:20,tocIndex:7},{value:"但和 Polyline 不同的是，由于多边形是",paraId:23,tocIndex:7},{value:"闭合",paraId:23,tocIndex:7},{value:"的，因此 “起始点” 和 “终止点” 的位置是完全重合的，由 ",paraId:23,tocIndex:7},{value:"points",paraId:24,tocIndex:7},{value:" 中的第一个点决定。这也与 SVG 原生实现保持一致，下图展示了同时定义 markerStart 和 markerEnd 后的重合效果：",paraId:23,tocIndex:7},{value:"在该",paraId:25,tocIndex:7},{value:"示例",paraId:26,tocIndex:7},{value:"中，我们在多边形的“起始点”上放置了一个箭头：",paraId:25,tocIndex:7},{value:"const arrowMarker = new Path({\n    style: {\n        path: 'M 10,10 L -10,0 L 10,-10 Z',\n        stroke: '#1890FF',\n        anchor: '0.5 0.5',\n        transformOrigin: 'center',\n    },\n});\n\npolygon.style.markerStart = arrowMarker;\n",paraId:27,tocIndex:7},{value:"可以参考 ",paraId:28,tocIndex:8},{value:"Polyline",paraId:29,tocIndex:8},{value:" 的 ",paraId:28,tocIndex:8},{value:"markerEnd",paraId:30,tocIndex:8},{value:" 属性。",paraId:28,tocIndex:8},{value:"但和 Polyline 不同的是，由于多边形是",paraId:31,tocIndex:8},{value:"闭合",paraId:31,tocIndex:8},{value:"的，因此 “起始点” 和 “终止点” 的位置是完全重合的。“终止点” 由 ",paraId:31,tocIndex:8},{value:"points",paraId:32,tocIndex:8},{value:" 中的第一个点决定。",paraId:31,tocIndex:8},{value:"在该",paraId:33,tocIndex:8},{value:"示例",paraId:34,tocIndex:8},{value:"中，我们在多边形的终止点上放置了一个图片：",paraId:33,tocIndex:8},{value:"const imageMarker = new Image({\n    style: {\n        width: 50,\n        height: 50,\n        anchor: [0.5, 0.5],\n        transformOrigin: 'center',\n        transform: 'rotate(90deg)',\n        src: 'https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*N4ZMS7gHsUIAAAAAAAAAAABkARQnAQ',\n    },\n});\n\npolygon.style.markerEnd = imageMarker;\n",paraId:35,tocIndex:8},{value:"可以参考 SVG 的",paraId:36,tocIndex:9},{value:"同名属性",paraId:36,tocIndex:9},{value:"。",paraId:36,tocIndex:9},{value:"在多边形除了 “起始点” / “终止点” 之外的每一个顶点上放置标记图形。",paraId:37,tocIndex:9},{value:"例如下图中在多边形上除首尾的每个顶点上都放置了一个 ",paraId:38,tocIndex:9},{value:"Circle",paraId:39,tocIndex:9},{value:"：",paraId:38,tocIndex:9},{value:"const circleMarker = new Circle({\n    style: {\n        r: 10,\n        stroke: '#1890FF',\n    },\n});\n\npolygon.style.markerMid = circleMarker;\n",paraId:40,tocIndex:9},{value:"可以参考 ",paraId:41,tocIndex:10},{value:"Polyline",paraId:42,tocIndex:10},{value:" 的 ",paraId:41,tocIndex:10},{value:"markerStartOffset",paraId:43,tocIndex:10},{value:" 属性。",paraId:41,tocIndex:10},{value:"沿多边形的第一个线段方向移动标记图形，同时会改变原始多边形的形状。",paraId:44,tocIndex:10},{value:"初始值",paraId:45,tocIndex:10},{value:"适用元素",paraId:46,tocIndex:10},{value:"是否可继承",paraId:47,tocIndex:10},{value:"是否支持动画",paraId:46,tocIndex:10},{value:"计算值",paraId:48,tocIndex:10},{value:"'0'",paraId:46,tocIndex:10},{value:"-",paraId:46,tocIndex:10},{value:"否",paraId:46,tocIndex:10},{value:"是",paraId:46,tocIndex:10},{value:"<length>",paraId:49,tocIndex:10},{value:"可以参考 ",paraId:50,tocIndex:11},{value:"Polyline",paraId:51,tocIndex:11},{value:" 的 ",paraId:50,tocIndex:11},{value:"markerEndOffset",paraId:52,tocIndex:11},{value:" 属性。",paraId:50,tocIndex:11},{value:"初始值",paraId:53,tocIndex:11},{value:"适用元素",paraId:54,tocIndex:11},{value:"是否可继承",paraId:55,tocIndex:11},{value:"是否支持动画",paraId:54,tocIndex:11},{value:"计算值",paraId:56,tocIndex:11},{value:"'0'",paraId:54,tocIndex:11},{value:"-",paraId:54,tocIndex:11},{value:"否",paraId:54,tocIndex:11},{value:"是",paraId:54,tocIndex:11},{value:"<length>",paraId:57,tocIndex:11}]},6018:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(90651);const d=[{value:"可以参考 SVG 的 ",paraId:0},{value:"<polyline>",paraId:0},{value:" 元素。",paraId:0},{value:"如下 ",paraId:1},{value:"示例",paraId:2},{value:" 定义了一条折线，各个端点依次为：",paraId:1},{value:"const polyline = new Polyline({\n    style: {\n        points: [\n            [50, 50],\n            [100, 50],\n            [100, 100],\n            [150, 100],\n            [150, 150],\n            [200, 150],\n            [200, 200],\n            [250, 200],\n            [250, 250],\n            [300, 250],\n            [300, 300],\n            [350, 300],\n            [350, 350],\n            [400, 350],\n            [400, 400],\n            [450, 400],\n        ],\n        stroke: '#1890FF',\n        lineWidth: 2,\n    },\n});\n",paraId:3},{value:"对于折线，默认锚点定义的位置为包围盒左上角顶点，其中各个端点坐标均定义在局部坐标系下。因此如果此时获取上面折线在局部坐标系的坐标，会得到包围盒左上角的坐标，也恰巧是第一个顶点的坐标，即 ",paraId:4},{value:"[50, 50]",paraId:4},{value:"：",paraId:4},{value:"polyline.getLocalPosition(); // [50, 50]\n",paraId:5},{value:"继承了 ",paraId:6,tocIndex:0},{value:"DisplayObject",paraId:7,tocIndex:0},{value:" 的 ",paraId:6,tocIndex:0},{value:"样式属性",paraId:8,tocIndex:0},{value:"。",paraId:6,tocIndex:0},{value:"默认值为 ",paraId:9,tocIndex:1},{value:"[0, 0]",paraId:9,tocIndex:1},{value:"。详见 ",paraId:9,tocIndex:1},{value:"DisplayObject anchor",paraId:10,tocIndex:1},{value:"默认值为 ",paraId:11,tocIndex:2},{value:"left top",paraId:11,tocIndex:2},{value:"。详见 ",paraId:11,tocIndex:2},{value:"DisplayObject transformOrigin",paraId:12,tocIndex:2},{value:"默认值为 ",paraId:13,tocIndex:3},{value:"'1'",paraId:13,tocIndex:3},{value:"。详见 ",paraId:13,tocIndex:3},{value:"DisplayObject lineWidth",paraId:14,tocIndex:3},{value:"默认值 ",paraId:15,tocIndex:4},{value:"4",paraId:15,tocIndex:4},{value:"。详见 ",paraId:15,tocIndex:4},{value:"DisplayObject miterLimit",paraId:16,tocIndex:4},{value:"支持以下两种写法：",paraId:17,tocIndex:6},{value:"[number, number][]",paraId:18,tocIndex:6},{value:" 点数组",paraId:18,tocIndex:6},{value:"string",paraId:18,tocIndex:6},{value:" 点之间使用空格分隔，形如：",paraId:18,tocIndex:6},{value:"'100,10 250,150 200,110'",paraId:18,tocIndex:6},{value:"因此以下两种写法等价：",paraId:19,tocIndex:6},{value:"polyline.style.points = '100,10 250,150 200,110';\npolyline.style.points = [\n    [100, 10],\n    [250, 150],\n    [200, 110],\n];\n",paraId:20,tocIndex:6},{value:"可以参考 SVG 的",paraId:21,tocIndex:6},{value:"同名属性",paraId:21,tocIndex:6},{value:"。",paraId:21,tocIndex:6},{value:"可以参考 ",paraId:22,tocIndex:7},{value:"Line",paraId:23,tocIndex:7},{value:" 的 ",paraId:22,tocIndex:7},{value:"markerStart",paraId:24,tocIndex:7},{value:" 属性。",paraId:22,tocIndex:7},{value:"“起始点” 由 ",paraId:25,tocIndex:7},{value:"points",paraId:26,tocIndex:7},{value:" 中的第一个点决定。",paraId:25,tocIndex:7},{value:"在该",paraId:27,tocIndex:7},{value:"示例",paraId:28,tocIndex:7},{value:"中，我们在折线的起始点上放置了一个箭头：",paraId:27,tocIndex:7},{value:"const arrowMarker = new Path({\n    style: {\n        path: 'M 10,10 L -10,0 L 10,-10 Z',\n        stroke: '#1890FF',\n        anchor: '0.5 0.5',\n        transformOrigin: 'center',\n    },\n});\n\npolyline.style.markerStart = arrowMarker;\n",paraId:29,tocIndex:7},{value:"可以参考 ",paraId:30,tocIndex:8},{value:"Line",paraId:31,tocIndex:8},{value:" 的 ",paraId:30,tocIndex:8},{value:"markerEnd",paraId:32,tocIndex:8},{value:" 属性。",paraId:30,tocIndex:8},{value:"“终止点” 由 ",paraId:33,tocIndex:8},{value:"points",paraId:34,tocIndex:8},{value:" 中的最后一个点决定。",paraId:33,tocIndex:8},{value:"在该",paraId:35,tocIndex:8},{value:"示例",paraId:36,tocIndex:8},{value:"中，我们在折线的终止点上放置了一个图片：",paraId:35,tocIndex:8},{value:"const imageMarker = new Image({\n    style: {\n        width: 50,\n        height: 50,\n        anchor: [0.5, 0.5],\n        transformOrigin: 'center',\n        transform: 'rotate(90deg)',\n        src: 'https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*N4ZMS7gHsUIAAAAAAAAAAABkARQnAQ',\n    },\n});\n\npolyline.style.markerEnd = imageMarker;\n",paraId:37,tocIndex:8},{value:"可以参考 SVG 的",paraId:38,tocIndex:9},{value:"同名属性",paraId:38,tocIndex:9},{value:"。",paraId:38,tocIndex:9},{value:"在折线除了 “起始点” 和 “终止点” 之外的每一个顶点上放置标记图形。",paraId:39,tocIndex:9},{value:"例如下图中在折线上除首尾的每个顶点上都放置了一个 ",paraId:40,tocIndex:9},{value:"Circle",paraId:41,tocIndex:9},{value:"：",paraId:40,tocIndex:9},{value:"const circleMarker = new Circle({\n    style: {\n        r: 10,\n        stroke: '#1890FF',\n    },\n});\n\npolyline.style.markerMid = circleMarker;\n",paraId:42,tocIndex:9},{value:"可以参考 ",paraId:43,tocIndex:10},{value:"Line",paraId:44,tocIndex:10},{value:" 的 ",paraId:43,tocIndex:10},{value:"markerStartOffset",paraId:45,tocIndex:10},{value:" 属性。",paraId:43,tocIndex:10},{value:"沿折线的第一个线段方向移动标记图形。需要注意的是，如果偏移距离超过了原始线段的长度，会向反方向延伸：",paraId:46,tocIndex:10},{value:"初始值",paraId:47,tocIndex:10},{value:"适用元素",paraId:48,tocIndex:10},{value:"是否可继承",paraId:49,tocIndex:10},{value:"是否支持动画",paraId:48,tocIndex:10},{value:"计算值",paraId:50,tocIndex:10},{value:"'0'",paraId:48,tocIndex:10},{value:"-",paraId:48,tocIndex:10},{value:"否",paraId:48,tocIndex:10},{value:"是",paraId:48,tocIndex:10},{value:"<length>",paraId:51,tocIndex:10},{value:"可以参考 ",paraId:52,tocIndex:11},{value:"Line",paraId:53,tocIndex:11},{value:" 的 ",paraId:52,tocIndex:11},{value:"markerEndOffset",paraId:54,tocIndex:11},{value:" 属性。",paraId:52,tocIndex:11},{value:"沿折线的最后一个线段方向移动标记图形。需要注意的是，如果偏移距离超过了原始线段的长度，会向反方向延伸。在该",paraId:55,tocIndex:11},{value:"示例",paraId:56,tocIndex:11},{value:"中，我们使用该属性移动标记图形：",paraId:55,tocIndex:11},{value:"初始值",paraId:57,tocIndex:11},{value:"适用元素",paraId:58,tocIndex:11},{value:"是否可继承",paraId:59,tocIndex:11},{value:"是否支持动画",paraId:58,tocIndex:11},{value:"计算值",paraId:60,tocIndex:11},{value:"'0'",paraId:58,tocIndex:11},{value:"-",paraId:58,tocIndex:11},{value:"否",paraId:58,tocIndex:11},{value:"是",paraId:58,tocIndex:11},{value:"<length>",paraId:61,tocIndex:11},{value:"3D 场景中生效，始终朝向屏幕，因此线宽不受透视投影影像。默认值为 ",paraId:62,tocIndex:12},{value:"false",paraId:62,tocIndex:12},{value:"。",paraId:62,tocIndex:12},{value:"获取折线长度。",paraId:63,tocIndex:14},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/SVGGeometryElement/getTotalLength",paraId:64,tocIndex:14},{value:"根据长度比例（取值范围 ",paraId:65,tocIndex:15},{value:"[0-1]",paraId:65,tocIndex:15},{value:"）获取点。",paraId:65,tocIndex:15},{value:"参数如下：",paraId:66,tocIndex:15},{value:"ratio",paraId:67,tocIndex:15},{value:" 必填，长度比例",paraId:67,tocIndex:15},{value:"inWorldSpace",paraId:67,tocIndex:15},{value:" 可选，表示是否在世界坐标系下计算。默认值为 ",paraId:67,tocIndex:15},{value:"false",paraId:67,tocIndex:15},{value:"其中 ",paraId:68,tocIndex:15},{value:"Point",paraId:68,tocIndex:15},{value:" 的格式为:",paraId:68,tocIndex:15},{value:"export type Point = {\n    x: number;\n    y: number;\n};\n",paraId:69,tocIndex:15},{value:"沿路径返回给定距离的点。",paraId:70,tocIndex:16},{value:"参数如下：",paraId:71,tocIndex:16},{value:"distance",paraId:72,tocIndex:16},{value:" 必填，从起点出发的距离值",paraId:72,tocIndex:16},{value:"inWorldSpace",paraId:72,tocIndex:16},{value:" 可选，表示是否在世界坐标系下计算。默认值为 ",paraId:72,tocIndex:16},{value:"false",paraId:72,tocIndex:16},{value:"https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getPointAtLength",paraId:73,tocIndex:16},{value:"polyline.getPointAtLength(100); // Point {x: 300, y: 100}\n",paraId:74,tocIndex:16},{value:"获取起点的切向量，形如: ",paraId:75,tocIndex:17},{value:"[[10, 10], [20, 20]]",paraId:75,tocIndex:17},{value:"获取终点的切向量，形如: ",paraId:76,tocIndex:18},{value:"[[10, 10], [20, 20]]",paraId:76,tocIndex:18},{value:"和 Line 一样，折线也可以定义在三维空间：",paraId:77,tocIndex:19},{value:"const polyline = new Polyline({\n    style: {\n        stroke: '#1890FF',\n        lineWidth: 10,\n        lineCap: 'round',\n        lineJoin: 'round',\n        points: [\n            [50, 50, 0],\n            [100, 50, 100],\n            [100, 100, 0],\n            [150, 100, 100],\n            [150, 150, 0],\n            [200, 150, 0],\n            [200, 200, 0],\n            [250, 200, 0],\n        ],\n    },\n});\n",paraId:78,tocIndex:19},{value:"效果如下：",paraId:79,tocIndex:19},{value:"但如果应用了公告牌效果，3D 效果将消失",paraId:80,tocIndex:19},{value:"示例",paraId:81,tocIndex:19},{value:"。",paraId:80,tocIndex:19}]},48953:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(96838);const d=[{value:"可以参考 SVG 的 ",paraId:0},{value:"<rect>",paraId:0},{value:" 元素。",paraId:0},{value:"如下 ",paraId:1},{value:"示例",paraId:2},{value:" 定义了一个圆角矩形，左上角顶点位置为 ",paraId:1},{value:"(200, 100)",paraId:1},{value:"：",paraId:1},{value:"const rect = new Rect({\n    style: {\n        x: 200,\n        y: 100,\n        width: 300,\n        height: 200,\n        fill: '#1890FF',\n        stroke: '#F04864',\n        lineWidth: 4,\n        radius: 8,\n    },\n});\n",paraId:3},{value:"继承了 ",paraId:4,tocIndex:0},{value:"DisplayObject",paraId:5,tocIndex:0},{value:" 的 ",paraId:4,tocIndex:0},{value:"样式属性",paraId:6,tocIndex:0},{value:"。",paraId:4,tocIndex:0},{value:"默认值为 ",paraId:7,tocIndex:1},{value:"[0, 0]",paraId:7,tocIndex:1},{value:"。详见 ",paraId:7,tocIndex:1},{value:"DisplayObject anchor",paraId:8,tocIndex:1},{value:"默认值为 ",paraId:9,tocIndex:2},{value:"left top",paraId:9,tocIndex:2},{value:"。详见 ",paraId:9,tocIndex:2},{value:"DisplayObject transformOrigin",paraId:10,tocIndex:2},{value:"局部坐标系下，矩形左上角顶点的 x 轴坐标。",paraId:11,tocIndex:4},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/x",paraId:12,tocIndex:4},{value:"初始值",paraId:13,tocIndex:4},{value:"适用元素",paraId:14,tocIndex:4},{value:"是否可继承",paraId:15,tocIndex:4},{value:"是否支持动画",paraId:14,tocIndex:4},{value:"计算值",paraId:16,tocIndex:4},{value:"'0'",paraId:14,tocIndex:4},{value:"-",paraId:14,tocIndex:4},{value:"否",paraId:14,tocIndex:4},{value:"是",paraId:14,tocIndex:4},{value:"<percentage>",paraId:17,tocIndex:4},{value:" ",paraId:14,tocIndex:4},{value:"<length>",paraId:18,tocIndex:4},{value:"局部坐标系下，矩形左上角顶点的 y 轴坐标。",paraId:19,tocIndex:5},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/y",paraId:20,tocIndex:5},{value:"初始值",paraId:21,tocIndex:5},{value:"适用元素",paraId:22,tocIndex:5},{value:"是否可继承",paraId:23,tocIndex:5},{value:"是否支持动画",paraId:22,tocIndex:5},{value:"计算值",paraId:24,tocIndex:5},{value:"'0'",paraId:22,tocIndex:5},{value:"-",paraId:22,tocIndex:5},{value:"否",paraId:22,tocIndex:5},{value:"是",paraId:22,tocIndex:5},{value:"<percentage>",paraId:25,tocIndex:5},{value:" ",paraId:22,tocIndex:5},{value:"<length>",paraId:26,tocIndex:5},{value:"矩形宽度。支持取",paraId:27,tocIndex:6},{value:"负数",paraId:27,tocIndex:6},{value:"，效果为沿 Y 轴反转，",paraId:27,tocIndex:6},{value:"示例",paraId:28,tocIndex:6},{value:"：",paraId:27,tocIndex:6},{value:"这与 Canvas2D API 保持一致，",paraId:29,tocIndex:6},{value:"详见",paraId:29,tocIndex:6},{value:"。在 SVG 规范中指出 ",paraId:29,tocIndex:6},{value:"<rect>",paraId:29,tocIndex:6},{value:" 宽高属性取负数时不予展示，例如在 Chrome 中这么做会报如下错误 ",paraId:29,tocIndex:6},{value:'Error: <rect> attribute height: A negative value is not valid. ("-100")',paraId:29,tocIndex:6},{value:"：",paraId:29,tocIndex:6},{value:"The width and height properties define the overall width and height of the rectangle. A negative value for either property is illegal and must be ignored as a parsing error. A computed value of zero for either dimension disables rendering of the element.",paraId:30,tocIndex:6},{value:"我们在 ",paraId:31,tocIndex:6},{value:"g-svg",paraId:32,tocIndex:6},{value:" 中使用 ",paraId:31,tocIndex:6},{value:"<path>",paraId:31,tocIndex:6},{value:" 代替 ",paraId:31,tocIndex:6},{value:"<rect>",paraId:31,tocIndex:6},{value:" 绘制规避了这个问题。",paraId:31,tocIndex:6},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/width",paraId:33,tocIndex:6},{value:"初始值",paraId:34,tocIndex:6},{value:"适用元素",paraId:35,tocIndex:6},{value:"是否可继承",paraId:36,tocIndex:6},{value:"是否支持动画",paraId:35,tocIndex:6},{value:"计算值",paraId:37,tocIndex:6},{value:"'0'",paraId:35,tocIndex:6},{value:"-",paraId:35,tocIndex:6},{value:"否",paraId:35,tocIndex:6},{value:"是",paraId:35,tocIndex:6},{value:"<percentage>",paraId:38,tocIndex:6},{value:" ",paraId:35,tocIndex:6},{value:"<length>",paraId:39,tocIndex:6},{value:"矩形高度。支持取",paraId:40,tocIndex:7},{value:"负数",paraId:40,tocIndex:7},{value:"，效果为沿 X 轴反转，",paraId:40,tocIndex:7},{value:"示例",paraId:41,tocIndex:7},{value:"：",paraId:40,tocIndex:7},{value:"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/height",paraId:42,tocIndex:7},{value:"初始值",paraId:43,tocIndex:7},{value:"适用元素",paraId:44,tocIndex:7},{value:"是否可继承",paraId:45,tocIndex:7},{value:"是否支持动画",paraId:44,tocIndex:7},{value:"计算值",paraId:46,tocIndex:7},{value:"'0'",paraId:44,tocIndex:7},{value:"-",paraId:44,tocIndex:7},{value:"否",paraId:44,tocIndex:7},{value:"是",paraId:44,tocIndex:7},{value:"<percentage>",paraId:47,tocIndex:7},{value:" ",paraId:44,tocIndex:7},{value:"<length>",paraId:48,tocIndex:7},{value:"圆角半径，不同于 SVG ",paraId:49,tocIndex:8},{value:"<rect>",paraId:49,tocIndex:8},{value:" 仅支持 ",paraId:49,tocIndex:8},{value:"cx/cy",paraId:49,tocIndex:8},{value:" 统一设置，这里可以分别指定四个角的圆角半径，",paraId:49,tocIndex:8},{value:"示例",paraId:50,tocIndex:8},{value:"：",paraId:49,tocIndex:8},{value:"rect.style.radius = [0, 4, 8, 16];\nrect.style.radius = '0 4px 8px 16px';\n",paraId:51,tocIndex:8},{value:"支持以下取值，设置顺序依次为 左上，右上，右下，左下：",paraId:52,tocIndex:8},{value:"number",paraId:53,tocIndex:8},{value:" 统一设置四个圆角半径",paraId:53,tocIndex:8},{value:"number[]",paraId:53,tocIndex:8},{value:" 分别设置四个圆角半径，会补足缺省的分量：\n",paraId:53,tocIndex:8},{value:"[ 1 ]",paraId:54,tocIndex:8},{value:" 相当于 ",paraId:54,tocIndex:8},{value:"[ 1, 1, 1, 1 ]",paraId:54,tocIndex:8},{value:"[ 1, 2 ]",paraId:54,tocIndex:8},{value:" 相当于 ",paraId:54,tocIndex:8},{value:"[ 1, 2, 1, 2 ]",paraId:54,tocIndex:8},{value:"[ 1, 2, 3 ]",paraId:54,tocIndex:8},{value:" 相当于 ",paraId:54,tocIndex:8},{value:"[ 1, 2, 3, 2 ]",paraId:54,tocIndex:8},{value:"[ 1, 2, 3, 4 ]",paraId:54,tocIndex:8},{value:"string",paraId:53,tocIndex:8},{value:" 与 CSS ",paraId:53,tocIndex:8},{value:"padding",paraId:53,tocIndex:8},{value:" 属性类似，使用空格分隔",paraId:53,tocIndex:8},{value:"在实际绘制时，会限制圆角半径的最大值为矩形宽高最大值的一半：",paraId:55,tocIndex:8},{value:"const [tlr, trr, brr, blr] = radius.map((r) =>\n    clamp(\n        r.value,\n        0,\n        Math.min(Math.abs(width.value) / 2, Math.abs(height.value) / 2),\n    ),\n);\n",paraId:56,tocIndex:8},{value:"初始值",paraId:57,tocIndex:8},{value:"适用元素",paraId:58,tocIndex:8},{value:"是否可继承",paraId:59,tocIndex:8},{value:"是否支持动画",paraId:58,tocIndex:8},{value:"计算值",paraId:60,tocIndex:8},{value:"'0'",paraId:58,tocIndex:8},{value:"-",paraId:58,tocIndex:8},{value:"否",paraId:58,tocIndex:8},{value:"是",paraId:58,tocIndex:8},{value:"(",paraId:58,tocIndex:8},{value:"<percentage>",paraId:61,tocIndex:8},{value:" ",paraId:58,tocIndex:8},{value:"<length>",paraId:62,tocIndex:8},{value:") {1, 4}",paraId:58,tocIndex:8}]},79077:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(37163);const d=[{value:"提供简单的单行/多行文本排版能力，单行支持水平对齐、字符间距；多行支持显式换行符以及自动换行，垂直对齐。",paraId:0},{value:"可以在该 ",paraId:1},{value:"示例",paraId:2},{value:" 中调整以下属性。",paraId:1},{value:"DisplayObject",paraId:3,tocIndex:0},{value:"文本/文本块的位置通过文本锚点描述，围绕该锚点通过 ",paraId:4,tocIndex:0},{value:"textBaseline",paraId:4,tocIndex:0},{value:"（单行/多行）、",paraId:4,tocIndex:0},{value:"textAlign",paraId:4,tocIndex:0},{value:"（多行）等属性调整自身位置。",paraId:4,tocIndex:0},{value:"必填项，文本内容，可以包含换行符，例如 ",paraId:5,tocIndex:1},{value:'"测试文本\\n另起一行"',paraId:5,tocIndex:1},{value:"初始值",paraId:6,tocIndex:1},{value:"适用元素",paraId:7,tocIndex:1},{value:"是否可继承",paraId:8,tocIndex:1},{value:"是否支持动画",paraId:7,tocIndex:1},{value:"计算值",paraId:9,tocIndex:1},{value:"''",paraId:7,tocIndex:1},{value:"-",paraId:7,tocIndex:1},{value:"否",paraId:7,tocIndex:1},{value:"否",paraId:7,tocIndex:1},{value:"<string>",paraId:10,tocIndex:1},{value:"与 ",paraId:11,tocIndex:2},{value:"CSS text-transform",paraId:11,tocIndex:2},{value:" 一致，对文本内容进行转换，仅影响视觉效果，原始文本内容不变，支持以下枚举值：",paraId:11,tocIndex:2},{value:"'capitalize'",paraId:12,tocIndex:2},{value:" 首字母大写",paraId:12,tocIndex:2},{value:"'uppercase'",paraId:12,tocIndex:2},{value:" 全大写",paraId:12,tocIndex:2},{value:"'lowercase'",paraId:12,tocIndex:2},{value:" 全小写",paraId:12,tocIndex:2},{value:"'none'",paraId:12,tocIndex:2},{value:" 不做转换，默认值",paraId:12,tocIndex:2},{value:"初始值",paraId:13,tocIndex:2},{value:"适用元素",paraId:14,tocIndex:2},{value:"是否可继承",paraId:15,tocIndex:2},{value:"是否支持动画",paraId:14,tocIndex:2},{value:"计算值",paraId:16,tocIndex:2},{value:"'none'",paraId:14,tocIndex:2},{value:"-",paraId:14,tocIndex:2},{value:"否",paraId:14,tocIndex:2},{value:"否",paraId:14,tocIndex:2},{value:"<keywords>",paraId:17,tocIndex:2},{value:"与 ",paraId:18,tocIndex:3},{value:"SVG dx / dy 属性",paraId:18,tocIndex:3},{value:"对应，在水平和垂直方向增加偏移量",paraId:18,tocIndex:3},{value:"支持 ",paraId:19,tocIndex:3},{value:"px",paraId:19,tocIndex:3},{value:" 和 ",paraId:19,tocIndex:3},{value:"em",paraId:19,tocIndex:3},{value:" 两种单位，使用 ",paraId:19,tocIndex:3},{value:"number",paraId:19,tocIndex:3},{value:" 类型时默认 ",paraId:19,tocIndex:3},{value:"px",paraId:19,tocIndex:3},{value:" 单位：",paraId:19,tocIndex:3},{value:"{\n    dx: 10;\n    dx: '10px';\n    dx: '0.5em';\n}\n",paraId:20,tocIndex:3},{value:"初始值",paraId:21,tocIndex:3},{value:"适用元素",paraId:22,tocIndex:3},{value:"是否可继承",paraId:23,tocIndex:3},{value:"是否支持动画",paraId:22,tocIndex:3},{value:"计算值",paraId:24,tocIndex:3},{value:"'0'",paraId:22,tocIndex:3},{value:"-",paraId:22,tocIndex:3},{value:"否",paraId:22,tocIndex:3},{value:"是",paraId:22,tocIndex:3},{value:"<percentage>",paraId:25,tocIndex:3},{value:" ",paraId:22,tocIndex:3},{value:"<length>",paraId:26,tocIndex:3},{value:"在 3D 场景下是否永远面朝相机，默认为 ",paraId:27,tocIndex:4},{value:"false",paraId:27,tocIndex:4},{value:"，也称作“公告牌效果”。",paraId:27,tocIndex:4},{value:"在",paraId:28,tocIndex:4},{value:"示例",paraId:29,tocIndex:4},{value:"中，未开启情况下在相机发生旋转时，文本会呈现被压缩的效果：",paraId:28,tocIndex:4},{value:"开启后并不会改变文本的位置，但它会始终面朝相机。这也符合通常 3D 场景下对于文本这类 2D 图形的需求：",paraId:30,tocIndex:4},{value:"公告牌模式下的旋转角度，顺时针方向以 radians 为单位。",paraId:31,tocIndex:5},{value:"在",paraId:32,tocIndex:5},{value:"示例",paraId:33,tocIndex:5},{value:"中，我们为文本增加一个旋转角度：",paraId:32,tocIndex:5},{value:"label.style.isBillboard = true;\nlabel.style.billboardRotation = Math.PI / 8;\n",paraId:34,tocIndex:5},{value:"在透视投影下，是否进行尺寸衰减。在透视投影中遵循“近大远小”的视觉效果，如果希望保持大小始终一致不受深度影响，可以开启该选项。",paraId:35,tocIndex:6},{value:"在",paraId:36,tocIndex:6},{value:"示例",paraId:37,tocIndex:6},{value:"中，我们为文本开启了尺寸衰减：",paraId:36,tocIndex:6},{value:"label.style.isSizeAttenuation = true;\n",paraId:38,tocIndex:6},{value:"字体类型，例如 ",paraId:39,tocIndex:8},{value:"'PingFang SC'",paraId:39,tocIndex:8},{value:" ",paraId:39,tocIndex:8},{value:"'Microsoft Yahei'",paraId:39,tocIndex:8},{value:"。",paraId:39,tocIndex:8},{value:"与 ",paraId:40,tocIndex:8},{value:"CSS font-family",paraId:40,tocIndex:8},{value:" 一致。",paraId:40,tocIndex:8},{value:"初始值",paraId:41,tocIndex:8},{value:"适用元素",paraId:42,tocIndex:8},{value:"是否可继承",paraId:43,tocIndex:8},{value:"是否支持动画",paraId:42,tocIndex:8},{value:"计算值",paraId:44,tocIndex:8},{value:"''",paraId:42,tocIndex:8},{value:"-",paraId:42,tocIndex:8},{value:"是",paraId:42,tocIndex:8},{value:"否",paraId:42,tocIndex:8},{value:"<keywords>",paraId:45,tocIndex:8},{value:"字体大小。",paraId:46,tocIndex:9},{value:"与 ",paraId:47,tocIndex:9},{value:"CSS font-size",paraId:47,tocIndex:9},{value:" 一致。",paraId:47,tocIndex:9},{value:"初始值",paraId:48,tocIndex:9},{value:"适用元素",paraId:49,tocIndex:9},{value:"是否可继承",paraId:50,tocIndex:9},{value:"是否支持动画",paraId:49,tocIndex:9},{value:"计算值",paraId:51,tocIndex:9},{value:"'16px'",paraId:49,tocIndex:9},{value:"-",paraId:49,tocIndex:9},{value:"是",paraId:49,tocIndex:9},{value:"是",paraId:49,tocIndex:9},{value:"<percentage>",paraId:52,tocIndex:9},{value:" ",paraId:49,tocIndex:9},{value:"<length>",paraId:53,tocIndex:9},{value:"字体粗细。",paraId:54,tocIndex:10},{value:"与 ",paraId:55,tocIndex:10},{value:"CSS font-weight",paraId:55,tocIndex:10},{value:" 一致。",paraId:55,tocIndex:10},{value:"支持以下值：",paraId:56,tocIndex:10},{value:"'normal'",paraId:57,tocIndex:10},{value:" 正常粗细度，等于 ",paraId:57,tocIndex:10},{value:"400",paraId:57,tocIndex:10},{value:"'bold'",paraId:57,tocIndex:10},{value:" 加粗，等于 ",paraId:57,tocIndex:10},{value:"700",paraId:57,tocIndex:10},{value:"'bolder'",paraId:57,tocIndex:10},{value:"'lighter'",paraId:57,tocIndex:10},{value:"number",paraId:57,tocIndex:10},{value:" ",paraId:57,tocIndex:10},{value:"1",paraId:57,tocIndex:10},{value:" 到 ",paraId:57,tocIndex:10},{value:"1000",paraId:57,tocIndex:10},{value:" 之间的值。",paraId:57,tocIndex:10},{value:"初始值",paraId:58,tocIndex:10},{value:"适用元素",paraId:59,tocIndex:10},{value:"是否可继承",paraId:60,tocIndex:10},{value:"是否支持动画",paraId:59,tocIndex:10},{value:"计算值",paraId:61,tocIndex:10},{value:"'normal'",paraId:59,tocIndex:10},{value:"-",paraId:59,tocIndex:10},{value:"是",paraId:59,tocIndex:10},{value:"否",paraId:59,tocIndex:10},{value:"<keywords>",paraId:62,tocIndex:10},{value:"字体样式。",paraId:63,tocIndex:11},{value:"与 ",paraId:64,tocIndex:11},{value:"CSS font-style",paraId:64,tocIndex:11},{value:" 一致。",paraId:64,tocIndex:11},{value:"例如下图为倾斜 ",paraId:65,tocIndex:11},{value:"italic",paraId:65,tocIndex:11},{value:" 效果：",paraId:65,tocIndex:11},{value:"初始值",paraId:66,tocIndex:11},{value:"适用元素",paraId:67,tocIndex:11},{value:"是否可继承",paraId:68,tocIndex:11},{value:"是否支持动画",paraId:67,tocIndex:11},{value:"计算值",paraId:69,tocIndex:11},{value:"'normal'",paraId:67,tocIndex:11},{value:"-",paraId:67,tocIndex:11},{value:"是",paraId:67,tocIndex:11},{value:"否",paraId:67,tocIndex:11},{value:"<keywords>",paraId:70,tocIndex:11},{value:"字体样式。",paraId:71,tocIndex:12},{value:"与 ",paraId:72,tocIndex:12},{value:"CSS font-variant",paraId:72,tocIndex:12},{value:" 一致。",paraId:72,tocIndex:12},{value:"支持以下取值：",paraId:73,tocIndex:12},{value:"'normal'",paraId:74,tocIndex:12},{value:" 默认值",paraId:74,tocIndex:12},{value:"'small-caps'",paraId:74,tocIndex:12},{value:"例如下图为 ",paraId:75,tocIndex:12},{value:"small-cap",paraId:75,tocIndex:12},{value:" 效果",paraId:75,tocIndex:12},{value:"初始值",paraId:76,tocIndex:12},{value:"适用元素",paraId:77,tocIndex:12},{value:"是否可继承",paraId:78,tocIndex:12},{value:"是否支持动画",paraId:77,tocIndex:12},{value:"计算值",paraId:79,tocIndex:12},{value:"'normal'",paraId:77,tocIndex:12},{value:"-",paraId:77,tocIndex:12},{value:"是",paraId:77,tocIndex:12},{value:"否",paraId:77,tocIndex:12},{value:"<keywords>",paraId:80,tocIndex:12},{value:"在垂直方向的对齐通过该属性实现，",paraId:81,tocIndex:14},{value:"与 ",paraId:82,tocIndex:14},{value:"Canvas textBaseline",paraId:82,tocIndex:14},{value:" 一致。下图展示了不同取值下的对齐效果：",paraId:82,tocIndex:14},{value:"以文本当前位置为锚点，下图依次展示了 ",paraId:83,tocIndex:14},{value:"top",paraId:83,tocIndex:14},{value:" ",paraId:83,tocIndex:14},{value:"middle",paraId:83,tocIndex:14},{value:" 和 ",paraId:83,tocIndex:14},{value:"bottom",paraId:83,tocIndex:14},{value:" 的效果。除了单行也适用于多行文本块：",paraId:83,tocIndex:14},{value:"初始值",paraId:84,tocIndex:14},{value:"适用元素",paraId:85,tocIndex:14},{value:"是否可继承",paraId:86,tocIndex:14},{value:"是否支持动画",paraId:85,tocIndex:14},{value:"计算值",paraId:87,tocIndex:14},{value:"'alphabetic'",paraId:85,tocIndex:14},{value:"-",paraId:85,tocIndex:14},{value:"是",paraId:85,tocIndex:14},{value:"否",paraId:85,tocIndex:14},{value:"<keywords>",paraId:88,tocIndex:14},{value:"字符间距。",paraId:89,tocIndex:15},{value:"与 ",paraId:90,tocIndex:15},{value:"Canvas letterSpacing",paraId:90,tocIndex:15},{value:" 一致。",paraId:90,tocIndex:15},{value:"初始值",paraId:91,tocIndex:15},{value:"适用元素",paraId:92,tocIndex:15},{value:"是否可继承",paraId:93,tocIndex:15},{value:"是否支持动画",paraId:92,tocIndex:15},{value:"计算值",paraId:94,tocIndex:15},{value:"'0'",paraId:92,tocIndex:15},{value:"-",paraId:92,tocIndex:15},{value:"是",paraId:92,tocIndex:15},{value:"否",paraId:92,tocIndex:15},{value:"<length>",paraId:95,tocIndex:15},{value:"在以下两种情况下会出现换行：",paraId:96,tocIndex:16},{value:"文本中的换行符",paraId:97,tocIndex:16},{value:"开启 ",paraId:97,tocIndex:16},{value:"wordWrap",paraId:97,tocIndex:16},{value:" 后，超出 ",paraId:97,tocIndex:16},{value:"wordWrapWidth",paraId:97,tocIndex:16},{value:" 的部分自动换行，类似 CSS 中的 ",paraId:97,tocIndex:16},{value:"word-break",paraId:97,tocIndex:16},{value:"因此在解析原始文本时，需要考虑这两种情况。但在处理 CJK(Chinese/Japanese/Korean) 字符时，需要考虑它们的特殊语言规范。事实上 CSS 的 ",paraId:98,tocIndex:16},{value:"word-break",paraId:98,tocIndex:16},{value:" 也提供了考虑 CJK 情况的值。",paraId:98,tocIndex:16},{value:"在多行文本中，每一行可以在水平方向以锚点（anchor）对齐。",paraId:99,tocIndex:17},{value:"与 ",paraId:100,tocIndex:17},{value:"CSS text-align",paraId:100,tocIndex:17},{value:" 一致。",paraId:100,tocIndex:17},{value:"支持以下取值：",paraId:101,tocIndex:17},{value:"'start'",paraId:102,tocIndex:17},{value:"'center'",paraId:102,tocIndex:17},{value:"'end'",paraId:102,tocIndex:17},{value:"'left'",paraId:102,tocIndex:17},{value:" 与 ",paraId:102,tocIndex:17},{value:"'start'",paraId:102,tocIndex:17},{value:" 一致。",paraId:102,tocIndex:17},{value:"'right'",paraId:102,tocIndex:17},{value:" 与 ",paraId:102,tocIndex:17},{value:"'end'",paraId:102,tocIndex:17},{value:" 一致。",paraId:102,tocIndex:17},{value:"下图依次展示了 ",paraId:103,tocIndex:17},{value:"left",paraId:103,tocIndex:17},{value:" ",paraId:103,tocIndex:17},{value:"center",paraId:103,tocIndex:17},{value:" 和 ",paraId:103,tocIndex:17},{value:"right",paraId:103,tocIndex:17},{value:" 的效果：",paraId:103,tocIndex:17},{value:"初始值",paraId:104,tocIndex:17},{value:"适用元素",paraId:105,tocIndex:17},{value:"是否可继承",paraId:106,tocIndex:17},{value:"是否支持动画",paraId:105,tocIndex:17},{value:"计算值",paraId:107,tocIndex:17},{value:"'left'",paraId:105,tocIndex:17},{value:"-",paraId:105,tocIndex:17},{value:"是",paraId:105,tocIndex:17},{value:"否",paraId:105,tocIndex:17},{value:"<keywords>",paraId:108,tocIndex:17},{value:"是否开启自动折行，默认值为 ",paraId:109,tocIndex:18},{value:"false",paraId:109,tocIndex:18},{value:"。",paraId:109,tocIndex:18},{value:"开启自动折行后，超出该宽度则换行。",paraId:110,tocIndex:19},{value:"初始值",paraId:111,tocIndex:19},{value:"适用元素",paraId:112,tocIndex:19},{value:"是否可继承",paraId:113,tocIndex:19},{value:"是否支持动画",paraId:112,tocIndex:19},{value:"计算值",paraId:114,tocIndex:19},{value:"'0'",paraId:112,tocIndex:19},{value:"-",paraId:112,tocIndex:19},{value:"否",paraId:112,tocIndex:19},{value:"否",paraId:112,tocIndex:19},{value:"<length>",paraId:115,tocIndex:19},{value:"用于确定如何提示用户存在隐藏的文本溢出内容，例如直接裁剪、追加省略号或一个自定义字符串。需要配合 ",paraId:116,tocIndex:20},{value:"wordWrap",paraId:117,tocIndex:20},{value:" ，",paraId:116,tocIndex:20},{value:"wordWrapWidth",paraId:118,tocIndex:20},{value:" 和 ",paraId:116,tocIndex:20},{value:"maxLines",paraId:119,tocIndex:20},{value:" 一起使用。",paraId:116,tocIndex:20},{value:"与 ",paraId:120,tocIndex:20},{value:"CSS text-overflow",paraId:120,tocIndex:20},{value:" 一致。",paraId:120,tocIndex:20},{value:"支持以下取值：",paraId:121,tocIndex:20},{value:"'clip'",paraId:122,tocIndex:20},{value:" 直接截断文本",paraId:122,tocIndex:20},{value:"'ellipsis'",paraId:122,tocIndex:20},{value:" 使用 ",paraId:122,tocIndex:20},{value:"...",paraId:122,tocIndex:20},{value:" 表示被截断的文本",paraId:122,tocIndex:20},{value:"自定义字符串，使用它表示被截断的文本",paraId:122,tocIndex:20},{value:"注意事项：",paraId:123,tocIndex:20},{value:"'clip'",paraId:124,tocIndex:20},{value:" 和 ",paraId:124,tocIndex:20},{value:"'ellipsis'",paraId:124,tocIndex:20},{value:" 为保留字，因此自定义字符串不能使用它们。",paraId:124,tocIndex:20},{value:"如果自定义文本长度超出 ",paraId:124,tocIndex:20},{value:"wordWrapWidth",paraId:125,tocIndex:20},{value:"，将直接截断，效果等同于 ",paraId:124,tocIndex:20},{value:"'clip'",paraId:124,tocIndex:20},{value:"。",paraId:124,tocIndex:20},{value:"截断仅影响视觉效果，原始文本内容 ",paraId:124,tocIndex:20},{value:"text",paraId:126,tocIndex:20},{value:" 不受影响",paraId:124,tocIndex:20},{value:"初始值",paraId:127,tocIndex:20},{value:"适用元素",paraId:128,tocIndex:20},{value:"是否可继承",paraId:129,tocIndex:20},{value:"是否支持动画",paraId:128,tocIndex:20},{value:"计算值",paraId:130,tocIndex:20},{value:"'clip'",paraId:128,tocIndex:20},{value:"-",paraId:128,tocIndex:20},{value:"否",paraId:128,tocIndex:20},{value:"否",paraId:128,tocIndex:20},{value:"<keywords>",paraId:131,tocIndex:20},{value:"最大行数，文本超出后将被截断，需要配合 ",paraId:132,tocIndex:21},{value:"wordWrap",paraId:133,tocIndex:21},{value:" ，",paraId:132,tocIndex:21},{value:"wordWrapWidth",paraId:134,tocIndex:21},{value:" 和 ",paraId:132,tocIndex:21},{value:"textOverflow",paraId:135,tocIndex:21},{value:" 一起使用。",paraId:132,tocIndex:21},{value:"下图展示了限制文本在一行展示，超出后使用省略号截断：",paraId:136,tocIndex:21},{value:"初始值",paraId:137,tocIndex:21},{value:"适用元素",paraId:138,tocIndex:21},{value:"是否可继承",paraId:139,tocIndex:21},{value:"是否支持动画",paraId:138,tocIndex:21},{value:"计算值",paraId:140,tocIndex:21},{value:"'Infinity'",paraId:138,tocIndex:21},{value:"-",paraId:138,tocIndex:21},{value:"否",paraId:138,tocIndex:21},{value:"否",paraId:138,tocIndex:21},{value:"<number>",paraId:141,tocIndex:21},{value:"行高。",paraId:142,tocIndex:22},{value:"与 ",paraId:143,tocIndex:22},{value:"CSS line-height",paraId:143,tocIndex:22},{value:" 保持一致。",paraId:143,tocIndex:22},{value:"初始值",paraId:144,tocIndex:22},{value:"适用元素",paraId:145,tocIndex:22},{value:"是否可继承",paraId:146,tocIndex:22},{value:"是否支持动画",paraId:145,tocIndex:22},{value:"计算值",paraId:147,tocIndex:22},{value:"'0'",paraId:145,tocIndex:22},{value:"-",paraId:145,tocIndex:22},{value:"否",paraId:145,tocIndex:22},{value:"是",paraId:145,tocIndex:22},{value:"<length>",paraId:148,tocIndex:22},{value:"行间距。",paraId:149,tocIndex:23},{value:"初始值",paraId:150,tocIndex:23},{value:"适用元素",paraId:151,tocIndex:23},{value:"是否可继承",paraId:152,tocIndex:23},{value:"是否支持动画",paraId:151,tocIndex:23},{value:"计算值",paraId:153,tocIndex:23},{value:"'0'",paraId:151,tocIndex:23},{value:"-",paraId:151,tocIndex:23},{value:"否",paraId:151,tocIndex:23},{value:"否",paraId:151,tocIndex:23},{value:"<length>",paraId:154,tocIndex:23},{value:"6.1.28",paraId:155,tocIndex:23},{value:"文本装饰线通过以下四个属性控制，与 CSS ",paraId:156,tocIndex:24},{value:"text-decoration",paraId:156,tocIndex:24},{value:" 一致。",paraId:156,tocIndex:24},{value:"装饰线类型，与 ",paraId:157,tocIndex:25},{value:"CSS text-decoration-line",paraId:157,tocIndex:25},{value:" 一致。",paraId:157,tocIndex:25},{value:"支持以下取值：",paraId:158,tocIndex:25},{value:"'none'",paraId:159,tocIndex:25},{value:" 无装饰线，默认值",paraId:159,tocIndex:25},{value:"'underline'",paraId:159,tocIndex:25},{value:" 下划线",paraId:159,tocIndex:25},{value:"'overline'",paraId:159,tocIndex:25},{value:" 上划线",paraId:159,tocIndex:25},{value:"'line-through'",paraId:159,tocIndex:25},{value:" 删除线",paraId:159,tocIndex:25},{value:"'underline overline'",paraId:159,tocIndex:25},{value:" 同时包含上下划线",paraId:159,tocIndex:25},{value:"可以在该",paraId:160,tocIndex:25},{value:"示例",paraId:161,tocIndex:25},{value:"中调整以下属性。",paraId:160,tocIndex:25},{value:"初始值",paraId:162,tocIndex:25},{value:"适用元素",paraId:163,tocIndex:25},{value:"是否可继承",paraId:164,tocIndex:25},{value:"是否支持动画",paraId:163,tocIndex:25},{value:"计算值",paraId:165,tocIndex:25},{value:"'none'",paraId:163,tocIndex:25},{value:"-",paraId:163,tocIndex:25},{value:"否",paraId:163,tocIndex:25},{value:"否",paraId:163,tocIndex:25},{value:"<keywords>",paraId:166,tocIndex:25},{value:"装饰线样式，与 ",paraId:167,tocIndex:26},{value:"CSS text-decoration-style",paraId:167,tocIndex:26},{value:" 一致。",paraId:167,tocIndex:26},{value:"支持以下取值：",paraId:168,tocIndex:26},{value:"'solid'",paraId:169,tocIndex:26},{value:" 实线，默认值",paraId:169,tocIndex:26},{value:"'double'",paraId:169,tocIndex:26},{value:" 双线",paraId:169,tocIndex:26},{value:"'dotted'",paraId:169,tocIndex:26},{value:" 点线",paraId:169,tocIndex:26},{value:"'dashed'",paraId:169,tocIndex:26},{value:" 虚线",paraId:169,tocIndex:26},{value:"'wavy'",paraId:169,tocIndex:26},{value:" 波浪线",paraId:169,tocIndex:26},{value:"初始值",paraId:170,tocIndex:26},{value:"适用元素",paraId:171,tocIndex:26},{value:"是否可继承",paraId:172,tocIndex:26},{value:"是否支持动画",paraId:171,tocIndex:26},{value:"计算值",paraId:173,tocIndex:26},{value:"'solid'",paraId:171,tocIndex:26},{value:"-",paraId:171,tocIndex:26},{value:"否",paraId:171,tocIndex:26},{value:"否",paraId:171,tocIndex:26},{value:"<keywords>",paraId:174,tocIndex:26},{value:"装饰线颜色，与 ",paraId:175,tocIndex:27},{value:"CSS text-decoration-color",paraId:175,tocIndex:27},{value:" 一致。",paraId:175,tocIndex:27},{value:"支持 CSS 支持的所有颜色格式，例如：",paraId:176,tocIndex:27},{value:"关键词：",paraId:177,tocIndex:27},{value:"'red'",paraId:177,tocIndex:27},{value:" ",paraId:177,tocIndex:27},{value:"'blue'",paraId:177,tocIndex:27},{value:"十六进制：",paraId:177,tocIndex:27},{value:"'#FF0000'",paraId:177,tocIndex:27},{value:"RGB：",paraId:177,tocIndex:27},{value:"'rgb(255, 0, 0)'",paraId:177,tocIndex:27},{value:"RGBA：",paraId:177,tocIndex:27},{value:"'rgba(255, 0, 0, 1)'",paraId:177,tocIndex:27},{value:"初始值",paraId:178,tocIndex:27},{value:"适用元素",paraId:179,tocIndex:27},{value:"是否可继承",paraId:180,tocIndex:27},{value:"是否支持动画",paraId:179,tocIndex:27},{value:"计算值",paraId:181,tocIndex:27},{value:"'currentcolor'",paraId:179,tocIndex:27},{value:"-",paraId:179,tocIndex:27},{value:"否",paraId:179,tocIndex:27},{value:"否",paraId:179,tocIndex:27},{value:"<color>",paraId:182,tocIndex:27},{value:"装饰线粗细，与 ",paraId:183,tocIndex:28},{value:"CSS text-decoration-thickness",paraId:183,tocIndex:28},{value:" 一致。",paraId:183,tocIndex:28},{value:"支持数字类型，表示像素值。例如：",paraId:184,tocIndex:28},{value:"1",paraId:185,tocIndex:28},{value:" 1像素粗细",paraId:185,tocIndex:28},{value:"3",paraId:185,tocIndex:28},{value:" 3像素粗细",paraId:185,tocIndex:28},{value:"初始值",paraId:186,tocIndex:28},{value:"适用元素",paraId:187,tocIndex:28},{value:"是否可继承",paraId:188,tocIndex:28},{value:"是否支持动画",paraId:187,tocIndex:28},{value:"计算值",paraId:189,tocIndex:28},{value:"1",paraId:187,tocIndex:28},{value:"-",paraId:187,tocIndex:28},{value:"否",paraId:187,tocIndex:28},{value:"否",paraId:187,tocIndex:28},{value:"<length>",paraId:190,tocIndex:28},{value:"获取每一行文本的包围盒，例如：",paraId:191,tocIndex:31},{value:"text.getLineBoundingRects(); // Rectangle[]\n",paraId:192,tocIndex:31},{value:"其中包围盒结构如下，其中 x/y 相对于文本的局部坐标系：",paraId:193,tocIndex:31},{value:"interface Rectangle {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\n",paraId:194,tocIndex:31},{value:"在",paraId:195,tocIndex:31},{value:"示例",paraId:196,tocIndex:31},{value:"中，我们绘制出了多行文本中每一行的包围盒，可以根据包围盒信息实现例如下划线、删除线等高级文本特性：",paraId:195,tocIndex:31},{value:"text.getLineBoundingRects().forEach(({ x, y, width, height }) => {\n    const block = new Rect({\n        style: {\n            x,\n            y,\n            width,\n            height,\n            stroke: 'black',\n            lineWidth: 2,\n        },\n    });\n    text.appendChild(block);\n});\n",paraId:197,tocIndex:31},{value:"用于判断是否有溢出内容。便于类似 Tooltip 组件判定是否需要展示完整文本。",paraId:198,tocIndex:32},{value:"text.isOverflowing(); // true\n",paraId:199,tocIndex:32},{value:"需要注意的是，存在折行并不意味着一定有溢出内容。例如下图即使设置了 ",paraId:200,tocIndex:32},{value:"maxLines",paraId:200,tocIndex:32},{value:" 和 ",paraId:200,tocIndex:32},{value:"wordWrapWidth",paraId:200,tocIndex:32},{value:"，但内容并不存在溢出情况，该方法返回 ",paraId:200,tocIndex:32},{value:"false",paraId:200,tocIndex:32},{value:"：",paraId:200,tocIndex:32},{value:"而只有内容确实存在溢出情况，即 ",paraId:201,tocIndex:32},{value:"textOverflow",paraId:202,tocIndex:32},{value:" 属性确实生效（无论它的取值是啥），才会返回 ",paraId:201,tocIndex:32},{value:"true",paraId:201,tocIndex:32},{value:"：",paraId:201,tocIndex:32},{value:"除了系统默认字体，有时我们希望加载第三方字体。",paraId:203,tocIndex:33},{value:"此时可以使用 ",paraId:204,tocIndex:33},{value:"Web Font Loader",paraId:204,tocIndex:33},{value:"，在加载成功的 ",paraId:204,tocIndex:33},{value:"active",paraId:204,tocIndex:33},{value:" 回调函数中创建，",paraId:204,tocIndex:33},{value:"示例",paraId:205,tocIndex:33},{value:"：",paraId:204,tocIndex:33},{value:"import WebFont from 'webfontloader';\n\nWebFont.load({\n    google: {\n        families: ['Gaegu'],\n    },\n    active: () => {\n        const text = new Text({\n            style: {\n                x: 100,\n                y: 100,\n                fontFamily: 'Gaegu',\n                text: 'Almost before we knew it, we had left the ground.',\n                fontSize: 30,\n                fill: '#1890FF',\n                stroke: '#F04864',\n                lineWidth: 5,\n            },\n        });\n        canvas.appendChild(text);\n    },\n});\n",paraId:206,tocIndex:33},{value:"CanvasKit 提供了 ",paraId:207,tocIndex:34},{value:"众多文本段落增强功能",paraId:208,tocIndex:34},{value:"。 我们将这些能力整合进了 ",paraId:207,tocIndex:34},{value:"g-canvaskit",paraId:209,tocIndex:34},{value:" 渲染器中。",paraId:207,tocIndex:34},{value:"由于 Text 的很多属性都是可继承的，这意味着如果未显式传入它们的值，只有在加入文档后才能获取到正确的继承值，从而计算得到精确的包围盒。如果确实想在加入文档前获取包围盒大小，例如实例化之后立刻获取到精确的包围盒，需要手动传入它们的值：",paraId:210,tocIndex:36},{value:"const text = new Text({\n    style: {\n        text: 'abcde',\n    },\n});\ntext.getBounds(); // Wrong empty bounding box.\n\ntext.attr({\n    fontSize: '16px',\n    fontFamily: 'sans-serif',\n    fontWeight: 'normal',\n    fontVariant: 'normal',\n    fontStyle: 'normal',\n    textAlign: 'start',\n    textBaseline: 'alphabetic',\n    lineWidth: 0,\n});\ntext.getBounds(); // Right bounding box.\n",paraId:211,tocIndex:36}]},62552:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(19970);const d=[{value:"在 G 中有以下继承关系：",paraId:0},{value:"Document -> Node -> EventTarget",paraId:1},{value:"我们可以把 ",paraId:2},{value:"Document",paraId:2},{value:" 类比成浏览器环境中的 ",paraId:2},{value:"window.document",paraId:2},{value:"，例如在浏览器中：",paraId:2},{value:"它有指向 ",paraId:3},{value:"window",paraId:3},{value:" 的引用 ",paraId:3},{value:"defaultView",paraId:4},{value:"通过 ",paraId:3},{value:"documentElement",paraId:5},{value:" 访问 ",paraId:3},{value:"<html>",paraId:3},{value:" 元素",paraId:3},{value:"可以通过一系列方法查询节点，例如 ",paraId:3},{value:"getElementById",paraId:6},{value:"通过 ",paraId:3},{value:"createElement",paraId:7},{value:" 创建元素",paraId:3},{value:"我们尽可能实现了以上浏览器提供的 API。",paraId:8},{value:"Node",paraId:9},{value:"实现了 ",paraId:10,tocIndex:2},{value:"Node.nodeName",paraId:11,tocIndex:2},{value:"，返回 ",paraId:10,tocIndex:2},{value:"'document'",paraId:10,tocIndex:2},{value:"，在事件处理器中可用来快速判断 target，例如点击了画布的空白区域时：",paraId:10,tocIndex:2},{value:"canvas.addEventListener('click', (e) => {\n    e.target; // Document\n\n    if (e.target.nodeName === 'document') {\n        //...\n    }\n});\n",paraId:12,tocIndex:2},{value:"指向画布，例如：",paraId:13,tocIndex:3},{value:"canvas.document.defaultView; // canvas\n",paraId:14,tocIndex:3},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Document/defaultView",paraId:15,tocIndex:3},{value:"返回场景图中的根节点，在创建画布时会默认使用 ",paraId:16,tocIndex:4},{value:"Group",paraId:17,tocIndex:4},{value:" 创建一个：",paraId:16,tocIndex:4},{value:"canvas.document.documentElement; // Group\ncanvas.document.documentElement.getBounds(); // 获取整个场景的包围盒\n",paraId:18,tocIndex:4},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Document/documentElement",paraId:19,tocIndex:4},{value:"默认时间轴，在动画系统中使用。",paraId:20,tocIndex:5},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/timeline",paraId:21,tocIndex:5},{value:"返回 null",paraId:22,tocIndex:6},{value:"由于继承自 ",paraId:23,tocIndex:7},{value:"Node",paraId:24,tocIndex:7},{value:"，因此显然拥有了事件绑定能力：",paraId:23,tocIndex:7},{value:"canvas.document.addEventListener('click', () => {});\n",paraId:25,tocIndex:7},{value:"但在一些方法特别是节点操作上和 Node 有差异。",paraId:26,tocIndex:7},{value:"虽然继承了 ",paraId:27,tocIndex:8},{value:"Node",paraId:28,tocIndex:8},{value:"，但在 Document 上无法调用一些节点操作方法，正如在浏览器中调用 ",paraId:27,tocIndex:8},{value:"document.appendChild",paraId:27,tocIndex:8},{value:" 会返回如下错误一样：",paraId:27,tocIndex:8},{value:"Uncaught DOMException: Failed to execute 'appendChild' on 'Node': Only one element on document allowed.\n",paraId:29,tocIndex:8},{value:"以下节点查询方法等同于在 document.documentElement 上执行。",paraId:30,tocIndex:9},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/getElementById",paraId:31,tocIndex:10},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/getElementsByName",paraId:32,tocIndex:11},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/getElementsByClassName",paraId:33,tocIndex:12},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/getElementsByTagName",paraId:34,tocIndex:13},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelector",paraId:35,tocIndex:14},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelectorAll",paraId:36,tocIndex:15},{value:"通常我们建议使用 ",paraId:37,tocIndex:16},{value:"new Circle()",paraId:37,tocIndex:16},{value:" 这样的方式创建内置或者自定义图形，但我们也提供了类似 DOM ",paraId:37,tocIndex:16},{value:"CustomElementRegistry",paraId:37,tocIndex:16},{value:" API，可以使用 ",paraId:37,tocIndex:16},{value:"document.createElement",paraId:38,tocIndex:16},{value:" 创建完成注册的图形，因此以下写法等价：",paraId:37,tocIndex:16},{value:"import { Shape, Circle } from '@antv/g';\n\nconst circle = canvas.document.createElement(Shape.CIRCLE, {\n    style: { r: 100 },\n});\n\n// 或者\nconst circle = new Circle({ style: { r: 100 } });\n",paraId:39,tocIndex:16},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement",paraId:40,tocIndex:16},{value:"目前实现同 createElement。",paraId:41,tocIndex:17},{value:"当我们想知道画布中某个点上堆叠了多少个图形，除了通过交互事件，还可以通过 API 方式完成拾取。",paraId:42,tocIndex:18},{value:"该方法接受一组 ",paraId:43,tocIndex:18},{value:"x, y",paraId:43,tocIndex:18},{value:" 坐标（在 ",paraId:43,tocIndex:18},{value:"Canvas 坐标系",paraId:44,tocIndex:18},{value:"下，如果想使用其他坐标系下的坐标，请使用",paraId:43,tocIndex:18},{value:"转换方法",paraId:45,tocIndex:18},{value:"）为参数，返回拾取结果。",paraId:43,tocIndex:18},{value:"在下面的",paraId:46,tocIndex:18},{value:"例子",paraId:47,tocIndex:18},{value:"中，我们在 ",paraId:46,tocIndex:18},{value:"Canvas 坐标系",paraId:48,tocIndex:18},{value:"下 ",paraId:46,tocIndex:18},{value:"[100, 100]",paraId:46,tocIndex:18},{value:" 放置了一个半径为 ",paraId:46,tocIndex:18},{value:"100",paraId:46,tocIndex:18},{value:" 的 ",paraId:46,tocIndex:18},{value:"Circle",paraId:49,tocIndex:18},{value:"，在红点处拾取时会返回它：",paraId:46,tocIndex:18},{value:"const topMostElement = await canvas.document.elementFromPoint(20, 100); // circle1\n\nawait canvas.document.elementFromPoint(0, 0); // canvas.document.documentElement\n",paraId:50,tocIndex:18},{value:"有三点需要注意：",paraId:51,tocIndex:18},{value:"有别于浏览器提供的同步 API，由于部分渲染器的实现（例如 ",paraId:52,tocIndex:18},{value:"g-webgl",paraId:52,tocIndex:18},{value:"）需要通过 GPU 方式完成拾取，因此该方法为",paraId:52,tocIndex:18},{value:"异步",paraId:52,tocIndex:18},{value:"当只需要获取该点命中的最顶层的图形时，应该使用 ",paraId:52,tocIndex:18},{value:"elementFromPoint",paraId:52,tocIndex:18},{value:" 而非 ",paraId:52,tocIndex:18},{value:"elementsFromPoint",paraId:52,tocIndex:18},{value:"，前者在绝大部分场景下都比后者快",paraId:52,tocIndex:18},{value:"拾取判定遵循以下规则：\n",paraId:52,tocIndex:18},{value:"超出画布视口范围（考虑到相机，并不一定等于画布范围）返回 null。",paraId:53,tocIndex:18},{value:"图形的 ",paraId:53,tocIndex:18},{value:"interactive",paraId:54,tocIndex:18},{value:" 属性",paraId:53,tocIndex:18},{value:"会影响",paraId:53,tocIndex:18},{value:"拾取。不可交互图形无法拾取。",paraId:53,tocIndex:18},{value:"图形的 ",paraId:53,tocIndex:18},{value:"visibility",paraId:55,tocIndex:18},{value:" 属性",paraId:53,tocIndex:18},{value:"会影响",paraId:53,tocIndex:18},{value:"拾取。不可见图形无法拾取。",paraId:53,tocIndex:18},{value:"图形的 ",paraId:53,tocIndex:18},{value:"opacity",paraId:56,tocIndex:18},{value:" 属性",paraId:53,tocIndex:18},{value:"不会影响",paraId:53,tocIndex:18},{value:"拾取。即使图形完全透明，依然也会被拾取到。",paraId:53,tocIndex:18},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Document/elementFromPoint",paraId:57,tocIndex:18},{value:"当目标点上有多个图形堆叠时，该方法会按照 ",paraId:58,tocIndex:19},{value:"z-index",paraId:59,tocIndex:19},{value:" 排序后返回它们，返回结果中的第一个元素为最顶层的图形。",paraId:58,tocIndex:19},{value:"该方法同样接受一组 ",paraId:60,tocIndex:19},{value:"x, y",paraId:60,tocIndex:19},{value:" 坐标作为参数。",paraId:60,tocIndex:19},{value:"在下面的",paraId:61,tocIndex:19},{value:"例子",paraId:62,tocIndex:19},{value:"中，circle2 在 circle1 之上，因此在重叠区域进行拾取两者都会出现在结果数组中，并且 circle2 在前：",paraId:61,tocIndex:19},{value:"const elements = await canvas.document.elementsFromPoint(150, 150); // [circle2, circle1, document.documentElement]\n",paraId:63,tocIndex:19},{value:"注意事项：",paraId:64,tocIndex:19},{value:"该返回结果和事件对象上的 ",paraId:65,tocIndex:19},{value:"composedPath()",paraId:66,tocIndex:19},{value:" 的差别是，后者会在返回数组中追加 ",paraId:65,tocIndex:19},{value:"Document",paraId:67,tocIndex:19},{value:" 和 ",paraId:65,tocIndex:19},{value:"Canvas",paraId:68,tocIndex:19},{value:" 对象，而前者只到 ",paraId:65,tocIndex:19},{value:"画布根节点",paraId:69,tocIndex:19},{value:" 为止。",paraId:65,tocIndex:19},{value:"超出画布视口范围返回空数组。",paraId:65,tocIndex:19},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Document/elementsFromPoint",paraId:70,tocIndex:19},{value:"区域查询特别是基于包围盒的检测在以下场景中特别适用：",paraId:71,tocIndex:20},{value:"脏矩形渲染中用于确定受影响区域",paraId:72,tocIndex:20},{value:"矩形刷选批量选中图形",paraId:72,tocIndex:20},{value:"此类基于包围盒的检测不需要太精确，配合内部 RBush 这样的空间索引，因此速度很快。",paraId:73,tocIndex:20},{value:"该方法为同步方法，接受包围盒描述 ",paraId:74,tocIndex:20},{value:"minX, minY, maxX, maxY",paraId:74,tocIndex:20},{value:" 坐标（在 ",paraId:74,tocIndex:20},{value:"Canvas 坐标系",paraId:75,tocIndex:20},{value:"下）：",paraId:74,tocIndex:20},{value:"const elements = document.elementsFromBBox(minX, minY, maxX, maxY);\n",paraId:76,tocIndex:20},{value:"注意事项：",paraId:77,tocIndex:20},{value:"会考虑 ",paraId:78,tocIndex:20},{value:"visibility",paraId:79,tocIndex:20},{value:" 和 ",paraId:78,tocIndex:20},{value:"pointer-events",paraId:80,tocIndex:20},{value:" 属性",paraId:78,tocIndex:20},{value:"无需考虑 WebGL / WebGPU 这样基于 GPU 的拾取实现，为同步方法",paraId:78,tocIndex:20},{value:"返回的元素数组按实际渲染次序排序",paraId:78,tocIndex:20},{value:"elementFromPoint",paraId:81,tocIndex:21},{value:" 的同步版本，值得注意的是，并不是所有",paraId:82,tocIndex:21},{value:"渲染器",paraId:83,tocIndex:21},{value:"都会实现该方法，目前仅有 ",paraId:82,tocIndex:21},{value:"g-canvas",paraId:84,tocIndex:21},{value:"，",paraId:82,tocIndex:21},{value:"g-svg",paraId:85,tocIndex:21},{value:" 和 ",paraId:82,tocIndex:21},{value:"g-canvaskit",paraId:86,tocIndex:21},{value:" 提供了对应实现：",paraId:82,tocIndex:21},{value:"const element = canvas.document.elementFromPoint(0, 0); // canvas.document.documentElement\n",paraId:87,tocIndex:21},{value:"elementsFromPoint",paraId:88,tocIndex:22},{value:" 的同步版本，值得注意的是，并不是所有",paraId:89,tocIndex:22},{value:"渲染器",paraId:90,tocIndex:22},{value:"都会实现该方法，目前仅有 ",paraId:89,tocIndex:22},{value:"g-canvas",paraId:91,tocIndex:22},{value:"，",paraId:89,tocIndex:22},{value:"g-svg",paraId:92,tocIndex:22},{value:" 和 ",paraId:89,tocIndex:22},{value:"g-canvaskit",paraId:93,tocIndex:22},{value:" 提供了对应实现：",paraId:89,tocIndex:22},{value:"const elements = canvas.document.elementsFromPoint(150, 150); // [circle2, circle1, document.documentElement]\n",paraId:94,tocIndex:22}]},42448:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(7314);const d=[{value:"在 G 中有以下继承关系：",paraId:0},{value:"DisplayObject -> Element -> Node -> EventTarget",paraId:1},{value:"Node",paraId:2},{value:"场景图中唯一，后续可以通过 getElementById 查询：",paraId:3,tocIndex:2},{value:"const circle = new Circle({\n    id: 'my-id',\n    style: { r: 10 },\n});\n\ncircle.id; // 'my-id';\n",paraId:4,tocIndex:2},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/id",paraId:5,tocIndex:2},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/name",paraId:6,tocIndex:3},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/className",paraId:7,tocIndex:4},{value:"只读属性，返回类名列表。",paraId:8,tocIndex:5},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/classList",paraId:9,tocIndex:5},{value:"circle.className = 'c1 c2';\ncircle.classList; // ['c1', 'c2']\n",paraId:10,tocIndex:5},{value:"只读，返回样式属性，例如：",paraId:11,tocIndex:6},{value:"const circle = new Circle({ style: { r: 10 } });\n\ncircle.attributes.r; // 10;\n",paraId:12,tocIndex:6},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/attributes",paraId:13,tocIndex:6},{value:"返回子元素列表，和 Node.childNodes 等价。",paraId:14,tocIndex:7},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/children",paraId:15,tocIndex:7},{value:"返回子元素列表长度。",paraId:16,tocIndex:8},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/childElementCount",paraId:17,tocIndex:8},{value:"和 ",paraId:18,tocIndex:9},{value:"Node.firstChild",paraId:19,tocIndex:9},{value:" 等价。",paraId:18,tocIndex:9},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/firstElementChild",paraId:20,tocIndex:9},{value:"和 ",paraId:21,tocIndex:10},{value:"Node.lastChild",paraId:22,tocIndex:10},{value:" 等价。",paraId:21,tocIndex:10},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/lastElementChild",paraId:23,tocIndex:10},{value:"由于暂不支持 border，始终返回 0。",paraId:24,tocIndex:11},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Element/clientTop",paraId:25,tocIndex:11},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNames",paraId:26,tocIndex:13},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute",paraId:27,tocIndex:14},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute",paraId:28,tocIndex:15},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute",paraId:29,tocIndex:16},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttribute",paraId:30,tocIndex:17},{value:"返回浏览器坐标系下的包围盒，不考虑子元素。",paraId:31,tocIndex:18},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect",paraId:32,tocIndex:18},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects",paraId:33,tocIndex:19},{value:"获取",paraId:34,tocIndex:20},{value:"样式系统",paraId:35,tocIndex:20},{value:"解析后的样式 Map，例如：",paraId:34,tocIndex:20},{value:"const circle = new Circle({\n  style: {\n    r: 100,\n    fill: '#f00',\n  },\n});\n\n/**\n * user-defined values\n */\nexpect(circle.getAttribute('r')).toBe(100);\nexpect(circle.getAttribute('fill')).toBe('#f00');\n\n/**\n * computed values\n */\nconst styleMap = circle.computedStyleMap();\nexpect((styleMap.get('r') as CSSUnitValue).equals(CSS.px(100))).to.be.true;\nconst fill = styleMap.get('fill') as CSSRGB;\nexpect(fill.r).toBe(255);\nexpect(fill.g).toBe(0);\nexpect(fill.b).toBe(0);\nexpect(fill.alpha).toBe(1);\n",paraId:36,tocIndex:20},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Element/computedStyleMap",paraId:37,tocIndex:20},{value:"销毁自身，会移除一切事件监听器，停止正在进行的动画。",paraId:38,tocIndex:21},{value:"是否匹配选择器字符串",paraId:39,tocIndex:23},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Element/matches",paraId:40,tocIndex:23},{value:"基于 Node 已有的节点操作能力，提供一些更便捷的操作，例如批量添加兄弟节点、替换所有子节点等。",paraId:41,tocIndex:31},{value:"在当前节点的子节点列表末尾批量添加一组节点。方法签名如下：",paraId:42,tocIndex:32},{value:"append(...nodes: Element[]): void\n",paraId:43,tocIndex:32},{value:"parent.appendChild(child1);\nparent.appendChild(child2); // parent -> [child1, child2]\nparent.append(child3, child34); // parent -> [child1, child2, child3, child4]\n",paraId:44,tocIndex:32},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/append",paraId:45,tocIndex:32},{value:"在当前节点的子节点列表头部批量添加一组节点。方法签名如下：",paraId:46,tocIndex:33},{value:"prepend(...nodes: Element[]): void\n",paraId:47,tocIndex:33},{value:"parent.appendChild(child1);\nparent.appendChild(child2); // parent -> [child1, child2]\nparent.prepend(child3, child34); // parent -> [child3, child4, child1, child2]\n",paraId:48,tocIndex:33},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/prepend",paraId:49,tocIndex:33},{value:"在当前节点之后批量添加一些兄弟节点，例如一次性添加一批：",paraId:50,tocIndex:34},{value:"circle.after(sibling1, sibling2); // [circle, sibling1, sibling2]\n",paraId:51,tocIndex:34},{value:"方法签名如下：",paraId:52,tocIndex:34},{value:"after(...nodes: Element[]): void\n",paraId:53,tocIndex:34},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/after",paraId:54,tocIndex:34},{value:"在当前节点之前批量添加一些兄弟节点，例如一次性添加一批：",paraId:55,tocIndex:35},{value:"circle.before(sibling1, sibling2); // [sibling1, sibling2, circle]\n",paraId:56,tocIndex:35},{value:"方法签名如下：",paraId:57,tocIndex:35},{value:"before(...nodes: Element[]): void\n",paraId:58,tocIndex:35},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/before",paraId:59,tocIndex:35},{value:"将自身从场景图中移除。",paraId:60,tocIndex:36},{value:"circle.remove();\n",paraId:61,tocIndex:36},{value:"方法签名如下：",paraId:62,tocIndex:36},{value:"remove(): void\n",paraId:63,tocIndex:36},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/remove",paraId:64,tocIndex:36},{value:"将所有子节点从场景图中移除。",paraId:65,tocIndex:37},{value:"parent.removeChildren();\n",paraId:66,tocIndex:37},{value:"在父节点的子节点列表中，用传入的节点列表替换该节点：",paraId:67,tocIndex:38},{value:"parent.appendChild(child1);\nparent.appendChild(child2); // parent -> [child1, child2]\nchild1.replaceWith(node1, node2); // parent -> [node1, node2, child2]\n",paraId:68,tocIndex:38},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceWith",paraId:69,tocIndex:38},{value:"替换该节点的所有子节点。不传参数时则会清空并销毁该节点的所有子节点：",paraId:70,tocIndex:39},{value:"parent.replaceChildren(child1, child2);\nparent.replaceChildren(); // 清空\n",paraId:71,tocIndex:39},{value:"方法签名如下：",paraId:72,tocIndex:39},{value:"replaceChildren(...nodes: Element[]): void\n",paraId:73,tocIndex:39},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceChildren",paraId:74,tocIndex:39},{value:"返回应用在当前元素上的动画对象列表，详见",paraId:75,tocIndex:40},{value:"动画系统",paraId:76,tocIndex:40},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Element/getAnimations",paraId:77,tocIndex:40},{value:"应用 Keyframe 动画，详见",paraId:78,tocIndex:41},{value:"动画系统",paraId:79,tocIndex:41},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/animate",paraId:80,tocIndex:41},{value:" imate",paraId:80,tocIndex:41}]},73093:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(17395);const d=[{value:"和 DOM API 中的 ",paraId:0},{value:"EventTarget",paraId:0},{value:" 类似，该对象提供了事件绑定/解绑的能力。",paraId:0},{value:"在 G 中有以下继承关系，因此 ",paraId:1},{value:"Canvas",paraId:2},{value:"，",paraId:1},{value:"Document",paraId:3},{value:"，",paraId:1},{value:"DisplayObject",paraId:4},{value:" 这些高级对象都拥有事件管理能力：",paraId:1},{value:"Canvas -> EventTarget",paraId:5},{value:"Document -> Node -> EventTarget",paraId:5},{value:"DisplayObject -> Element -> Node -> EventTarget",paraId:5},{value:"具体 API 可以参考",paraId:6},{value:"事件系统",paraId:7},{value:"：",paraId:6},{value:"绑定事件：",paraId:8},{value:"addEventListener",paraId:9},{value:"解绑事件：",paraId:8},{value:"removeEventListener",paraId:10},{value:"触发自定义事件：",paraId:8},{value:"dispatchEvent",paraId:11},{value:"移除所有事件监听器 ",paraId:8},{value:"removeAllEventListeners",paraId:12}]},84207:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(86687);const d=[{value:"在 DOM API 中，当我们想感知 DOM 树节点的修改，例如新节点加入、属性值变更，可以使用 ",paraId:0},{value:"MutationObserver",paraId:0},{value:"。",paraId:0},{value:"在 G 中我们同样实现了这个 API，用来监听场景图中的变化。",paraId:1},{value:"创建一个 MutationObserver 需要传入一个 callback：",paraId:2,tocIndex:0},{value:"const group1 = new Group();\nconst group2 = new Group();\nconst group3 = new Group();\ncanvas.appendChild(group1);\n\n// 创建一个 MutationObserver\nconst observer = new MutationObserver(() => {});\n\n// 开始监听\nobserver.observe(group1, { childList: true });\n\n// 操作场景图\ngroup1.appendChild(group2);\ngroup1.appendChild(group3);\n\n// 获取变更记录\nconst records = observer.takeRecords();\n\n// 断开监听\nobserver.disconnect();\n",paraId:3,tocIndex:0},{value:"监听场景图中一个节点的变化，可以通过配置选择监听单个节点或者全部子孙节点。",paraId:4,tocIndex:1},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/observe",paraId:5,tocIndex:1},{value:"mutationObserver.observe(target[, options])\n",paraId:6,tocIndex:1},{value:"options",paraId:7,tocIndex:1},{value:" 为可选项，类型为 ",paraId:7,tocIndex:1},{value:"MutationObserverInit",paraId:7,tocIndex:1},{value:" 配置如下：",paraId:7,tocIndex:1},{value:"childList",paraId:8,tocIndex:1},{value:" 设为 true 以监视目标节点（如果 subtree 为 true，则包含子孙节点）添加或删除新的子节点。默认值为 false。",paraId:8,tocIndex:1},{value:"subtree",paraId:8,tocIndex:1},{value:" 设为 true 以将监视范围扩展至目标节点整个节点树中的所有节点。MutationObserverInit 的其他值也会作用于此子树下的所有节点，而不仅仅只作用于目标节点。默认值为 false。",paraId:8,tocIndex:1},{value:"attributes",paraId:8,tocIndex:1},{value:" 设为 true 以观察受监视元素的属性值变更。默认值为 false。",paraId:8,tocIndex:1},{value:"attributeOldValue",paraId:8,tocIndex:1},{value:" 当监视节点的属性改动时，将此属性设为 true 将记录任何有改动的属性的上一个值。",paraId:8,tocIndex:1},{value:"attributeFilter",paraId:8,tocIndex:1},{value:" 要监视的特定属性名称的数组。如果未包含此属性，则对所有属性的更改都会触发变动通知。无默认值。",paraId:8,tocIndex:1},{value:"断开监听。",paraId:9,tocIndex:2},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/disconnect",paraId:10,tocIndex:2},{value:"获取变更记录。",paraId:11,tocIndex:3},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/takeRecords",paraId:12,tocIndex:3},{value:"在下面的例子中，我们监听父节点的变化，当加入两个子节点后获取到两条变更记录：",paraId:13,tocIndex:3},{value:"const group1 = new Group();\nconst group2 = new Group();\nconst group3 = new Group();\ncanvas.appendChild(group1);\n\n// 创建一个 MutationObserver\nconst observer = new MutationObserver(() => {});\n\n// 开始监听 group1 上的变更\nobserver.observe(group1, { childList: true });\n\n// 操作场景图\ngroup1.appendChild(group2);\ngroup1.appendChild(group3);\n\n// 获取变更记录\nconst records = observer.takeRecords();\n// 包含两条记录\nexpect(records.length).to.eqls(2);\nexpect(records[0].type).to.eqls('childList');\nexpect(records[0].target).to.eqls(group1);\nexpect(records[0].addedNodes.length).to.eqls(1);\nexpect(records[0].addedNodes[0]).to.eqls(group2);\n\nexpect(records[1].type).to.eqls('childList');\nexpect(records[1].target).to.eqls(group1);\nexpect(records[1].addedNodes.length).to.eqls(1);\nexpect(records[1].addedNodes[0]).to.eqls(group3);\nexpect(records[1].previousSibling).to.eqls(group2);\n",paraId:14,tocIndex:3}]},93273:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(17491);const d=[{value:"和 DOM API 中的 ",paraId:0},{value:"Node",paraId:0},{value:" 类似，该对象提供了一部分场景图能力，例如节点添加、删除等。",paraId:0},{value:"在 G 中有以下继承关系：",paraId:1},{value:"Document -> Node -> EventTarget",paraId:2},{value:"DisplayObject -> Element -> Node -> EventTarget",paraId:2},{value:"EventTarget",paraId:3},{value:"只读，返回节点名称，例如：",paraId:4,tocIndex:2},{value:"circle.nodeName; // 'circle'\nrect.nodeName; // 'rect'\n",paraId:5,tocIndex:2},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeName",paraId:6,tocIndex:2},{value:"G 内置图形名称如下：",paraId:7,tocIndex:2},{value:"export enum Shape {\n  GROUP = 'g',\n  CIRCLE = 'circle',\n  ELLIPSE = 'ellipse',\n  IMAGE = 'image',\n  RECT = 'rect',\n  LINE = 'line',\n  POLYLINE = 'polyline',\n  POLYGON = 'polygon',\n  TEXT = 'text',\n  PATH = 'path',\n  HTML = 'html',\n  MESH = 'mesh'\n}\n",paraId:8,tocIndex:2},{value:"只读，返回节点字符串，默认为 null。",paraId:9,tocIndex:3},{value:"Text",paraId:10,tocIndex:3},{value:" 会返回文本字符串。",paraId:9,tocIndex:3},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeValue",paraId:11,tocIndex:3},{value:"const group = new Group();\ngroup.nodeValue; // null\n\nconst text = new Text({ style: { text: 'test' } });\ntext.nodeValue; // 'test'\n",paraId:12,tocIndex:3},{value:"只读，是否被加入到画布中，例如：",paraId:13,tocIndex:4},{value:"circle.isConnected; // false\ncanvas.appendChild(circle); // 加入到画布中\ncircle.isConnected; // true\n",paraId:14,tocIndex:4},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/isConnected",paraId:15,tocIndex:4},{value:"只读，指向画布的入口 ",paraId:16,tocIndex:5},{value:"Document",paraId:17,tocIndex:5},{value:"。如果还未加入到画布中，返回 null，例如：",paraId:16,tocIndex:5},{value:"circle.ownerDocument; // null\ncanvas.appendChild(circle); // 加入到画布中\ncircle.ownerDocument; // canvas.document\n",paraId:18,tocIndex:5},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/ownerDocument",paraId:19,tocIndex:5},{value:"只读，返回当前节点的父节点。",paraId:20,tocIndex:6},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/parentNode",paraId:21,tocIndex:6},{value:"只读，在目前的实现中同 parentNode。",paraId:22,tocIndex:7},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/parentElement",paraId:23,tocIndex:7},{value:"只读，返回当前节点的子节点列表。",paraId:24,tocIndex:8},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/childNodes",paraId:25,tocIndex:8},{value:"只读，返回当前节点的第一个子节点，如果无子节点，则返回 null。",paraId:26,tocIndex:9},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/firstChild",paraId:27,tocIndex:9},{value:"只读，返回当前节点的最后一个子节点，如果无子节点，则返回 null。",paraId:28,tocIndex:10},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/lastChild",paraId:29,tocIndex:10},{value:"只读，返回当前节点的后一个兄弟节点，没有则返回 null。",paraId:30,tocIndex:11},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nextSibling",paraId:31,tocIndex:11},{value:"只读，返回当前节点的前一个兄弟节点，没有则返回 null。",paraId:32,tocIndex:12},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/previousSibling",paraId:33,tocIndex:12},{value:"读写属性，获取或者设置节点的文本内容。默认返回空字符串，",paraId:34,tocIndex:13},{value:"Text",paraId:35,tocIndex:13},{value:" 会返回文本字符串。",paraId:34,tocIndex:13},{value:"在读取时，该方法会递归计算子节点，将最终拼接而成的字符串返回：",paraId:36,tocIndex:13},{value:"const group = new Group();\ngroup.textContent; // ''\n\nconst text = new Text({ style: { text: 'test' } });\ngroup.appendChild(text);\n\ntext.textContent; // 'test'\ngroup.textContent; // 'test'\n",paraId:37,tocIndex:13},{value:"在设置时，会首先移除该节点的所有子节点，如果该节点是 ",paraId:38,tocIndex:13},{value:"Text",paraId:39,tocIndex:13},{value:"，直接修改文本内容；如果该节点不是 ",paraId:38,tocIndex:13},{value:"Text",paraId:40,tocIndex:13},{value:"，会创建一个 ",paraId:38,tocIndex:13},{value:"Text",paraId:41,tocIndex:13},{value:" 作为子节点并设置文本内容。",paraId:38,tocIndex:13},{value:"const text = new Text({ style: { text: 'test' } });\ntext.textContent = 'changed';\n\n// create a Text & insertChild\ngroup.textContent = 'changed';\ngroup.childNodes; // [Text]\n",paraId:42,tocIndex:13},{value:"将一个节点添加到指定父节点的子节点列表末尾处。如果该节点已经在场景图中，会先从原位置处移除，再添加到新的位置。",paraId:43,tocIndex:15},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild",paraId:44,tocIndex:15},{value:"方法签名为 ",paraId:45,tocIndex:16},{value:"cloneNode(deep?: boolean): this",paraId:45,tocIndex:16},{value:"，可选参数为是否需要深拷贝，返回克隆得到的新节点。",paraId:45,tocIndex:16},{value:"在下面的例子中，我们创建了一个圆，设置了它的半径与位置。拷贝得到的新节点拥有同样的样式属性与位置：",paraId:46,tocIndex:16},{value:"circle.style.r = 20;\ncircle.setPosition(10, 20);\n\nconst clonedCircle = circle.cloneNode();\nclonedCircle instanceof Circle; // true\nclonedCircle.style.r; // 20\nclonedCircle.getPosition(); // [10, 20]\n",paraId:47,tocIndex:16},{value:"注意事项：",paraId:48,tocIndex:16},{value:"支持深拷贝，即自身以及整棵子树",paraId:49,tocIndex:16},{value:"克隆的新节点不会保留原始节点的父子关系，需要使用 ",paraId:49,tocIndex:16},{value:"appendChild",paraId:49,tocIndex:16},{value:" 将其加入画布才会被渲染",paraId:49,tocIndex:16},{value:"与 ",paraId:49,tocIndex:16},{value:"DOM API",paraId:49,tocIndex:16},{value:" 保持一致，不会拷贝原图形上的事件监听器",paraId:49,tocIndex:16},{value:"在这个",paraId:50,tocIndex:16},{value:"示例",paraId:51,tocIndex:16},{value:"中，我们展示了以上特性：",paraId:50,tocIndex:16},{value:"可以随时更改原始节点的样式属性，得到的拷贝都会是最新的，新节点同样需要被加入到场景图中才会被渲染",paraId:52,tocIndex:16},{value:"但由于不会拷贝事件监听器，因此只有原始节点可以进行拖拽",paraId:52,tocIndex:16},{value:"非深拷贝模式下，Text（Drag me 文本） 作为 Circle 的子节点不会被拷贝",paraId:52,tocIndex:16},{value:"判断传入的节点是否为该节点的后代节点。",paraId:53,tocIndex:17},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/contains",paraId:54,tocIndex:17},{value:"返回当前节点的根节点。如果已经被添加到画布中，会返回 canvas.document 例如：",paraId:55,tocIndex:18},{value:"circle.getRootNode(); // circle\ncanvas.appendChild(circle);\ncircle.getRootNode(); // canvas.document\n",paraId:56,tocIndex:18},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/getRootNode",paraId:57,tocIndex:18},{value:"返回指定层次的祖先节点，例如：",paraId:58,tocIndex:19},{value:"circle.getAncestor(2); // circle.parentNode.parentNode\n",paraId:59,tocIndex:19},{value:"如果向上查找超出了根节点，则返回 null：",paraId:60,tocIndex:19},{value:"circle.getAncestor(100); // null\n",paraId:61,tocIndex:19},{value:"是否有子节点。",paraId:62,tocIndex:20},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/hasChildNodes",paraId:63,tocIndex:20},{value:"完整方法签名为：",paraId:64,tocIndex:21},{value:"insertBefore(child: Node, reference?: Node): Node\n",paraId:65,tocIndex:21},{value:"在参考节点之前插入一个拥有指定父节点的子节点。如果给定的子节点是对文档中现有节点的引用，insertBefore() 会将其从当前位置移动到新位置（在将节点附加到其他节点之前，不需要从其父节点删除该节点）。",paraId:66,tocIndex:21},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/insertBefore",paraId:67,tocIndex:21},{value:"完整方法签名为：",paraId:68,tocIndex:22},{value:"removeChild(child: Node): Node\n",paraId:69,tocIndex:22},{value:"删除一个子节点，返回被删除的子节点，但不会销毁这个子节点，因此可以重新添加回来。",paraId:70,tocIndex:22},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/removeChild",paraId:71,tocIndex:22},{value:"用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点。",paraId:72,tocIndex:23},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/replaceChild",paraId:73,tocIndex:23},{value:"判断两个节点是否相等。",paraId:74,tocIndex:24},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/isEqualNode",paraId:75,tocIndex:24},{value:"比较两个节点在场景图中的位置。",paraId:76,tocIndex:25},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition",paraId:77,tocIndex:25},{value:"例如自己和自己比较返回 0：",paraId:78,tocIndex:25},{value:"const group1 = new Element();\nexpect(group1.compareDocumentPosition(group1)).to.eqls(0);\n",paraId:79,tocIndex:25},{value:"和另一个无共同祖先的节点比较：",paraId:80,tocIndex:25},{value:"const group1 = new Element();\nconst group2 = new Element();\nexpect(group1.compareDocumentPosition(group2)).to.eqls(\n    Node.DOCUMENT_POSITION_DISCONNECTED |\n        Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n        Node.DOCUMENT_POSITION_PRECEDING,\n);\n",paraId:81,tocIndex:25},{value:"父子节点：",paraId:82,tocIndex:25},{value:"group1.appendChild(group2);\nexpect(group1.compareDocumentPosition(group2)).to.eqls(\n    Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING,\n);\nexpect(group2.compareDocumentPosition(group1)).to.eqls(\n    Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING,\n);\n",paraId:83,tocIndex:25},{value:"兄弟节点：",paraId:84,tocIndex:25},{value:"// 1 -> 2\n// 1 -> 4\ngroup1.appendChild(group2);\ngroup1.appendChild(group4);\nexpect(group2.compareDocumentPosition(group4)).to.eqls(\n    Node.DOCUMENT_POSITION_PRECEDING,\n);\nexpect(group4.compareDocumentPosition(group2)).to.eqls(\n    Node.DOCUMENT_POSITION_FOLLOWING,\n);\n",paraId:85,tocIndex:25},{value:"枚举值如下：",paraId:86,tocIndex:25},{value:"static DOCUMENT_POSITION_DISCONNECTED = 1;\nstatic DOCUMENT_POSITION_PRECEDING = 2;\nstatic DOCUMENT_POSITION_FOLLOWING = 4;\nstatic DOCUMENT_POSITION_CONTAINS = 8;\nstatic DOCUMENT_POSITION_CONTAINED_BY = 16;\nstatic DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;\n",paraId:87,tocIndex:25}]},71640:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(32897);const d=[{value:"我们提供了一系列工具方法，供核心以及插件使用，例如：",paraId:0},{value:"import { convertToPath } from '@antv/g';\n",paraId:1},{value:"主要涉及不同角度单位之间的换算。",paraId:2,tocIndex:0},{value:"角度转换到弧度。",paraId:3,tocIndex:1},{value:"deg2rad(deg: number): number;\n",paraId:4,tocIndex:1},{value:"弧度转换到角度。",paraId:5,tocIndex:2},{value:"rad2deg(rad: number): number;\n",paraId:6,tocIndex:2},{value:"角度转换到圈数。",paraId:7,tocIndex:3},{value:"deg2turn(deg: number): number;\n",paraId:8,tocIndex:3},{value:"圈数转换到角度。",paraId:9,tocIndex:4},{value:"turn2deg(turn: number): number;\n",paraId:10,tocIndex:4},{value:"在绝大部分情况下，我们都可以使用图形自带的变换能力，内部通过 ",paraId:11,tocIndex:5},{value:"gl-matrix",paraId:11,tocIndex:5},{value:" 实现。",paraId:11,tocIndex:5},{value:"分解 3x3 变换矩阵，得到平移、缩放和旋转角度。",paraId:12,tocIndex:6},{value:"来自：",paraId:13,tocIndex:6},{value:"https://www.w3.org/TR/css-transforms-1/#decomposing-a-2d-matrix",paraId:13,tocIndex:6},{value:"const [tx, ty, scalingX, scalingY, angle] = decompose(mat3);\n",paraId:14,tocIndex:6},{value:"从 ",paraId:15,tocIndex:7},{value:"quat",paraId:15,tocIndex:7},{value:" 或者 ",paraId:15,tocIndex:7},{value:"mat4",paraId:15,tocIndex:7},{value:" 中获取欧拉角。方法签名如下：",paraId:15,tocIndex:7},{value:"getEuler(out: vec3, quat: quat | mat4): vec3\n",paraId:16,tocIndex:7},{value:"来自：",paraId:17,tocIndex:7},{value:"https://github.com/toji/gl-matrix/issues/329",paraId:17,tocIndex:7},{value:"创建 ",paraId:18,tocIndex:8},{value:"vec3",paraId:18,tocIndex:8},{value:"，接受多种类型参数。方法签名如下：",paraId:18,tocIndex:8},{value:"createVec3(x: number | vec2 | vec3 | vec4, y: number = 0, z: number = 0): vec3;\n",paraId:19,tocIndex:8},{value:"大部分涉及 path 的计算都依赖于 ",paraId:20,tocIndex:9},{value:"@antv/util",paraId:20,tocIndex:9},{value:"。",paraId:20,tocIndex:9},{value:"Morph 形变动画",paraId:21,tocIndex:10},{value:"是通过对 ",paraId:22,tocIndex:10},{value:"Path",paraId:23,tocIndex:10},{value:" 的 ",paraId:22,tocIndex:10},{value:"path/d",paraId:24,tocIndex:10},{value:" 属性进行插值实现的。",paraId:22,tocIndex:10},{value:"方法签名如下：",paraId:25,tocIndex:10},{value:"convertToPath(\n    object: Circle | Ellipse | Rect | Line | Polyline | Polygon | Path,\n    transform = object.getLocalTransform()\n): string;\n",paraId:26,tocIndex:10},{value:"该方法支持以下基础图形，不支持 ",paraId:27,tocIndex:10},{value:"Group",paraId:28,tocIndex:10},{value:" 或者其他自定义图形：",paraId:27,tocIndex:10},{value:"Circle",paraId:29,tocIndex:10},{value:"Ellipse",paraId:30,tocIndex:10},{value:"Rect",paraId:31,tocIndex:10},{value:"Line",paraId:32,tocIndex:10},{value:"Polyline",paraId:33,tocIndex:10},{value:"Polygon",paraId:34,tocIndex:10},{value:"Path",paraId:35,tocIndex:10},{value:"转换结果为字符串形式的三阶贝塞尔曲线，利用它易于分割的特性，将变换前后的路径规范到相同数目的分段，最后对各个分段中的控制点进行插值实现动画效果。",paraId:36,tocIndex:10},{value:"在转换过程中会考虑输入图形在局部坐标系下的变换（使用 ",paraId:37,tocIndex:10},{value:"transform",paraId:38,tocIndex:10},{value:" 进行的声明式变换或者",paraId:37,tocIndex:10},{value:"命令式的变换方法",paraId:39,tocIndex:10},{value:"），因此生成的路径定义已经包含了变换信息，可以直接基于该路径定义创建 ",paraId:37,tocIndex:10},{value:"Path",paraId:40,tocIndex:10},{value:"。",paraId:37,tocIndex:10},{value:"示例",paraId:41,tocIndex:10},{value:"：",paraId:37,tocIndex:10},{value:"const circle = new Circle({\n    style: {\n        cx: 100,\n        cy: 100,\n        r: 100,\n        transform: 'translate(20px, 20px)', // 声明式变换\n    },\n});\n// 对源图形应用变换，命令式\ncircle.translate(100, 0);\ncircle.scale(0.5);\n\n// 转换得到路径，已经包含了全部变换信息\nconst pathStr = convertToPath(circle);\n\n// 创建新图形\nconst circlePath = new Path({\n    style: {\n        d: pathStr,\n        fill: 'red',\n    },\n});\n\n// 不需要再进行以下变换\n// circlePath.translate(100, 0);\n",paraId:42,tocIndex:10},{value:"在某些情况下不需要考虑局部坐标系下的变换，可以传入第二个参数为 ",paraId:43,tocIndex:10},{value:"mat4.identity()",paraId:43,tocIndex:10},{value:"。",paraId:43,tocIndex:10}]},77632:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(82151);const d=[{value:"在相机坐标系中相机的三轴为 ",paraId:0},{value:"uvn",paraId:0},{value:"后面我们介绍的相机动作实际就是沿这三轴进行移动和旋转。",paraId:1},{value:"下图来自 Television Production Handbook p.97。早年的电视台使用的摄像机通过轨道完成移动：",paraId:2},{value:"我们不考虑依靠摇臂完成的 crane 和 tongue 动作，沿 uvn 三轴的平移和旋转可总结出以下动作：",paraId:3},{value:"动作名",paraId:4},{value:"相机位置",paraId:4},{value:"视点",paraId:4},{value:"u",paraId:4},{value:"v",paraId:4},{value:"n",paraId:4},{value:"dolly",paraId:4},{value:"平移",paraId:4},{value:"pedestal",paraId:4},{value:"平移",paraId:4},{value:"truck",paraId:4},{value:"平移",paraId:4},{value:"cant",paraId:4},{value:"旋转中心",paraId:4},{value:"旋转",paraId:4},{value:"pan",paraId:4},{value:"旋转中心",paraId:4},{value:"旋转",paraId:4},{value:"tilt",paraId:4},{value:"旋转中心",paraId:4},{value:"旋转",paraId:4},{value:"arc",paraId:4},{value:"旋转中心",paraId:4},{value:"旋转",paraId:4},{value:"很自然的，根据相机类型的不同，同一个摄像机动作对应的实现也不同。 我们以 ",paraId:5},{value:"dolly",paraId:6},{value:" 动作为例，同样都是一个向前向后移动摄像机位置的动作，对于 ",paraId:5},{value:"Orbiting",paraId:7},{value:" / ",paraId:5},{value:"Exploring",paraId:8},{value:" 模式视点不变，而在 ",paraId:5},{value:"Tracking",paraId:9},{value:" 模式下视点是需要调整的。",paraId:5},{value:"沿 u / v 轴，即水平和垂直方向平移相机。",paraId:10,tocIndex:0},{value:"方法签名如下：",paraId:11,tocIndex:0},{value:"pan(tx: number, ty: number)\n",paraId:12,tocIndex:0},{value:"参数：",paraId:13,tocIndex:0},{value:"tx",paraId:14,tocIndex:0},{value:" 沿 u 轴正向平移",paraId:14,tocIndex:0},{value:"ty",paraId:14,tocIndex:0},{value:" 沿 v 轴正向平移",paraId:14,tocIndex:0},{value:"在该",paraId:15,tocIndex:0},{value:"示例",paraId:16,tocIndex:0},{value:" 中，下面的操作将导致原本处于视点处的物体展示在左上角：",paraId:15,tocIndex:0},{value:"camera.pan(200, 200);\n",paraId:17,tocIndex:0},{value:"在 ",paraId:18,tocIndex:0},{value:"g-plugin-control",paraId:19,tocIndex:0},{value:" 中我们响应鼠标平移事件，调用该方法：",paraId:18,tocIndex:0},{value:"沿 n 轴移动相机。固定视点，改变相机位置从而改变视距。会保持视距在 ",paraId:20,tocIndex:1},{value:"minDistance",paraId:21,tocIndex:1},{value:" 和 ",paraId:20,tocIndex:1},{value:"maxDistance",paraId:22,tocIndex:1},{value:" 之间。",paraId:20,tocIndex:1},{value:"方法签名如下：",paraId:23,tocIndex:1},{value:"dolly(value: number)\n",paraId:24,tocIndex:1},{value:"参数：",paraId:25,tocIndex:1},{value:"value",paraId:26,tocIndex:1},{value:" 以 ",paraId:26,tocIndex:1},{value:"dollyingStep",paraId:26,tocIndex:1},{value:" 为单位，正向远离视点，负向靠近",paraId:26,tocIndex:1},{value:"使用示例：",paraId:27,tocIndex:1},{value:"camera.dolly(10); // 远离视点\ncamera.dolly(-10); // 靠近视点\n",paraId:28,tocIndex:1},{value:"在透视投影中效果如下，在 ",paraId:29,tocIndex:1},{value:"g-plugin-control",paraId:30,tocIndex:1},{value:" 中我们响应鼠标滚轮事件，调用该方法：",paraId:29,tocIndex:1},{value:"按相机方位角旋转，逆时针方向为正。",paraId:31,tocIndex:2},{value:"方法签名如下：",paraId:32,tocIndex:2},{value:"rotate(azimuth: number, elevation: number, roll: number)\n",paraId:33,tocIndex:2},{value:"2D 场景只需要指定 roll，例如让相机“歪下头”：",paraId:34,tocIndex:2},{value:"camera.rotate(0, 0, 30);\n",paraId:35,tocIndex:2}]},41665:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(54978);const d=[{value:'我们可以把相机当前的位置、视点记录下来，保存成一个"地标" Landmark。随后当相机参数发生改变时，可以随时切换到之前保存的任意一个 Landmark，同时带有平滑的切换动画，类似真实片场中的摄像机摇臂，在一些应用中也称作 ',paraId:0},{value:"flyTo",paraId:0},{value:"（例如 ",paraId:0},{value:"Mapbox 中的应用",paraId:0},{value:"），",paraId:0},{value:"示例",paraId:1},{value:"。",paraId:0},{value:"创建一个 Landmark，参数包括：",paraId:2,tocIndex:0},{value:"markName 名称",paraId:3,tocIndex:0},{value:"options 相机参数，包括：\n",paraId:3,tocIndex:0},{value:"position 世界坐标系下的相机位置，取值类型参考 ",paraId:4,tocIndex:0},{value:"setPosition",paraId:5,tocIndex:0},{value:"focalPoint 世界坐标系下的视点，取值类型参考 ",paraId:4,tocIndex:0},{value:"setFocalPoint",paraId:6,tocIndex:0},{value:"roll 旋转角度，取值类型参考 ",paraId:4,tocIndex:0},{value:"setRoll",paraId:7,tocIndex:0},{value:"zoom 缩放比例，取值类型参考 ",paraId:4,tocIndex:0},{value:"setZoom",paraId:8,tocIndex:0},{value:"camera.createLandmark('mark1', {\n    position: [300, 250, 400],\n    focalPoint: [300, 250, 0],\n});\ncamera.createLandmark('mark2', {\n    position: [300, 600, 500],\n    focalPoint: [300, 250, 0],\n});\ncamera.createLandmark('mark3', {\n    position: [0, 250, 800],\n    focalPoint: [300, 250, 0],\n    roll: 30,\n});\n",paraId:9,tocIndex:0},{value:"切换到之前保存的 Landmark，在 2D 和 3D 场景下都适用，",paraId:10,tocIndex:1},{value:"示例",paraId:11,tocIndex:1},{value:"：",paraId:10,tocIndex:1},{value:"camera.gotoLandmark('mark1', { duration: 300, easing: 'ease-in' });\n// or\ncamera.gotoLandmark(landmark, { duration: 300, easing: 'ease-in' });\n",paraId:12,tocIndex:1},{value:"参数列表如下：",paraId:13,tocIndex:1},{value:"markName 名称或者已创建的 Landmark",paraId:14,tocIndex:1},{value:"options 动画参数，包括：\n",paraId:14,tocIndex:1},{value:"duration 动画持续时间，单位为 ",paraId:15,tocIndex:1},{value:"ms",paraId:15,tocIndex:1},{value:"，默认值为 ",paraId:15,tocIndex:1},{value:"100",paraId:15,tocIndex:1},{value:"easing 缓动函数，默认值为 ",paraId:15,tocIndex:1},{value:"linear",paraId:15,tocIndex:1},{value:"。和动画系统一致的",paraId:15,tocIndex:1},{value:"内置效果",paraId:16,tocIndex:1},{value:"easingFunction 自定义缓动函数，当内置的缓动函数无法满足要求时，可以",paraId:15,tocIndex:1},{value:"自定义",paraId:17,tocIndex:1},{value:"onfinish 动画结束后的回调函数",paraId:15,tocIndex:1},{value:"和动画系统中的 ",paraId:18,tocIndex:1},{value:"options",paraId:19,tocIndex:1},{value:" 参数一样，传入 ",paraId:18,tocIndex:1},{value:"number",paraId:18,tocIndex:1},{value:" 时等同于设置 ",paraId:18,tocIndex:1},{value:"duration",paraId:18,tocIndex:1},{value:"：",paraId:18,tocIndex:1},{value:"camera.gotoLandmark('mark1', { duration: 300 });\ncamera.gotoLandmark('mark1', 300);\n",paraId:20,tocIndex:1},{value:"值得注意的是，如果在一个相机动画结束前调用另一个，进行中的动画将会立刻取消。",paraId:21,tocIndex:1}]},15845:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(95296);const d=[{value:"相机（Camera）描述了我们观察世界的角度。视点、相机位置都会影响最终的成像。在创建 ",paraId:0},{value:"Canvas",paraId:1},{value:" 画布时，已经内置了一个默认使用正交投影的相机。因此我们不需要手动创建它，可以通过如下方式获取：",paraId:0},{value:"const camera = canvas.getCamera();\n",paraId:2},{value:"通过操作相机我们可以很方便地实现很多效果，例如对整个画布进行平移和缩放。这在渲染性能上会有很大提升。",paraId:3},{value:"目前相机支持以下特性：",paraId:4},{value:"两种投影模式：正交投影 ",paraId:5},{value:"Orthographic",paraId:6},{value:" 和透视投影 ",paraId:5},{value:"Perspective",paraId:7},{value:"，默认使用前者。",paraId:5},{value:"三种相机类型：",paraId:5},{value:"Exploring",paraId:8},{value:"、",paraId:5},{value:"Orbiting",paraId:9},{value:" 和 ",paraId:5},{value:"Tracking",paraId:10},{value:"，默认使用 Exploring。",paraId:5},{value:"相机动作。例如 ",paraId:5},{value:"pan",paraId:11},{value:"、",paraId:5},{value:"dolly",paraId:12},{value:"、",paraId:5},{value:"rotate",paraId:13},{value:"自定义",paraId:5},{value:"相机动画",paraId:14},{value:"，创建/保存当前相机状态作为一个 Landmark，可在多个 Landmark 间平滑切换。",paraId:5},{value:"正交投影（左图）常用于 CAD 软件和策略类游戏（模拟人生）中。而透视投影（右图）遵循我们认知中的“近大远小”。 ",paraId:15,tocIndex:0},{value:"我们提供了以上两种投影模式：",paraId:16,tocIndex:0},{value:"enum CameraProjectionMode {\n  ORTHOGRAPHIC,\n  PERSPECTIVE,\n}\n",paraId:17,tocIndex:0},{value:"G 默认使用 ",paraId:18,tocIndex:1},{value:"CameraProjectionMode.ORTHOGRAPHIC",paraId:18,tocIndex:1},{value:"：",paraId:18,tocIndex:1},{value:"canvas.getCamera().getProjectionMode(); // CameraProjectionMode.ORTHOGRAPHIC\n",paraId:19,tocIndex:1},{value:"在 2D 场景中使用的都是正交投影，因此这也是 G 默认的投影模式。而在 3D 场景中，有时我们需要切换到透视投影，因此我们提供以下两个 API 来设置投影模式。",paraId:20,tocIndex:1},{value:"设置相机投影模式为正交投影 ",paraId:21,tocIndex:2},{value:"CameraProjectionMode.ORTHOGRAPHIC",paraId:21,tocIndex:2},{value:"方法签名如下：",paraId:22,tocIndex:2},{value:"setOrthographic(left: number, right: number,\n                top: number, bottom: number,\n                near: number, far: number)\n",paraId:23,tocIndex:2},{value:"参数列表如下：",paraId:24,tocIndex:2},{value:"left",paraId:25,tocIndex:2},{value:" x 轴负向最大距离",paraId:25,tocIndex:2},{value:"right",paraId:25,tocIndex:2},{value:" x 轴正向最大距离",paraId:25,tocIndex:2},{value:"top",paraId:25,tocIndex:2},{value:" y 轴正向最大距离",paraId:25,tocIndex:2},{value:"bottom",paraId:25,tocIndex:2},{value:" y 轴负向最大距离",paraId:25,tocIndex:2},{value:"near",paraId:25,tocIndex:2},{value:" 近平面",paraId:25,tocIndex:2},{value:"far",paraId:25,tocIndex:2},{value:" 远平面",paraId:25,tocIndex:2},{value:"G 的默认相机设置如下，其中 ",paraId:26,tocIndex:2},{value:"width/height",paraId:26,tocIndex:2},{value:" 为 ",paraId:26,tocIndex:2},{value:"Canvas",paraId:27,tocIndex:2},{value:" 的尺寸，",paraId:26,tocIndex:2},{value:"使用示例",paraId:28,tocIndex:2},{value:"：",paraId:26,tocIndex:2},{value:"const camera = new Camera()\n    .setPosition(width / 2, height / 2, 500)\n    .setFocalPoint(width / 2, height / 2, 0)\n    .setOrthographic(width / -2, width / 2, height / 2, height / -2, 0.1, 1000);\n",paraId:29,tocIndex:2},{value:"设置相机投影模式为透视投影 ",paraId:30,tocIndex:3},{value:"CameraProjectionMode.PERSPECTIVE",paraId:30,tocIndex:3},{value:"方法签名如下：",paraId:31,tocIndex:3},{value:"setPerspective(near: number, far: number, fov: number, aspect: number)\n",paraId:32,tocIndex:3},{value:"参数：",paraId:33,tocIndex:3},{value:"near",paraId:34,tocIndex:3},{value:" 近平面",paraId:34,tocIndex:3},{value:"far",paraId:34,tocIndex:3},{value:" 远平面",paraId:34,tocIndex:3},{value:"fov",paraId:34,tocIndex:3},{value:" 可视角度，越大意味着能容纳场景中的更多对象",paraId:34,tocIndex:3},{value:"aspect",paraId:34,tocIndex:3},{value:" 宽高比",paraId:34,tocIndex:3},{value:"使用示例",paraId:35,tocIndex:3},{value:"：",paraId:36,tocIndex:3},{value:"camera\n    .setPosition(300, 100, 500)\n    .setFocalPoint(300, 250, 0)\n    .setPerspective(0.1, 1000, 75, 600 / 500);\n",paraId:37,tocIndex:3},{value:"在 2D 场景中，如果我们想在场景中移动，通常会使用到平移和缩放。而在 3D 场景下不同的相机类型会带来不同的视觉效果。",paraId:38,tocIndex:4},{value:"左图是固定视点，移动相机位置来观测场景，多见于模型观察。而右图固定相机位置，调整视点观察场景中的所有物体。",paraId:39,tocIndex:4},{value:"我们提供了三种类型：",paraId:40,tocIndex:4},{value:"export enum CameraType {\n  ORBITING,\n  EXPLORING,\n  TRACKING,\n}\n\n",paraId:41,tocIndex:4},{value:"配合 ",paraId:42,tocIndex:4},{value:"g-plugin-control",paraId:43,tocIndex:4},{value:" 可以使用鼠标平移、缩放进行交互，",paraId:42,tocIndex:4},{value:"示例",paraId:44,tocIndex:4},{value:"。",paraId:42,tocIndex:4},{value:"固定视点 ",paraId:45,tocIndex:5},{value:"focalPoint",paraId:45,tocIndex:5},{value:"，改变相机位置 ",paraId:45,tocIndex:5},{value:"position",paraId:45,tocIndex:5},{value:"。常用于 CAD 观察模型这样的场景，但不能跨越南北极。",paraId:45,tocIndex:5},{value:"在 Three.js 中称作 ",paraId:46,tocIndex:5},{value:"OrbitControls",paraId:46,tocIndex:5},{value:"在该",paraId:47,tocIndex:5},{value:"示例",paraId:48,tocIndex:5},{value:"中，我们通过鼠标的平移控制相机完成 ",paraId:47,tocIndex:5},{value:"pan",paraId:49,tocIndex:5},{value:" 动作，仿佛是在让场景绕固定视点“旋转”。",paraId:47,tocIndex:5},{value:"类似 ",paraId:50,tocIndex:6},{value:"Orbiting",paraId:50,tocIndex:6},{value:" 模式，同样固定视点 ",paraId:50,tocIndex:6},{value:"focalPoint",paraId:50,tocIndex:6},{value:"，但可以跨越南北极。",paraId:50,tocIndex:6},{value:"G 的",paraId:51,tocIndex:6},{value:"默认相机",paraId:51,tocIndex:6},{value:"选择了该模式。",paraId:51,tocIndex:6},{value:"在 Three.js 中称作 ",paraId:52,tocIndex:6},{value:"TrackballControls",paraId:52,tocIndex:6},{value:"在该",paraId:53,tocIndex:6},{value:"示例",paraId:54,tocIndex:6},{value:"中，我们通过鼠标的平移控制相机完成 ",paraId:53,tocIndex:6},{value:"pan",paraId:55,tocIndex:6},{value:" 动作，让相机绕固定视点“旋转”。",paraId:53,tocIndex:6},{value:"固定相机位置 ",paraId:56,tocIndex:7},{value:"position",paraId:56,tocIndex:7},{value:" 绕其旋转，因此视点 ",paraId:56,tocIndex:7},{value:"focalPoint",paraId:56,tocIndex:7},{value:" 位置会发生改变。",paraId:56,tocIndex:7},{value:"在 Three.js 中称作 ",paraId:57,tocIndex:7},{value:"FirstPersonControls",paraId:57,tocIndex:7},{value:"随时可以在以上三种模式间切换：",paraId:58,tocIndex:8},{value:"camera.setType(CameraType.Tracking);\n",paraId:59,tocIndex:8}]},58891:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(53423);const d=[{value:"我们提供了以下方法获取或者修改相机位置、视点等常用的相机参数。",paraId:0},{value:"下图来自：",paraId:1},{value:"http://voxelent.com/tutorial-camera-landmarks/",paraId:1},{value:" 展示了相机位置 ",paraId:1},{value:"position",paraId:1},{value:" 和视点 ",paraId:1},{value:"focalPoint",paraId:1},{value:"：",paraId:1},{value:"获取相机在世界坐标系下的位置，类型为 ",paraId:2,tocIndex:0},{value:"[number, number, number]",paraId:2,tocIndex:0},{value:"。",paraId:2,tocIndex:0},{value:"camera.getPosition(); // [300, 200, 500]\n",paraId:3,tocIndex:0},{value:"设置相机在世界坐标系下的位置。",paraId:4,tocIndex:1},{value:"方法签名如下：",paraId:5,tocIndex:1},{value:"setPosition(x: number | vec2 | vec3, y?: number, z?: number)\n",paraId:6,tocIndex:1},{value:"在 G 内置的正交投影相机中，默认设置为 ",paraId:7,tocIndex:1},{value:"[width / 2, height / 2, 500]",paraId:7,tocIndex:1},{value:"，其中 ",paraId:7,tocIndex:1},{value:"width/height",paraId:7,tocIndex:1},{value:" 为 ",paraId:7,tocIndex:1},{value:"Canvas",paraId:8,tocIndex:1},{value:" 的尺寸。因此如果我们想重新设置相机的 ",paraId:7,tocIndex:1},{value:"x/y",paraId:7,tocIndex:1},{value:" 坐标，同时保持 ",paraId:7,tocIndex:1},{value:"z",paraId:7,tocIndex:1},{value:" 坐标不变，可以这么做：",paraId:7,tocIndex:1},{value:"// 保持 Z 坐标不变\ncamera.setPosition(300, 250);\ncamera.setPosition([300, 250]);\n// 或者设置 Z 坐标为默认值 500\ncamera.setPosition(300, 250, 500);\ncamera.setPosition([300, 250, 500]);\n",paraId:9,tocIndex:1},{value:"需要注意的是，在 2D 场景中当我们设置相机位置时，通常也需要一并设置视点位置，否则使用 ",paraId:10,tocIndex:1},{value:"g-webgl",paraId:10,tocIndex:1},{value:" 渲染时会出现非预期的效果：",paraId:10,tocIndex:1},{value:"camera.setPosition(100, 100, 500);\ncamera.setFocalPoint(100, 100, 0);\n",paraId:11,tocIndex:1},{value:"获取视点在世界坐标系下的位置，类型为 ",paraId:12,tocIndex:2},{value:"[number, number, number]",paraId:12,tocIndex:2},{value:"。",paraId:12,tocIndex:2},{value:"camera.getFocalPoint(); // [300, 200, 0]\n",paraId:13,tocIndex:2},{value:"设置视点在世界坐标系下的位置。",paraId:14,tocIndex:3},{value:"方法签名如下：",paraId:15,tocIndex:3},{value:"setFocalPoint(x: number | vec2 | vec3, y?: number, z?: number)\n",paraId:16,tocIndex:3},{value:"在 G 内置的正交投影相机中，默认设置为 ",paraId:17,tocIndex:3},{value:"[width / 2, height / 2, 0]",paraId:17,tocIndex:3},{value:"，其中 ",paraId:17,tocIndex:3},{value:"width/height",paraId:17,tocIndex:3},{value:" 为 ",paraId:17,tocIndex:3},{value:"Canvas",paraId:18,tocIndex:3},{value:" 的尺寸。因此如果我们想重新设置相机视点的 ",paraId:17,tocIndex:3},{value:"x/y",paraId:17,tocIndex:3},{value:" 坐标，同时保持 ",paraId:17,tocIndex:3},{value:"z",paraId:17,tocIndex:3},{value:" 坐标不变，可以这么做：",paraId:17,tocIndex:3},{value:"// 保持 Z 坐标不变\ncamera.setFocalPoint(300, 250);\ncamera.setFocalPoint([300, 250]);\n// 或者设置 Z 坐标为默认值 0\ncamera.setFocalPoint(300, 250, 0);\n// 或者设置 Z 坐标为默认值 0\ncamera.setFocalPoint([300, 250, 0]);\n",paraId:19,tocIndex:3},{value:"获取相机位置到视点的距离。",paraId:20,tocIndex:4},{value:"例如默认相机中：",paraId:21,tocIndex:4},{value:"camera.getDistance(); // 500\n",paraId:22,tocIndex:4},{value:"固定视点，沿 ",paraId:23,tocIndex:5},{value:"forward",paraId:23,tocIndex:5},{value:" 方向移动相机位置。",paraId:23,tocIndex:5},{value:"例如移动默认相机，固定视点位置，将视距从 ",paraId:24,tocIndex:5},{value:"500",paraId:24,tocIndex:5},{value:" 改成 ",paraId:24,tocIndex:5},{value:"400",paraId:24,tocIndex:5},{value:"：",paraId:24,tocIndex:5},{value:"camera.setDistance(400);\n",paraId:25,tocIndex:5},{value:"获取近平面。近平面内的图形将被剔除。",paraId:26,tocIndex:6},{value:"G 的默认相机设置为 ",paraId:27,tocIndex:6},{value:"0.1",paraId:27,tocIndex:6},{value:"：",paraId:27,tocIndex:6},{value:"camera.getNear(); // 0.1\n",paraId:28,tocIndex:6},{value:"设置近平面。",paraId:29,tocIndex:7},{value:"方法签名如下：",paraId:30,tocIndex:7},{value:"setNear(near: number)\n",paraId:31,tocIndex:7},{value:"获取远平面。远平面外的图形将被剔除。",paraId:32,tocIndex:8},{value:"G 的默认相机设置为 ",paraId:33,tocIndex:8},{value:"1000",paraId:33,tocIndex:8},{value:"：",paraId:33,tocIndex:8},{value:"camera.getFar(); // 1000\n",paraId:34,tocIndex:8},{value:"设置远平面。",paraId:35,tocIndex:9},{value:"方法签名如下：",paraId:36,tocIndex:9},{value:"setFar(far: number)\n",paraId:37,tocIndex:9},{value:"获取缩放比例。虽然从视觉效果上看，增大相机的缩放比例与调用根节点的 ",paraId:38,tocIndex:10},{value:"setScale",paraId:39,tocIndex:10},{value:" 相同，但显然前者并不会对场景中的图形造成任何改变。",paraId:38,tocIndex:10},{value:"默认缩放比例为 ",paraId:40,tocIndex:10},{value:"1",paraId:40,tocIndex:10},{value:"：",paraId:40,tocIndex:10},{value:"camera.getZoom(); // 1\n",paraId:41,tocIndex:10},{value:"zoom",paraId:42,tocIndex:11},{value:" 大于 1 代表放大，反之代表缩小，",paraId:42,tocIndex:11},{value:"示例",paraId:43,tocIndex:11},{value:"。",paraId:42,tocIndex:11},{value:"方法签名如下：",paraId:44,tocIndex:11},{value:"setZoom(zoom: number)\n",paraId:45,tocIndex:11},{value:"setZoom",paraId:46,tocIndex:12},{value:" 会以相机在世界坐标系下的位置为中心进行缩放。但有时我们希望固定视点，即以",paraId:47,tocIndex:12},{value:"视口坐标系",paraId:48,tocIndex:12},{value:"下的点为中心进行缩放。",paraId:47,tocIndex:12},{value:"在下面的",paraId:49,tocIndex:12},{value:"示例",paraId:50,tocIndex:12},{value:"中，我们监听了 ",paraId:49,tocIndex:12},{value:"wheel",paraId:49,tocIndex:12},{value:" 事件，以事件对象在 client 坐标系下的位置为中心进行缩放：",paraId:49,tocIndex:12},{value:"// 将 wheel 事件的 clientX/Y 转换到视口坐标系\nconst { x, y } = canvas.client2Viewport({ x: e.clientX, y: e.clientY });\ncamera.setZoomByViewportPoint(zoom, [x, y]);\n",paraId:51,tocIndex:12},{value:"方法签名如下：",paraId:52,tocIndex:12},{value:"zoom",paraId:53,tocIndex:12},{value:" 大于 1 代表放大，反之代表缩小。",paraId:53,tocIndex:12},{value:"viewportPoint",paraId:53,tocIndex:12},{value:" 为",paraId:53,tocIndex:12},{value:"视口坐标系",paraId:54,tocIndex:12},{value:"下的点坐标。",paraId:53,tocIndex:12},{value:"setZoomByViewportPoint(zoom: number, viewportPoint: vec2)\n",paraId:55,tocIndex:12},{value:"仅透视投影下生效，视角越大容纳的对象越多。",paraId:56,tocIndex:13},{value:"示例",paraId:57,tocIndex:13},{value:"方法签名如下：",paraId:58,tocIndex:13},{value:"setFov(fov: number)\n",paraId:59,tocIndex:13},{value:"仅透视投影下生效。大部分情况下不需要手动设置，当画布尺寸发生改变时可以通过调用 ",paraId:60,tocIndex:14},{value:"canvas.resize()",paraId:60,tocIndex:14},{value:" 自动更新。",paraId:60,tocIndex:14},{value:"方法签名如下：",paraId:61,tocIndex:14},{value:"setAspect(aspect: number)\n",paraId:62,tocIndex:14},{value:"设置最小视距。在进行 ",paraId:63,tocIndex:15},{value:"dolly",paraId:64,tocIndex:15},{value:" 操作时不会小于该距离。",paraId:63,tocIndex:15},{value:"默认值为 ",paraId:65,tocIndex:15},{value:"-Infinity",paraId:65,tocIndex:15},{value:"。",paraId:65,tocIndex:15},{value:"设置最大视距。在进行 ",paraId:66,tocIndex:16},{value:"dolly",paraId:67,tocIndex:16},{value:" 操作时不会大于该距离。",paraId:66,tocIndex:16},{value:"默认值为 ",paraId:68,tocIndex:16},{value:"Infinity",paraId:68,tocIndex:16},{value:"。",paraId:68,tocIndex:16},{value:"设置视口的偏移量，立刻重新计算投影矩阵。",paraId:69,tocIndex:17},{value:"方法签名为：",paraId:70,tocIndex:17},{value:"setViewOffset(\n  fullWidth: number,\n  fullHeight: number,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n)\n",paraId:71,tocIndex:17},{value:"其中 ",paraId:72,tocIndex:17},{value:"fullWidth/fullHeight",paraId:72,tocIndex:17},{value:" 为原始视口大小，",paraId:72,tocIndex:17},{value:"x/y",paraId:72,tocIndex:17},{value:" 为视口偏移坐标，",paraId:72,tocIndex:17},{value:"width/height",paraId:72,tocIndex:17},{value:" 为偏移后视口大小。",paraId:72,tocIndex:17},{value:"在该",paraId:73,tocIndex:17},{value:"示例",paraId:74,tocIndex:17},{value:"中，",paraId:73,tocIndex:17},{value:"Cube",paraId:75,tocIndex:17},{value:" 原本位于视口正中央，通过设置 ",paraId:73,tocIndex:17},{value:"x/y",paraId:73,tocIndex:17},{value:" 偏移量到视口中心。",paraId:73,tocIndex:17},{value:"在 ",paraId:76,tocIndex:17},{value:"g-plugin-device-renderer",paraId:77,tocIndex:17},{value:" 中拾取时，我们使用该方法设置偏移量（将相机对准拾取区域），仅渲染拾取区域而非整个屏幕以提高性能。",paraId:76,tocIndex:17},{value:"清除之前设置的视口偏移量，立刻重新计算投影矩阵。",paraId:78,tocIndex:18},{value:"在该",paraId:79,tocIndex:18},{value:"示例",paraId:80,tocIndex:18},{value:"中，点击按钮可以随时移除已设置的偏移量。",paraId:79,tocIndex:18},{value:"在描述旋转时，有时欧拉角理解起来要更直观，因为它更加贴近我们在日常生活中的描述，比如摄像机运动、水平坐标系（也称作地心坐标系）中的经纬度等等。在一些 GIS 类可视化项目（例如 Mapbox）中，经常使用 pitch/yaw/roll 来描述自身的旋转情况。例如下图中的一架飞机。",paraId:81,tocIndex:19},{value:"设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置。",paraId:82,tocIndex:19},{value:"设置绕 ",paraId:83,tocIndex:20},{value:"forward",paraId:83,tocIndex:20},{value:" 轴旋转的角度，单位为 ",paraId:83,tocIndex:20},{value:"deg",paraId:83,tocIndex:20},{value:"，方法签名如下：",paraId:83,tocIndex:20},{value:"setRoll(roll: number)\n",paraId:84,tocIndex:20},{value:"注意不同的",paraId:85,tocIndex:20},{value:"相机类型",paraId:86,tocIndex:20},{value:"下，固定相机位置和固定视点位置旋转的效果不同：",paraId:85,tocIndex:20},{value:"camera.setRoll(30);\n",paraId:87,tocIndex:20},{value:"设置 ",paraId:88,tocIndex:21},{value:"elevation",paraId:88,tocIndex:21},{value:" 角度，单位为 ",paraId:88,tocIndex:21},{value:"deg",paraId:88,tocIndex:21},{value:"，方法签名如下：",paraId:88,tocIndex:21},{value:"setElevation(angle: number)\n",paraId:89,tocIndex:21},{value:"注意不同的",paraId:90,tocIndex:21},{value:"相机类型",paraId:91,tocIndex:21},{value:"下，固定相机位置和固定视点位置旋转的效果不同：",paraId:90,tocIndex:21},{value:"camera.setElevation(30);\n",paraId:92,tocIndex:21},{value:"设置绕 ",paraId:93,tocIndex:22},{value:"azimuth",paraId:93,tocIndex:22},{value:" 角度，单位为 ",paraId:93,tocIndex:22},{value:"deg",paraId:93,tocIndex:22},{value:"，方法签名如下：",paraId:93,tocIndex:22},{value:"setAzimuth(angle: number)\n",paraId:94,tocIndex:22},{value:"注意不同的",paraId:95,tocIndex:22},{value:"相机类型",paraId:96,tocIndex:22},{value:"下，固定相机位置和固定视点位置旋转的效果不同：",paraId:95,tocIndex:22},{value:"camera.setAzimuth(30);\n",paraId:97,tocIndex:22}]},40353:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(28535);const d=[{value:"我们都知道浏览器中的 ",paraId:0},{value:"window",paraId:0},{value:" 对象，DOM 树的入口为 ",paraId:0},{value:"window.document",paraId:0},{value:"，而入口中通常会包含一个根节点 ",paraId:0},{value:"<html>",paraId:0},{value:" 元素，它可以通过 ",paraId:0},{value:"window.document.documentElement",paraId:0},{value:" 获得。我们向这个根节点下添加各种 DOM 元素，例如 ",paraId:0},{value:"<head>",paraId:0},{value:" ",paraId:0},{value:"<body>",paraId:0},{value:" 等。",paraId:0},{value:"Canvas 画布可以类比到 ",paraId:1},{value:"window",paraId:1},{value:" 对象。与之类似，每一个画布在创建时都内置了一个入口 ",paraId:1},{value:"Document",paraId:2},{value:"，可以通过 ",paraId:1},{value:"canvas.document",paraId:1},{value:" 获取。这个入口包含了",paraId:1},{value:"场景图",paraId:3},{value:"的根节点，这个根节点可以通过 ",paraId:1},{value:"canvas.document.documentElement",paraId:1},{value:" 获取，随后可以通过 ",paraId:1},{value:"appendChild",paraId:1},{value:" 向这个根节点中添加图形完成渲染。",paraId:1},{value:"返回一个内置的 ",paraId:4,tocIndex:0},{value:"Document",paraId:5,tocIndex:0},{value:" 对象，它拥有场景图的根节点。通过 ",paraId:4,tocIndex:0},{value:"document.documentElement",paraId:4,tocIndex:0},{value:" 获取到这个根节点后，可以使用场景图能力添加子节点：",paraId:4,tocIndex:0},{value:"// 向画布中添加一个 Circle\ncanvas.document.documentElement.appendChild(circle);\ncanvas.document.documentElement.children; // [circle]\n",paraId:6,tocIndex:0},{value:"除了添加/删除节点能力，其他场景图能力、事件能力也都可以在根节点上使用：",paraId:7,tocIndex:0},{value:"canvas.document.documentElement.getBounds(); // 获取当前场景包围盒大小\ncanvas.document.addEventListener('click', () => {}); // 绑定事件\n",paraId:8,tocIndex:0},{value:"getRoot()",paraId:9,tocIndex:1},{value:" 的别名，因此以下两种写法等价：",paraId:9,tocIndex:1},{value:"const root = canvas.getRoot();\nconst root = canvas.document.documentElement;\n",paraId:10,tocIndex:1},{value:"获取",paraId:11,tocIndex:2},{value:"渲染上下文",paraId:12,tocIndex:2},{value:"，由渲染器（",paraId:11,tocIndex:2},{value:"g-canvas/svg/webgl",paraId:11,tocIndex:2},{value:"）实现。该渲染上下文上有很多常用的方法，例如：",paraId:11,tocIndex:2},{value:"getDomElement() 返回上下文所处的 DOM 元素，例如 ",paraId:13,tocIndex:2},{value:"g-canvas/webgl",paraId:13,tocIndex:2},{value:" 会返回 ",paraId:13,tocIndex:2},{value:"<canvas>",paraId:13,tocIndex:2},{value:"，而 ",paraId:13,tocIndex:2},{value:"g-svg",paraId:13,tocIndex:2},{value:" 会返回 ",paraId:13,tocIndex:2},{value:"<svg>",paraId:13,tocIndex:2},{value:"getDPR() 返回上下文的 devicePixelRatio",paraId:13,tocIndex:2},{value:"获取",paraId:14,tocIndex:3},{value:"相机",paraId:15,tocIndex:3},{value:"，后续可对该相机进行操作，例如切换投影模式、完成相机动作和动画等。",paraId:14,tocIndex:3},{value:"const camera = canvas.getCamera();\n\n// 相机动作\ncamera.pan();\ncamera.rotate();\n\n// 切换透视投影模式\ncamera\n    .setPosition(300, 100, 500)\n    .setFocalPoint(300, 250, 0)\n    .setPerspective(0.1, 1000, 75, 600 / 500);\n",paraId:16,tocIndex:3}]},6230:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(39246);const d=[{value:"当我们说起“位置”，一定是相对于某个坐标系下而言，在 G 中我们会使用到 Client、Screen、Page、Canvas 以及 Viewport 坐标系，例如在",paraId:0},{value:"事件系统",paraId:1},{value:"中可以从事件对象上获取不同坐标系下的坐标：",paraId:0},{value:"canvas.addEventListener('click', (e) => {\n    e.clientX;\n    e.screenX;\n    e.pageX;\n    e.canvasX;\n    e.viewportX;\n});\n",paraId:2},{value:"在这些坐标系中，Client、Screen、Page 都是浏览器原生支持的坐标系，因此我们不会对事件对象上的这些坐标值做任何修改。而 Canvas 画布类似在浏览器中实现的一个“小浏览器”，因此它的视口坐标系即 Viewport 就可以类比成浏览器的 Client 坐标系。而当相机发生移动时，我们的可视范围随之改变，类似页面发生滚动，但图形在世界中的位置并没有改变，因此 Canvas 坐标系就可以类比成浏览器的 Page 坐标系。",paraId:3},{value:"这些坐标系都以左上角为原点： ",paraId:4},{value:"⚠️ 如果使用了 ",paraId:5},{value:"g-plugin-3d",paraId:6},{value:" 插件，Z 轴正向指向屏幕外。",paraId:5},{value:"我们提供了它们之间的转换方法，在这个",paraId:7},{value:"示例",paraId:8},{value:"中，移动鼠标可以看到鼠标所在位置在各个坐标系下的值：",paraId:7},{value:"Client <-> Viewport",paraId:9},{value:"Canvas <-> Viewport",paraId:9},{value:"前端开发者最熟悉的应该是 Client 浏览器坐标系，它以浏览器左上角为原点，G 不会修改原生事件对象的这个坐标值，",paraId:10,tocIndex:0},{value:"示例",paraId:10,tocIndex:0},{value:"。",paraId:10,tocIndex:0},{value:"https://developer.mozilla.org/en-US/Web/API/MouseEvent/clientX",paraId:11,tocIndex:0},{value:"如果文档没有滚动，等同于 Page 坐标，下图展示了与 Screen 的差别：",paraId:12,tocIndex:0},{value:"屏幕坐标系也是浏览器常用的坐标系，以屏幕左上角为原点，会受页面滚动影响。G 不会修改原生事件对象的这个坐标值。 ",paraId:13,tocIndex:1},{value:"https://developer.mozilla.org/en-US/Web/API/MouseEvent/screenX",paraId:13,tocIndex:1},{value:"值得一提的是，在双屏下可能会出现负数，例如在左侧屏幕中，",paraId:14,tocIndex:1},{value:"示例",paraId:14,tocIndex:1},{value:"：",paraId:14,tocIndex:1},{value:"以文档左上角为原点，考虑文档滚动，G 不会修改原生事件对象的这个坐标值。 ",paraId:15,tocIndex:2},{value:"https://developer.mozilla.org/en-US/Web/API/MouseEvent/pageX",paraId:15,tocIndex:2},{value:"可以类比浏览器的 Client 坐标系，也称作世界坐标系，我们在创建图形时指定的位置均相对于该坐标系。它以画布 DOM 元素的左上角为原点，X 轴正向指向屏幕右侧，Y 轴正向指向屏幕下方。也称作“世界坐标系”，涉及到旋转时，我们设定沿坐标轴正向顺时针为旋转方向。",paraId:16,tocIndex:3},{value:"在浏览器的 Page 坐标系中，不管页面如何滚动，元素在文档中的坐标都不会改变，改变的是我们的可视区域。",paraId:17,tocIndex:4},{value:"同样的，",paraId:18,tocIndex:4},{value:"相机",paraId:19,tocIndex:4},{value:"决定了我们观察世界的角度，如果相机没有发生移动，Viewport 视口坐标系和 Canvas 坐标系将完全重合，因此在我们的可见范围内，视口左上角坐标与 Canvas 坐标系原点一样，都是 ",paraId:18,tocIndex:4},{value:"[0, 0]",paraId:18,tocIndex:4},{value:"。但如果相机发生了平移、旋转、缩放，视口也会发生相应变化，此时视口左上角 ",paraId:18,tocIndex:4},{value:"[0, 0]",paraId:18,tocIndex:4},{value:" 对应 Canvas 坐标系下的位置就不再是 ",paraId:18,tocIndex:4},{value:"[0, 0]",paraId:18,tocIndex:4},{value:" 了。",paraId:18,tocIndex:4},{value:"我们提供以下转换方法需要使用到 Point，它的结构如下，可以从 G 核心包中引入，",paraId:20,tocIndex:5},{value:"示例",paraId:21,tocIndex:5},{value:"：",paraId:20,tocIndex:5},{value:"interface Point {\n    x: number;\n    y: number;\n}\n\nimport type { Point } from '@antv/g';\n",paraId:22,tocIndex:5},{value:'-Viewport type="button" class="ant-btn ant-btn-text ant-btn-icon-only button comment-link">',paraId:23},{value:"我们提供了从浏览器的 Client 坐标系到画布 Viewport 视口坐标系的转换方法，",paraId:24,tocIndex:6},{value:"示例",paraId:25,tocIndex:6},{value:"：",paraId:24,tocIndex:6},{value:"client2Viewport(client: Point): Point",paraId:26,tocIndex:6},{value:"viewport2Client(canvas: Point): Point",paraId:26,tocIndex:6},{value:"在内部实现中，我们使用了以下计算逻辑，例如从 Client 到 Viewport，首先获取画布 DOM 元素在 Client 坐标系下的包围盒，使用到了 ",paraId:27,tocIndex:6},{value:"getBoundingClientRect",paraId:27,tocIndex:6},{value:"，然后用 clientX/Y 减去包围盒左上角坐标，就得到了相对画布 DOM 元素左上角的坐标，即 Viewport 坐标：",paraId:27,tocIndex:6},{value:"// 获取画布 DOM 元素在 Client 坐标系下的包围盒\n// @see https://developer.mozilla.org/en-US/Web/API/Element/getBoundingClientRect\nconst bbox = $canvas.getBoundingClientRect();\n\nviewportX = clientX - bbox.left;\nviewportY = clientY - bbox.top;\n",paraId:28,tocIndex:6},{value:"例如 DOM 树中的 ",paraId:29,tocIndex:6},{value:"<canvas>",paraId:29,tocIndex:6},{value:" 元素通过绝对定位，处于距浏览器左上角 ",paraId:29,tocIndex:6},{value:"[100, 100]",paraId:29,tocIndex:6},{value:" 的位置，当鼠标移动到 ",paraId:29,tocIndex:6},{value:"<canvas>",paraId:29,tocIndex:6},{value:" 左上角 ",paraId:29,tocIndex:6},{value:"[0, 0]",paraId:29,tocIndex:6},{value:" 位置时，可以得到 Client 坐标为 ",paraId:29,tocIndex:6},{value:"[100, 100]",paraId:29,tocIndex:6},{value:"：",paraId:29,tocIndex:6},{value:"canvas.viewport2Client({ x: 0, y: 0 }); // Point { x: 100, y: 100 }\ncanvas.client2Viewport({ x: 100, y: 100 }); // Point { x: 0, y: 0 }\n",paraId:30,tocIndex:6},{value:"为了兼容旧版 G API，我们也提供了：",paraId:31,tocIndex:6},{value:"getPointByClient(clientX: number, clientY: number): Point",paraId:32,tocIndex:6},{value:"getClientByPoint(viewportX: number, viewportY: number): Point",paraId:32,tocIndex:6},{value:'-Viewport type="button" class="ant-btn ant-btn-text ant-btn-icon-only button comment-link">',paraId:23},{value:"相机",paraId:33,tocIndex:7},{value:"决定了我们观察世界的角度，如果相机没有发生移动，Viewport 视口坐标系和 Canvas 坐标系将完全重合，因此在我们的可见范围内，视口左上角坐标与 Canvas 坐标系原点一样，都是 ",paraId:34,tocIndex:7},{value:"[0, 0]",paraId:34,tocIndex:7},{value:"。但如果相机发生了平移、旋转、缩放，视口也会发生相应变化，此时视口左上角 ",paraId:34,tocIndex:7},{value:"[0, 0]",paraId:34,tocIndex:7},{value:" 对应 Canvas 坐标系下的位置就不再是 ",paraId:34,tocIndex:7},{value:"[0, 0]",paraId:34,tocIndex:7},{value:" 了。",paraId:34,tocIndex:7},{value:"在",paraId:35,tocIndex:7},{value:"示例",paraId:36,tocIndex:7},{value:"中，我们将相机向上移动了一段距离（整个世界在观察者眼中向下移动），可以发现圆心在 Canvas 坐标系下位置不变，仍然为 ",paraId:35,tocIndex:7},{value:"[300, 200]",paraId:35,tocIndex:7},{value:"，但在 Viewport 坐标系下发生了偏移：",paraId:35,tocIndex:7},{value:"我们提供了以下转换方法：",paraId:37,tocIndex:7},{value:"viewport2Canvas(viewport: Point): Point",paraId:38,tocIndex:7},{value:"canvas2Viewport(canvas: Point): Point",paraId:38,tocIndex:7},{value:"在内部实现中，我们使用了以下计算逻辑，例如从 Canvas 到 Viewport，经历从世界坐标系到裁剪坐标系，再到 NDC，最后到视口坐标系的变换：",paraId:39,tocIndex:7},{value:"// 计算相机 VP 矩阵\nconst camera = canvas.getCamera();\nconst projectionMatrix = camera.getPerspective();\nconst viewMatrix = camera.getViewTransform();\nconst vpMatrix = mat4.multiply(mat4.create(), projectionMatrix, viewMatrix);\n\n// 世界坐标系（Canvas） -> 裁剪坐标系（Clip）\nconst clip = vec3.fromValues(canvasX, canvasY, 0);\nvec3.transformMat4(clip, clip, vpMatrix);\n\n// Clip -> NDC -> Viewport 同时翻转 Y 轴\nconst { width, height } = this.canvasConfig; // 画布宽高\nviewportX = ((clip[0] + 1) / 2) * width;\nviewportY = (1 - (clip[1] + 1) / 2) * height;\n",paraId:40,tocIndex:7}]},872:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(7857);const d=[{value:"通常我们建议使用 ",paraId:0},{value:"new Circle()",paraId:0},{value:" 这样的方式创建内置或者自定义图形，但我们也提供了类似 DOM ",paraId:0},{value:"CustomElementRegistry",paraId:0},{value:" API，可以使用 ",paraId:0},{value:"document.createElement",paraId:1},{value:" 创建完成注册的图形，因此以下写法等价：",paraId:0},{value:"import { Shape, Circle } from '@antv/g';\n\nconst circle = canvas.document.createElement(Shape.CIRCLE, {\n    style: { r: 100 },\n});\n\n// 或者\nconst circle = new Circle({ style: { r: 100 } });\n",paraId:2},{value:"canvas.customElements",paraId:3},{value:" 提供了以下方法。",paraId:3},{value:"完整方法签名为：",paraId:4,tocIndex:0},{value:"define(name: string, new (...any[]) => DisplayObject): void;\n",paraId:5,tocIndex:0},{value:"所有 G 的内置图形在画布初始化时都完成了注册，对于自定义图形，如果也想通过 createElement 的方法创建，也可以按如下方式完成注册：",paraId:6,tocIndex:0},{value:"import { MyCustomShape } from 'my-custom-shape';\ncanvas.customElements.define(MyCustomShape.tag, MyCustomShape);\n\nconst myCustomShape = canvas.document.createElement(MyCustomShape.tag, {});\n",paraId:7,tocIndex:0},{value:"完整方法签名为：",paraId:8,tocIndex:1},{value:"get(name: string): new (...any[]) => DisplayObject\n",paraId:9,tocIndex:1},{value:"根据图形注册时提供的字符串，返回构造函数：",paraId:10,tocIndex:1},{value:"import { Shape } from '@antv/g';\n\ncanvas.customElements.get(Shape.CIRCLE); // Circle constructor\n",paraId:11,tocIndex:1}]},96267:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(83873);const d=[{value:"在",paraId:0},{value:"事件系统",paraId:1},{value:"中，大部分事件都会冒泡直至画布。例如我们在如下简单场景下点击 Circle，可以查看事件的传播路径依次为：",paraId:0},{value:"Circle -> Group(canvas.document.documentElement) -> Document(canvas.document) -> Canvas：\n",paraId:2},{value:"canvas.addEventListener('click', (e) => {\n    e.propagationPath(); // [Circle, Group, Document, Canvas]\n});\n",paraId:3},{value:"在 Canvas 画布和画布根节点上都可以绑定事件：",paraId:4,tocIndex:0},{value:"// 在画布上绑定\ncanvas.addEventListener('click', () => {});\n\n// 在画布根节点上绑定\ncanvas.document.addEventListener('click', () => {});\n",paraId:5,tocIndex:0},{value:"更多事件相关操作详见",paraId:6,tocIndex:0},{value:"事件系统",paraId:7,tocIndex:0},{value:"画布在初始化、渲染前后会触发对应事件，目前可以监听以下画布相关事件：",paraId:8,tocIndex:1},{value:"export enum CanvasEvent {\n  READY = 'ready', // 画布相关服务准备就绪后触发\n  BEFORE_RENDER = 'beforerender', // 在每一帧渲染前触发\n  AFTER_RENDER = 'afterrender', // 在每一帧渲染后触发\n  BEFORE_DESTROY = 'beforedestroy', // 在销毁前触发\n  AFTER_DESTROY = 'afterdestroy', // 在销毁后触发\n  RESIZE = 'resize', // 在 resize 时触发\n}\n",paraId:9,tocIndex:1},{value:"例如我们在官网所有例子中展示实时帧率，该组件在每次渲染后更新，我们就可以通过监听 ",paraId:10,tocIndex:1},{value:"afterrender",paraId:10,tocIndex:1},{value:" 事件完成：",paraId:10,tocIndex:1},{value:"import { CanvasEvent } from '@antv/g';\n\ncanvas.addEventListener(CanvasEvent.AFTER_RENDER, () => {\n    stats.update();\n});\n// 或者\ncanvas.addEventListener('afterrender', () => {\n    stats.update();\n});\n",paraId:11,tocIndex:1},{value:"在浏览器中我们可以通过 ",paraId:12,tocIndex:2},{value:"window.onload",paraId:12,tocIndex:2},{value:" 获知包含 HTML 解析、样式解析、资源加载等页面初始化工作是否完成：",paraId:12,tocIndex:2},{value:"// @see https://javascript.info/onload-ondomcontentloaded\nwindow.onload = function () {\n    alert('Page loaded');\n};\n",paraId:13,tocIndex:2},{value:"同样在 G 中这些初始化工作也是异步的，我们也提供了类似的 ",paraId:14,tocIndex:2},{value:"ready",paraId:14,tocIndex:2},{value:" 事件。在初始化完成后可以进行场景图创建等工作：",paraId:14,tocIndex:2},{value:"canvas.addEventListener(CanvasEvent.READY, () => {\n    canvas.appendChild(circle);\n});\n// 或者\ncanvas.addEventListener('ready', () => {\n    canvas.appendChild(circle);\n});\n",paraId:15,tocIndex:2},{value:"除了监听 ",paraId:16,tocIndex:2},{value:"ready",paraId:16,tocIndex:2},{value:" 事件，还可以选择",paraId:16,tocIndex:2},{value:"等待 ready 这个 Promise",paraId:17,tocIndex:2},{value:"：",paraId:16,tocIndex:2},{value:"await canvas.ready;\ncanvas.appendChild(circle);\n",paraId:18,tocIndex:2}]},95939:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(86863);const d=[{value:"在同一个页面中，多个画布可以共存，即可以同时存在多个“平行世界”。但受限于底层渲染 API，例如 WebGL 只允许至多 8 个上下文。",paraId:0,tocIndex:0},{value:"示例",paraId:1,tocIndex:0},{value:"在该 ",paraId:2,tocIndex:1},{value:"示例",paraId:3,tocIndex:1},{value:" 中，我们自行创建 ",paraId:2,tocIndex:1},{value:"<canvas>",paraId:2,tocIndex:1},{value:" 元素，用它来创建画布：",paraId:2,tocIndex:1},{value:"const $canvas = document.createElement('canvas');\n$canvas.width = 600;\n$canvas.height = 500;\ndocument.getElementById('container').appendChild($canvas);\n\nconst canvas = new Canvas({\n    canvas: $canvas,\n    renderer: new CanvasRenderer(),\n});\n",paraId:4,tocIndex:1}]},4139:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(58046);const d=[{value:"我们在 G 核心包 ",paraId:0},{value:"@antv/g",paraId:0},{value:" 中提供了 Canvas 画布这一核心对象，从渲染的角度上看，它是一个在浏览器中实现的“小浏览器”，承载着以下三类对象：",paraId:0},{value:"场景图",paraId:1},{value:"。我们通过它描述场景中的各个图形及其层次关系。",paraId:2},{value:"相机",paraId:3},{value:"。我们通过它定义观察整个场景的角度。我们为每一个画布内置了一个默认使用正交投影的相机，后续可随时修改。",paraId:2},{value:"渲染器",paraId:4},{value:"。我们通过它指定画布使用何种底层技术来渲染场景。不同的渲染器有着不同的渲染能力，例如只有 ",paraId:2},{value:"g-webgl",paraId:5},{value:" 才能渲染 3D 图形。在 2D 场景下我们会尽力实现不同渲染器下一致的渲染效果。",paraId:2},{value:"在设计画布 API 时，我们参考了 DOM API，因此它们有着很多相似之处：",paraId:6},{value:"画布可以类比成浏览器环境中的 ",paraId:7},{value:"window",paraId:7},{value:" 对象。和 window 一样，在内部实现中我们也让画布继承了 ",paraId:7},{value:"EventTarget",paraId:8},{value:"。与 window 不同的是，在同一个页面中，多个画布可以共存，即可以同时存在多个“平行世界”。",paraId:7},{value:"在 DOM 树中页面的入口为 ",paraId:7},{value:"window.document",paraId:7},{value:"，在画布中为 ",paraId:7},{value:"canvas.document",paraId:7},{value:"。",paraId:7},{value:"在 DOM 树中根节点为 ",paraId:7},{value:"document.documentElement",paraId:7},{value:"，也就是 ",paraId:7},{value:"<html>",paraId:7},{value:"。在画布中同样可以通过 ",paraId:7},{value:"canvas.document.documentElement",paraId:7},{value:" 访问。",paraId:7},{value:"我们选择尽可能兼容 DOM API，一方面降低了前端使用者的记忆学习成本，另一方面可以充分利用现有的 Web 生态，例如可以无缝接入",paraId:9},{value:"现有的手势和拖拽库",paraId:10},{value:"。",paraId:9},{value:"对于非常规浏览器环境，我们也提供了例如 ",paraId:11},{value:"WebWorker 中使用 OffscreenCanvas",paraId:12},{value:"、",paraId:11},{value:"服务端渲染",paraId:13},{value:"等方案。",paraId:11},{value:"EventTarget",paraId:14}]},91646:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(38629);const d=[{value:"你可能看到过一些渲染引擎的应用：",paraId:0,tocIndex:0},{value:"Babylon.js ",paraId:1,tocIndex:0},{value:"https://doc.babylonjs.com/divingDeeper/scene/offscreenCanvas",paraId:1,tocIndex:0},{value:"Three.js ",paraId:1,tocIndex:0},{value:"https://r105.threejsfundamentals.org/threejs/lessons/threejs-offscreencanvas.html",paraId:1,tocIndex:0},{value:"我们在以下两个场景会使用到 OffscreenCanvas，主要利用 Worker 解放主线程压力：",paraId:2,tocIndex:0},{value:"GPGPU 配合 g-webgl 和 g-plugin-gpgpu 使用，例如上层的图分析算法库",paraId:3,tocIndex:0},{value:"g-webgl 在 Worker 中渲染，同步结果到主线程",paraId:3,tocIndex:0},{value:"在该 ",paraId:4,tocIndex:0},{value:"示例",paraId:5,tocIndex:0},{value:" 中我们演示了第二种用法，在主线程创建 ",paraId:4,tocIndex:0},{value:"<canvas>",paraId:4,tocIndex:0},{value:"，通过 ",paraId:4,tocIndex:0},{value:"transferControlToOffscreen()",paraId:4,tocIndex:0},{value:" 将控制权转移给 WebWorker，后续在 WebWorker 中完成渲染，将结果同步给主线程：",paraId:4,tocIndex:0},{value:"// 主线程\nconst $canvas = document.createElement('canvas') as HTMLCanvasElement;\nconst dpr = window.devicePixelRatio;\n$canvas.height = dpr * 600;\n$canvas.width = dpr * 500;\n$canvas.style.height = '600px';\n$canvas.style.width = '500px';\ndocument.getElementById('container').appendChild($canvas);\nconst offscreen = $canvas.transferControlToOffscreen();\n\n// 省略 Worker 创建过程\n\n// 在 WebWorker 中使用 OffscreenCanvas\nconst canvas = new Canvas({\n  canvas: offscreenCanvas, // 从主线程\n  devicePixelRatio,\n  renderer,\n});\n",paraId:6,tocIndex:0},{value:"值得注意的是事件交互。OffscreenCanvas 并不具备事件监听能力，我们的交互都发生在主线程的 ",paraId:7,tocIndex:0},{value:"<canvas>",paraId:7,tocIndex:0},{value:" 元素上，当鼠标点击事件被监听时，我们如何得知 OffscreenCanvas 中哪个图形命中了呢？",paraId:7,tocIndex:0},{value:"我们可以这样实现：",paraId:8,tocIndex:0},{value:"监听 ",paraId:9,tocIndex:0},{value:"<canvas>",paraId:9,tocIndex:0},{value:" 上的交互事件，触发后将事件通过 ",paraId:9,tocIndex:0},{value:"postMessage",paraId:9,tocIndex:0},{value:" 传递给 Worker。注意这里并不能直接传递类似 ",paraId:9,tocIndex:0},{value:"PointerEvent",paraId:9,tocIndex:0},{value:" 这样的原生事件对象，在序列化时会报如下错误。正确的做法是提取原生事件对象上的关键属性（例如 ",paraId:9,tocIndex:0},{value:"clientX/Y",paraId:9,tocIndex:0},{value:"）进行传递：",paraId:9,tocIndex:0},{value:"Uncaught (in promise) DOMException: Failed to execute 'postMessage' on 'Worker': PointerEvent object could not be cloned.\n",paraId:10,tocIndex:0},{value:"// 在主线程中监听 `<canvas>` 事件\n$canvas.addEventListener(\n    'pointerdown',\n    (e) => {\n        // 向 WebWorker 传递可序列化的事件对象\n        worker.triggerEvent('pointerdown', clonePointerEvent(e));\n    },\n    true,\n);\n",paraId:11,tocIndex:0},{value:"在 Worker 中触发 G 渲染服务提供的交互事件 hook，例如接收到主线程传来的 ",paraId:12,tocIndex:0},{value:"pointerdown",paraId:12,tocIndex:0},{value:" 信号时调用 ",paraId:12,tocIndex:0},{value:"pointerDown",paraId:12,tocIndex:0},{value:" hook：",paraId:12,tocIndex:0},{value:"export function triggerEvent(event, ev) {\n    if (event === 'pointerdown') {\n        canvas.getRenderingService().hooks.pointerDown.call(ev);\n    }\n}\n",paraId:13,tocIndex:0},{value:"cursor",paraId:14,tocIndex:0},{value:" 鼠标样式显然无法在 Worker 中应用。我们可以在拾取到图形时在 Worker 中通过 ",paraId:15,tocIndex:0},{value:"postMessage",paraId:15,tocIndex:0},{value:" 告知主线程修改 ",paraId:15,tocIndex:0},{value:"<canvas>",paraId:15,tocIndex:0},{value:" 上的鼠标样式。",paraId:15,tocIndex:0},{value:"依据不同的渲染器，我们提供了以下服务端渲染方案：",paraId:16,tocIndex:1},{value:"g-canvas + node-canvas",paraId:17,tocIndex:1},{value:"g-svg + JSDOM",paraId:18,tocIndex:1},{value:"g-webgl + headless-gl",paraId:19,tocIndex:1},{value:"目前我们在",paraId:20,tocIndex:1},{value:"集成测试",paraId:20,tocIndex:1},{value:"中使用它们。",paraId:20,tocIndex:1}]},23995:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(37248);const d=[{value:"在创建一个画布时，我们可以传入以下初始化参数，这也是最简单的初始化方式：",paraId:0},{value:"container",paraId:1},{value:" 画布容器的 id 或 DOM 元素，后续在该 DOM 元素内自动创建 ",paraId:1},{value:"<canvas>/<svg>",paraId:1},{value:"width / height",paraId:1},{value:" 画布宽度和高度",paraId:1},{value:"renderer",paraId:1},{value:" 渲染器，目前支持 ",paraId:1},{value:"g-canvas",paraId:2},{value:"、",paraId:1},{value:"g-svg",paraId:3},{value:"、",paraId:1},{value:"g-webgl",paraId:4},{value:" 等",paraId:1},{value:"以 ",paraId:5},{value:"g-canvas",paraId:6},{value:" 为例：",paraId:5},{value:"import { Canvas } from '@antv/g';\nimport { Renderer } from '@antv/g-canvas';\n\n// 创建渲染器\nconst renderer = new Renderer();\n\n// 创建画布\nconst canvas = new Canvas({\n    container: 'container', // 画布 DOM 容器 id\n    width: 600, // 画布宽度\n    height: 500, // 画布高度\n    renderer, // 指定渲染器\n});\n",paraId:7},{value:"以上初始化方式只需要提供一个承载 ",paraId:8},{value:"<canvas>/<svg>",paraId:8},{value:" 的容器 ",paraId:8},{value:"container",paraId:8},{value:"，但有时我们有如下自定义需求：",paraId:8},{value:"自行创建 ",paraId:9},{value:"<canvas>",paraId:9},{value:"，",paraId:9},{value:"详见",paraId:10},{value:"在 WebWorker 中使用 OffscreenCanvas，",paraId:9},{value:"详见",paraId:11},{value:"在 Node 端使用 node-canvas 进行服务端渲染，",paraId:9},{value:"详见",paraId:12},{value:"此时可以使用 ",paraId:13},{value:"canvas",paraId:13},{value:" 代替 ",paraId:13},{value:"container",paraId:13},{value:"，更多初始化参数如下。",paraId:13},{value:"可选，",paraId:14,tocIndex:0},{value:"string | HTMLElement",paraId:14,tocIndex:0},{value:"，画布容器的 id 或 DOM 元素。后续当渲染器初始化时，会在该容器 DOM 元素内自动创建 ",paraId:14,tocIndex:0},{value:"<canvas>/<svg>",paraId:14,tocIndex:0},{value:"。",paraId:14,tocIndex:0},{value:"可选，",paraId:15,tocIndex:1},{value:"HTMLCanvasElement | OffscreenCanvas | NodeCanvas",paraId:15,tocIndex:1},{value:"，已创建好的 ",paraId:15,tocIndex:1},{value:"<canvas>",paraId:15,tocIndex:1},{value:" 元素或者 OffscreenCanvas。",paraId:15,tocIndex:1},{value:"当传入此参数时，",paraId:16,tocIndex:1},{value:"container",paraId:17,tocIndex:1},{value:" 参数将被忽略，我们假定 ",paraId:16,tocIndex:1},{value:"<canvas>",paraId:16,tocIndex:1},{value:" 已经创建完毕并且加入到文档中，例如：",paraId:16,tocIndex:1},{value:"// 用户自行创建 <canvas>\nconst $canvas = document.createElement('canvas');\n// 设置画布大小\nconst dpr = window.devicePixelRatio;\n$canvas.height = dpr * 600;\n$canvas.width = dpr * 500;\n$canvas.style.height = '600px';\n$canvas.style.width = '500px';\n// 用户自行将 <canvas> 加入文档\ndocument.getElementById('container').appendChild($canvas);\n\n// 使用创建好的 <canvas> 创建画布\nconst canvas = new Canvas({\n    canvas: $canvas,\n    renderer: canvasRenderer,\n});\n",paraId:18,tocIndex:1},{value:"除了浏览器环境下的 ",paraId:19,tocIndex:1},{value:"HTMLCanvasElement",paraId:19,tocIndex:1},{value:"，还可以使用：",paraId:19,tocIndex:1},{value:"OffscreenCanvas",paraId:20,tocIndex:1},{value:" 在 WebWorker 中运行，",paraId:20,tocIndex:1},{value:"详见",paraId:21,tocIndex:1},{value:"NodeCanvas",paraId:20,tocIndex:1},{value:" 在 Node 端使用 node-canvas 进行服务端渲染，",paraId:20,tocIndex:1},{value:"详见",paraId:22,tocIndex:1},{value:"需要注意的是，一旦使用了该参数，就不再支持运行时切换渲染器了。",paraId:23,tocIndex:1},{value:"画布宽高。",paraId:24,tocIndex:2},{value:"如果设置了 ",paraId:25,tocIndex:2},{value:"container",paraId:26,tocIndex:2},{value:"，必填。渲染器创建 ",paraId:25,tocIndex:2},{value:"<canvas>",paraId:25,tocIndex:2},{value:" 时将使用传入的宽高设置。",paraId:25,tocIndex:2},{value:"如果设置了 ",paraId:25,tocIndex:2},{value:"canvas",paraId:27,tocIndex:2},{value:"，选填。如果不填写，将使用 ",paraId:25,tocIndex:2},{value:"canvas.width/height",paraId:25,tocIndex:2},{value:" 与 ",paraId:25,tocIndex:2},{value:"devicePixelRatio",paraId:25,tocIndex:2},{value:" 计算。",paraId:25,tocIndex:2},{value:"必填，目前支持以下渲染器:",paraId:28,tocIndex:3},{value:"基于 Canvas2D 的 ",paraId:29,tocIndex:3},{value:"g-canvas",paraId:30,tocIndex:3},{value:"基于 CanvasKit 的 ",paraId:29,tocIndex:3},{value:"g-canvaskit",paraId:31,tocIndex:3},{value:"基于 SVG 的 ",paraId:29,tocIndex:3},{value:"g-svg",paraId:32,tocIndex:3},{value:"基于 WebGL 2/1 的 ",paraId:29,tocIndex:3},{value:"g-webgl",paraId:33,tocIndex:3},{value:"基于 WebGPU 的 ",paraId:29,tocIndex:3},{value:"g-webgpu",paraId:34,tocIndex:3},{value:"后续可以在运行时通过 ",paraId:35,tocIndex:3},{value:"setRenderer()",paraId:36,tocIndex:3},{value:" 切换。",paraId:35,tocIndex:3},{value:"选填，画布初始化时用于清除的颜色。类似 WebGL 中的 ",paraId:37,tocIndex:4},{value:"clearColor",paraId:37,tocIndex:4},{value:"。",paraId:37,tocIndex:4},{value:"支持 ",paraId:38,tocIndex:4},{value:"<color>",paraId:39,tocIndex:4},{value:" 取值，默认值为 ",paraId:38,tocIndex:4},{value:"'transparent'",paraId:38,tocIndex:4},{value:"。",paraId:38,tocIndex:4},{value:"在该",paraId:40,tocIndex:4},{value:"示例",paraId:41,tocIndex:4},{value:"中，我们为 Canvas 设置了一个半透明的红色，而最底层的 ",paraId:40,tocIndex:4},{value:"<div>",paraId:40,tocIndex:4},{value:" 通过 CSS 设置了背景灰色：",paraId:40,tocIndex:4},{value:"选填，设置画布默认的",paraId:42,tocIndex:5},{value:"鼠标样式",paraId:43,tocIndex:5},{value:"。如果通过交互事件拾取到的图形之上也配置了该属性，会覆盖掉画布上配置的鼠标样式，但当鼠标移动到空白区域时，画布上配置的鼠标样式就会生效了。下图展示了这一点：",paraId:42,tocIndex:5},{value:"const canvas = new Canvas({\n    //...\n    cursor: 'crosshair',\n});\n\nconst circle = new Circle({\n    style: {\n        //...\n        cursor: 'pointer',\n    },\n});\n",paraId:44,tocIndex:5},{value:"除了在画布初始化时设置，后续还可以通过 ",paraId:45,tocIndex:5},{value:"setCursor()",paraId:45,tocIndex:5},{value:" 修改：",paraId:45,tocIndex:5},{value:"// 画布初始化时设置\ncanvas = new Canvas({\n    //...\n    cursor: 'crosshair',\n});\n\n// 或者后续修改\ncanvas.setCursor('crosshair');\n",paraId:46,tocIndex:5},{value:"可选。是否支持一个 container 下容纳多个画布，默认为 false。",paraId:47,tocIndex:6},{value:"示例",paraId:48},{value:"6.1.1",paraId:49},{value:"boolean",paraId:50,tocIndex:7},{value:"可选，默认为 ",paraId:51,tocIndex:7},{value:"false",paraId:51,tocIndex:7},{value:"。开启高分辨率大图渲染与交互优化，通过降采样与切片渲染策略使得上亿像素的大图也能流畅渲染和交互。",paraId:51,tocIndex:7},{value:"目前仅在原生 Canvas 渲染器中实现。",paraId:52},{value:"在一些特殊的运行平台（例如小程序）上，无法正常使用类似 ",paraId:53,tocIndex:8},{value:"globalThis",paraId:53,tocIndex:8},{value:" 这样的全局变量，而在内部我们又需要依靠它创建图片（",paraId:53,tocIndex:8},{value:"new globalThis.Image()",paraId:53,tocIndex:8},{value:"）、判断是否支持 TouchEvent（",paraId:53,tocIndex:8},{value:"'ontouchstart' in globalThis",paraId:53,tocIndex:8},{value:"）等。因此需要这些特殊平台的使用者手动传入特有的创建以及判断方式。",paraId:53,tocIndex:8},{value:"可选。默认将使用 ",paraId:54,tocIndex:9},{value:"window.document",paraId:54,tocIndex:9},{value:"。在",paraId:54,tocIndex:9},{value:"基于 g-svg 的服务端渲染方案",paraId:55,tocIndex:9},{value:"中，需要将 ",paraId:54,tocIndex:9},{value:"window.document",paraId:54,tocIndex:9},{value:" 替换成 ",paraId:54,tocIndex:9},{value:"JSDOM",paraId:54,tocIndex:9},{value:" 提供的对应元素，以便创建对应 SVG 元素。",paraId:54,tocIndex:9},{value:"可选。默认将使用 ",paraId:56,tocIndex:10},{value:"window.devicePixelRatio",paraId:56,tocIndex:10},{value:"，如果运行环境中无 ",paraId:56,tocIndex:10},{value:"window",paraId:56,tocIndex:10},{value:" 对象，例如 WebWorker 中，可以手动传入，如果仍未传入则使用 1。",paraId:56,tocIndex:10},{value:"可选。默认将使用 ",paraId:57,tocIndex:11},{value:"window.requestAnimationFrame",paraId:57,tocIndex:11},{value:"，如果运行环境中无 ",paraId:57,tocIndex:11},{value:"window",paraId:57,tocIndex:11},{value:" 对象，例如小程序环境，可以手动传入。",paraId:57,tocIndex:11},{value:"可选。默认将使用 ",paraId:58,tocIndex:12},{value:"window.cancelAnimationFrame",paraId:58,tocIndex:12},{value:"，如果运行环境中无 ",paraId:58,tocIndex:12},{value:"window",paraId:58,tocIndex:12},{value:" 对象，例如小程序环境，可以手动传入。",paraId:58,tocIndex:12},{value:"可选。返回一个 ",paraId:59,tocIndex:13},{value:"HTMLImageElement",paraId:59,tocIndex:13},{value:" 或类似对象，默认将使用 ",paraId:59,tocIndex:13},{value:"() => new window.Image()",paraId:59,tocIndex:13},{value:" 创建，如果运行环境中无 ",paraId:59,tocIndex:13},{value:"window",paraId:59,tocIndex:13},{value:" 对象，例如小程序环境，可以手动传入。",paraId:59,tocIndex:13},{value:"例如支付宝小程序中使用 ",paraId:60,tocIndex:13},{value:"createImage",paraId:60,tocIndex:13},{value:"：",paraId:60,tocIndex:13},{value:"const canvas = new Canvas({\n    // 省略其他参数\n    createImage: () => canvas.createImage(),\n});\n",paraId:61,tocIndex:13},{value:"可选。是否支持在容器上应用 CSS Transform 的情况下确保交互事件坐标转换正确。",paraId:62,tocIndex:14},{value:"在该 ",paraId:63,tocIndex:14},{value:"示例",paraId:64,tocIndex:14},{value:" 中，我们将容器放大了 1.1 倍，开启该配置项后，鼠标移动到圆上可以正确变化鼠标样式：",paraId:63,tocIndex:14},{value:"const $wrapper = document.getElementById('container');\n$wrapper.style.transform = 'scale(1.1)';\n",paraId:65,tocIndex:14},{value:"可选。是否支持 PointerEvent，默认将使用 ",paraId:66,tocIndex:15},{value:"!!globalThis.PointerEvent",paraId:66,tocIndex:15},{value:" 判断。如果传入 ",paraId:66,tocIndex:15},{value:"false",paraId:66,tocIndex:15},{value:"，事件监听插件将不会监听例如 ",paraId:66,tocIndex:15},{value:"pointerdown",paraId:66,tocIndex:15},{value:" 等 PointerEvent。",paraId:66,tocIndex:15},{value:"可选。是否支持 TouchEvent。如果传入 ",paraId:67,tocIndex:16},{value:"false",paraId:67,tocIndex:16},{value:"，事件监听插件将不会监听例如 ",paraId:67,tocIndex:16},{value:"touchstart",paraId:67,tocIndex:16},{value:" 等 TouchEvent。",paraId:67,tocIndex:16},{value:"可选。判断一个原生事件是否是 TouchEvent，接受原生事件作为参数，返回判定结果。",paraId:68,tocIndex:17},{value:"可选。判断一个原生事件是否是 MouseEvent，接受原生事件作为参数，返回判定结果。",paraId:69,tocIndex:18},{value:"6.0.12",paraId:70,tocIndex:18},{value:"number",paraId:71,tocIndex:19},{value:"可选，默认为 200ms。判断两次连续点击是否触发双击事件 ",paraId:72,tocIndex:19},{value:"dblclick",paraId:72,tocIndex:19},{value:" 的速度。",paraId:72,tocIndex:19},{value:"可选。返回一个 ",paraId:73,tocIndex:20},{value:"HTMLCanvasElement | OffscreenCanvas",paraId:73,tocIndex:20},{value:" 或类似对象。用于生成一个离屏的 Canvas2D 上下文，目前它使用在以下场景：",paraId:73,tocIndex:20},{value:"g 绘制并调用 ",paraId:74,tocIndex:20},{value:"ctx.measureText",paraId:74,tocIndex:20},{value:" 度量文本",paraId:74,tocIndex:20},{value:"g-plugin-canvas-picker",paraId:75,tocIndex:20},{value:" 会在上下文中绘制一遍路径，再调用 ",paraId:74,tocIndex:20},{value:"ctx.isPointInPath",paraId:74,tocIndex:20},{value:" Canvas2D API",paraId:74,tocIndex:20},{value:"g-plugin-device-renderer",paraId:76,tocIndex:20},{value:" 会在上下文中调用 ",paraId:74,tocIndex:20},{value:"ctx.createLinearGradient",paraId:74,tocIndex:20},{value:" 绘制渐变，再生成纹理",paraId:74,tocIndex:20},{value:"默认不传入时会尝试创建 ",paraId:77,tocIndex:20},{value:"OffscreenCanvas",paraId:77,tocIndex:20},{value:"，失败后再使用 DOM API 创建一个 ",paraId:77,tocIndex:20},{value:"HTMLCanvasElement",paraId:77,tocIndex:20},{value:"。但在小程序这样非 DOM 环境中，需要手动传入：",paraId:77,tocIndex:20},{value:"const canvas = new Canvas({\n    // 省略其他参数\n    offscreenCanvas: {\n        // 小程序中创建上下文方法\n        getContext: () => Canvas.createContext(),\n    },\n});\n",paraId:78,tocIndex:20},{value:"在初始化画布时我们传入了画布尺寸、渲染器等配置，后续可能对它们进行修改，因此我们提供了以下 API。",paraId:79,tocIndex:21},{value:"有时我们需要在初始化之后调整画布尺寸，传入新的画布宽度和高度。方法签名如下：",paraId:80,tocIndex:22},{value:"resize(width: number, height: number): void;\n",paraId:81,tocIndex:22},{value:"例如使用 ",paraId:82,tocIndex:22},{value:"ResizeObserver",paraId:82,tocIndex:22},{value:" 监听容器尺寸变化：",paraId:82,tocIndex:22},{value:"const resizeObserver = new ResizeObserver((entries) => {\n    for (const entry of entries) {\n        if (entry !== canvas) {\n            continue;\n        }\n        const { width, height } = entry.contentRect;\n        // resize canvas\n        canvas.resize(width, height);\n    }\n});\nresizeObserver.observe($container);\n",paraId:83,tocIndex:22},{value:"在绝大部分场景下我们都应该在画布初始化时指定一个渲染器，后续再也不会更改。但也有小部分场景需要在运行时",paraId:84,tocIndex:23},{value:"切换渲染器",paraId:85,tocIndex:23},{value:"，例如 G 官网中几乎所有的示例都是这样做的：",paraId:84,tocIndex:23},{value:"// 当图元数目很多时切换到 WebGL 渲染器\nif (tooManyShapes) {\n    canvas.setRenderer(webglRenderer);\n} else {\n    canvas.setRenderer(svgRenderer);\n}\n",paraId:86,tocIndex:23},{value:"方法签名如下：",paraId:87,tocIndex:23},{value:"setRenderer(renderer: Renderer): Promise<void>;\n",paraId:88,tocIndex:23},{value:"需要注意的是，在切换渲染器时需要重新初始化渲染环境，因此该方法为异步方法。",paraId:89,tocIndex:23},{value:"修改画布默认的",paraId:90,tocIndex:24},{value:"鼠标样式",paraId:91,tocIndex:24},{value:"。",paraId:90,tocIndex:24},{value:"canvas.setCursor('crosshair');\n",paraId:92,tocIndex:24},{value:"获取初始传入画布的配置。",paraId:93,tocIndex:25},{value:"const canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer: webglRenderer,\n});\ncanvas.getConfig(); // { container: 'container', width: 600, ... }\n",paraId:94,tocIndex:25}]},64603:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(92223);const d=[{value:"由于画布并没有继承 ",paraId:0,tocIndex:0},{value:"Node",paraId:1,tocIndex:0},{value:"，因此它本身并不具备节点操作能力。但我们增加了一些快捷方式，以下节点操作本质上都是在根节点上完成的，例如以下两种写法等价：",paraId:0,tocIndex:0},{value:"canvas.appendChild(circle);\ncanvas.document.documentElement.appendChild(circle);\n",paraId:2,tocIndex:0},{value:"向画布中添加待渲染对象。如果该对象有子节点也会一并加入。",paraId:3,tocIndex:1},{value:"const circle = new Circle({ style: { r: 10 } });\n\ncanvas.appendChild(circle);\n// or canvas.document.documentElement.appendChild(circle);\n",paraId:4,tocIndex:1},{value:"方法签名如下：",paraId:5,tocIndex:1},{value:"appendChild(object: DisplayObject): DisplayObject;\n",paraId:6,tocIndex:1},{value:"从画布中移除对象。如果该对象有子节点也会一并移除。",paraId:7,tocIndex:2},{value:"canvas.removeChild(circle);\n// or canvas.document.documentElement.removeChild(circle);\n",paraId:8,tocIndex:2},{value:"方法签名如下：",paraId:9,tocIndex:2},{value:"removeChild(object: DisplayObject): DisplayObject;\n",paraId:10,tocIndex:2},{value:"为了和 DOM API 保持一致，仅移除对象并不会销毁。如果要销毁需要调用 ",paraId:11,tocIndex:2},{value:"destroy()",paraId:11,tocIndex:2},{value:"。",paraId:11,tocIndex:2},{value:"移除画布中所有对象。",paraId:12,tocIndex:3},{value:"canvas.removeChildren();\n// or canvas.document.documentElement.removeChildren();\n",paraId:13,tocIndex:3},{value:"移除并销毁画布中所有对象。",paraId:14,tocIndex:4},{value:"canvas.destroyChildren();\n",paraId:15,tocIndex:4},{value:"在实例化时会进行初始化逻辑，随后可调用以下生命周期方法。",paraId:16,tocIndex:5},{value:"初始化工作完成后，返回一个 Promise，等价于监听 ",paraId:17,tocIndex:6},{value:"CanvasEvent.READY",paraId:18,tocIndex:6},{value:" 事件：",paraId:17,tocIndex:6},{value:"await canvas.ready;\n\n// 等价于\nimport { CanvasEvent } from '@antv/g';\ncanvas.addEventListener(CanvasEvent.READY, () => {});\n",paraId:19,tocIndex:6},{value:"渲染画布，由于渲染器默认开启了自动渲染，大多数情况下不需要手动调用。但有些场景需要手动控制渲染时机，此时可以进行",paraId:20,tocIndex:7},{value:"按需渲染",paraId:21,tocIndex:7},{value:" ",paraId:20,tocIndex:7},{value:"示例",paraId:22,tocIndex:7},{value:"：",paraId:20,tocIndex:7},{value:"// 关闭自动渲染\nconst webglRenderer = new WebGLRenderer({\n    enableAutoRendering: false,\n});\n\ncanvas.render();\n",paraId:23,tocIndex:7},{value:"销毁画布，依次执行以下销毁逻辑：",paraId:24,tocIndex:8},{value:"如果开启了自动渲染，停止主渲染循环",paraId:25,tocIndex:8},{value:"将整个场景图从画布中移除，如果设置了 ",paraId:25,tocIndex:8},{value:"destroyScenegraph",paraId:25,tocIndex:8},{value:" 还会销毁整个场景图",paraId:25,tocIndex:8},{value:"销毁渲染上下文",paraId:25,tocIndex:8},{value:"// 仅销毁画布，保留场景图\ncanvas.destroy();\n\n// 一并销毁画布中的场景图\ncanvas.destroy(true);\n",paraId:26,tocIndex:8}]},27135:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(39511);const d=[{value:"基于样式系统，我们可以提供常用的布局算法，让用户避免相同场景的重复计算，主要参考 CSS Layout API 。",paraId:0},{value:"https://drafts.css-houdini.org/css-layout-api",paraId:1},{value:"https://github.com/w3c/css-houdini-drafts/blob/main/css-layout-api/EXPLAINER.md",paraId:2},{value:"布局算法以 ",paraId:3},{value:"@antv/g-layout-xxx",paraId:3},{value:" 形式命名，用户在运行时：",paraId:3},{value:"选择自己需要的布局算法，通过样式系统提供的 ",paraId:4},{value:"CSS.registerLayout",paraId:4},{value:" API 完成注册",paraId:4},{value:"容器元素通过 ",paraId:4},{value:"display",paraId:4},{value:" 属性使用，容器内元素不再需要使用 x/y/z 属性或者 ",paraId:4},{value:"setPosition",paraId:5},{value:" 等 API 手动定位。定位工作由容器选择的布局算法承担",paraId:4},{value:"使用方式如下：",paraId:6},{value:"import { CSS, Group, Circle } from '@antv/g';\nimport { Layout as BlockFlowLayout } from '@antv/g-layout-blockflow';\nimport { Layout as FlexLayout } from '@antv/g-layout-flex';\nimport { Layout as MasonryLayout } from '@antv/g-layout-masonry';\nimport { Layout as GridLayout } from '@antv/g-layout-grid';\n\n// 注册布局算法\nCSS.registerLayout('block', BlockFlowLayout);\nCSS.registerLayout('flex', FlexLayout);\nCSS.registerLayout('masonry', MasonryLayout);\nCSS.registerLayout('grid', GridLayout);\n\n// 使用 BlockFlow 布局\nconst blockGroup = new Group({\n    style: {\n        display: 'block', // 通过 display 属性使用\n        width: '400px',\n        height: '400px',\n    },\n});\n// 容器内元素无需手动定位，由容器负责\nblockGroup.appendChild(\n    new Circle({\n        style: {\n            r: 100,\n        },\n    }),\n);\ncanvas.appendChild(blockGroup);\n",paraId:7}]},40581:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(88038);const d=[{value:"有了 ",paraId:0},{value:"CSS Typed OM",paraId:1},{value:" 我们能方便地定义例如 ",paraId:0},{value:"CSS.px(5)",paraId:0},{value:" 这样的属性值，但属性并不只有值。",paraId:0},{value:"在浏览器中 ",paraId:2},{value:"CSS Properties & Values API",paraId:2},{value:" 允许用户自定义 CSS 属性并为其配置类型检查、默认值、是否支持继承等元数据，它也是 CSS Houdini 的一部分。",paraId:2},{value:"例如下面展示了如何自定义一个颜色属性：",paraId:3},{value:"window.CSS.registerProperty({\n    name: '--my-color',\n    syntax: '<color>',\n    inherits: false,\n    initialValue: '#c0ffee',\n});\n",paraId:4},{value:"我们在 G 中也实现了这一 API，定义了一系列内置的属性值类型。",paraId:5},{value:"CSS 属性值包含各种类型：",paraId:6,tocIndex:0},{value:"https://drafts.csswg.org/css-values-4/",paraId:6,tocIndex:0},{value:"在 G 中我们支持以下类型：",paraId:7,tocIndex:0},{value:"关键词，例如 ",paraId:8,tocIndex:0},{value:"unset",paraId:8,tocIndex:0},{value:" ",paraId:8,tocIndex:0},{value:"center",paraId:8,tocIndex:0},{value:"数值\n",paraId:8,tocIndex:0},{value:"<color> 颜色值，例如 ",paraId:9,tocIndex:0},{value:"red",paraId:9,tocIndex:0},{value:"<paint> 绘制，包含颜色值",paraId:9,tocIndex:0},{value:"<percentage> 百分比，例如 ",paraId:9,tocIndex:0},{value:"%",paraId:9,tocIndex:0},{value:"<number> 纯数字",paraId:9,tocIndex:0},{value:"<length> 带单位的长度值 ",paraId:9,tocIndex:0},{value:"px",paraId:9,tocIndex:0},{value:" ",paraId:9,tocIndex:0},{value:"em",paraId:9,tocIndex:0},{value:" ",paraId:9,tocIndex:0},{value:"rem",paraId:9,tocIndex:0},{value:"<angle> 带单位的角度值，例如 ",paraId:9,tocIndex:0},{value:"deg",paraId:9,tocIndex:0},{value:" ",paraId:9,tocIndex:0},{value:"rad",paraId:9,tocIndex:0},{value:" ",paraId:9,tocIndex:0},{value:"turn",paraId:9,tocIndex:0},{value:"在部分场景下，这些类型可以进行组合，例如：<length-percentage> 就是 <length> 和 <percentage> 的组合。",paraId:10,tocIndex:0},{value:"对应 ",paraId:11,tocIndex:1},{value:"CSS Typed OM",paraId:12,tocIndex:1},{value:" 中的 ",paraId:11,tocIndex:1},{value:"CSSKeywordValue",paraId:13,tocIndex:1},{value:"。",paraId:11,tocIndex:1},{value:"例如会被解析成：",paraId:14,tocIndex:1},{value:"text.style.fontWeight = 'normal';\n\nconst styleMap = text.computedStyleMap();\nstyleMap.get('fontWeight'); // CSSKeywordValue { value: 'normal' }\n",paraId:15,tocIndex:1},{value:"和 CSS 一样，全局关键词如下。",paraId:16,tocIndex:1},{value:"该关键词为元素应用“默认值”，可以用来重置继承属性。",paraId:17,tocIndex:2},{value:"例如下面的例子中，",paraId:18,tocIndex:2},{value:"<em>",paraId:18,tocIndex:2},{value:" 本应继承 ",paraId:18,tocIndex:2},{value:"<p>",paraId:18,tocIndex:2},{value:" 定义的 ",paraId:18,tocIndex:2},{value:"color",paraId:18,tocIndex:2},{value:" 属性，但它通过 ",paraId:18,tocIndex:2},{value:"initial",paraId:18,tocIndex:2},{value:" 应用默认值（黑色），覆盖掉了继承值：",paraId:18,tocIndex:2},{value:"p {\n  color: red;\n}\nem {\n  color: initial;\n}\n\n<p>\n  <span>This text is red.</span>\n  <em>This text is in the initial color (typically black).</em>\n  <span>This is red again.</span>\n</p>\n",paraId:19,tocIndex:2},{value:"https://developer.mozilla.org/en-US/docs/Web/CSS/initial",paraId:20,tocIndex:2},{value:"https://developer.mozilla.org/en-US/docs/Web/CSS/inherit",paraId:21,tocIndex:3},{value:"https://developer.mozilla.org/en-US/docs/Web/CSS/unset",paraId:22,tocIndex:4},{value:' type="button" class="ant-btn ant-btn-text ant-btn-icon-only button comment-link">',paraId:23},{value:"对应 ",paraId:24,tocIndex:5},{value:"CSS Typed OM",paraId:25,tocIndex:5},{value:" 中的 ",paraId:24,tocIndex:5},{value:"CSSUnitValue",paraId:26,tocIndex:5},{value:"，无单位。",paraId:24,tocIndex:5},{value:"目前使用该类型的属性值包括：",paraId:27,tocIndex:5},{value:"opacity",paraId:28,tocIndex:5},{value:"fillOpacity",paraId:29,tocIndex:5},{value:"strokeOpacity",paraId:30,tocIndex:5},{value:"circle.style.opacity = '0.5';\n\nconst styleMap = circle.computedStyleMap();\nstyleMap.get('opacity'); // CSSUnitValue { unit:'', value: 0.5 }\n",paraId:31,tocIndex:5},{value:' type="button" class="ant-btn ant-btn-text ant-btn-icon-only button comment-link">',paraId:23},{value:"长度类型用于定义距离，而距离又包括绝对和相对类型。",paraId:32,tocIndex:6},{value:"https://drafts.csswg.org/css-values-4/#length-value",paraId:33,tocIndex:6},{value:"像素显然是一种绝对单位，如果一个长度值使用 ",paraId:34,tocIndex:7},{value:"number",paraId:34,tocIndex:7},{value:" 默认单位就是 ",paraId:34,tocIndex:7},{value:"px",paraId:34,tocIndex:7},{value:"。随后被解析成 ",paraId:34,tocIndex:7},{value:"CSS.px()",paraId:34,tocIndex:7},{value:"：",paraId:34,tocIndex:7},{value:"circle.style.r = 10;\n// or\ncircle.style.r = '10px';\n\nconst styleMap = circle.computedStyleMap();\nstyleMap.get('r'); // CSSUnitValue { unit: 'px', value: 10 }\n",paraId:35,tocIndex:7},{value:"这个单位代表根元素的 font-size 大小。当用在根元素的 font-size 上面时，它代表了它的初始值。",paraId:36,tocIndex:8},{value:"相对长度单位，这个单位表示元素的 font-size 的计算值。如果用在 font-size 属性本身，它则表示元素继承的 font-size 值。",paraId:37,tocIndex:9},{value:' type="button" class="ant-btn ant-btn-text ant-btn-icon-only button comment-link">',paraId:23},{value:"https://drafts.csswg.org/css-values-4/#percentage-value",paraId:38,tocIndex:10},{value:' type="button" class="ant-btn ant-btn-text ant-btn-icon-only button comment-link">',paraId:23},{value:"https://drafts.csswg.org/css-values-4/#angle-value",paraId:39,tocIndex:11},{value:"度。一个完整的圆是 360deg。例：0deg，90deg，14.23deg。",paraId:40,tocIndex:12},{value:"百分度。一个完整的圆是 400grad。例：0grad，100grad，38.8grad。",paraId:41,tocIndex:13},{value:"弧度。一个完整的圆是 2π 弧度，约等于 6.2832rad。1rad 是 180/π 度。例：0rad，1.0708rad，6.2832rad。",paraId:42,tocIndex:14},{value:"圈数。一个完整的圆是 1turn。例：0turn，0.25turn，1.2turn。",paraId:43,tocIndex:15},{value:' type="button" class="ant-btn ant-btn-text ant-btn-icon-only button comment-link">',paraId:23},{value:"参考 CSS 规范中对于 ",paraId:44,tocIndex:16},{value:"<color>",paraId:44,tocIndex:16},{value:" 类型的定义，我们支持以下颜色值类型，它们都以 JS 中的 ",paraId:44,tocIndex:16},{value:"string",paraId:44,tocIndex:16},{value:" 类型存在。",paraId:44,tocIndex:16},{value:"它是 ",paraId:45,tocIndex:16},{value:"<paint>",paraId:46,tocIndex:16},{value:" 包含的一种类型。",paraId:45,tocIndex:16},{value:"示例",paraId:47,tocIndex:16},{value:"。",paraId:48,tocIndex:16},{value:"目前会使用该类型的属性有：",paraId:49,tocIndex:16},{value:"shadowColor",paraId:50,tocIndex:16},{value:" 阴影色",paraId:51,tocIndex:16},{value:"CSS 定义了一系列基础的颜色关键词，它们都是",paraId:52,tocIndex:17},{value:"大小写敏感",paraId:52,tocIndex:17},{value:"的。下左图展示基础的颜色关键词，下右图为部分扩展的关键词。",paraId:52,tocIndex:17},{value:"在内部实现中，我们会把关键词字符串传给 ",paraId:53,tocIndex:17},{value:"d3-color",paraId:53,tocIndex:17},{value:" 解析，得到 ",paraId:53,tocIndex:17},{value:"CSSRGB",paraId:54,tocIndex:17},{value:"。",paraId:53,tocIndex:17},{value:"使用示例如下：",paraId:55,tocIndex:17},{value:"circle.style.fill = 'red';\ncircle.style.fill = 'darkcyan';\n",paraId:56,tocIndex:17},{value:"定义在 ",paraId:57,tocIndex:19},{value:"sRGB",paraId:57,tocIndex:19},{value:" 颜色空间，支持十六进制写法。",paraId:57,tocIndex:19},{value:"使用示例如下：",paraId:58,tocIndex:19},{value:"circle.style.fill = '#f00';\ncircle.style.fill = '#ff0000';\ncircle.style.fill = 'rgb(255,0,0)';\ncircle.style.fill = 'rgb(100%, 0%, 0%)';\n",paraId:59,tocIndex:19},{value:"在 ",paraId:60,tocIndex:20},{value:"rgb",paraId:60,tocIndex:20},{value:" 基础上增加透明度通道。按照",paraId:60,tocIndex:20},{value:"规范",paraId:60,tocIndex:20},{value:"，",paraId:60,tocIndex:20},{value:"alpha",paraId:60,tocIndex:20},{value:" 取值范围为 ",paraId:60,tocIndex:20},{value:"[0, 1]",paraId:60,tocIndex:20},{value:"。",paraId:60,tocIndex:20},{value:"使用示例如下：",paraId:61,tocIndex:20},{value:"circle.style.fill = 'rgb(255,0,0)';\ncircle.style.fill = 'rgba(255,0,0,1)';\ncircle.style.fill = 'rgba(100%,0%,0%,1)';\n",paraId:62,tocIndex:20},{value:"等同于 ",paraId:63,tocIndex:21},{value:"rgba(0,0,0,0)",paraId:63,tocIndex:21},{value:" 即完全透明的黑色。",paraId:63,tocIndex:21},{value:"注意它和 ",paraId:64,tocIndex:21},{value:"<paint>",paraId:65,tocIndex:21},{value:" 支持的 ",paraId:64,tocIndex:21},{value:"none",paraId:64,tocIndex:21},{value:" 是不同的含义。",paraId:64,tocIndex:21},{value:"暂不支持。",paraId:66,tocIndex:22},{value:"暂不支持。",paraId:67,tocIndex:23},{value:"https://www.w3.org/TR/css-color-3/#currentcolor",paraId:68,tocIndex:24},{value:"Canvas / WebGL 渲染环境中等同于 black，SVG 中为同名属性效果。",paraId:69,tocIndex:24},{value:' type="button" class="ant-btn ant-btn-text ant-btn-icon-only button comment-link">',paraId:23},{value:' type="button" class="ant-btn ant-btn-text ant-btn-icon-only button comment-link">',paraId:23},{value:' type="button" class="ant-btn ant-btn-text ant-btn-icon-only button comment-link">',paraId:23},{value:"参考 SVG 中的 ",paraId:70,tocIndex:27},{value:"<paint>",paraId:70,tocIndex:27},{value:"，它是以下类型的并集：",paraId:70,tocIndex:27},{value:"<paint> = none | <color> | <gradient> | <pattern>\n",paraId:71,tocIndex:27},{value:"示例",paraId:72,tocIndex:27},{value:"。",paraId:73,tocIndex:27},{value:"目前使用的属性有：",paraId:74,tocIndex:27},{value:"fill",paraId:75,tocIndex:27},{value:" 填充色",paraId:76,tocIndex:27},{value:"stroke",paraId:77,tocIndex:27},{value:" 描边色",paraId:76,tocIndex:27},{value:"不使用任何颜色，并不等于 ",paraId:78,tocIndex:28},{value:"<color>",paraId:79,tocIndex:28},{value:" 的 ",paraId:78,tocIndex:28},{value:"transparent",paraId:80,tocIndex:28},{value:" 关键词。以 ",paraId:78,tocIndex:28},{value:"fill",paraId:78,tocIndex:28},{value:" 属性为例，两者从视觉效果上看相同，但设置为 ",paraId:78,tocIndex:28},{value:"'transparent'",paraId:78,tocIndex:28},{value:" 依然可以被拾取到，设置成 ",paraId:78,tocIndex:28},{value:"'none'",paraId:78,tocIndex:28},{value:" 则不会。",paraId:78,tocIndex:28},{value:"例如当图形在初始化未设置 ",paraId:81,tocIndex:28},{value:"fill",paraId:81,tocIndex:28},{value:" 属性时，等同于创建后手动修改为 ",paraId:81,tocIndex:28},{value:"none",paraId:81,tocIndex:28},{value:"：",paraId:81,tocIndex:28},{value:"const circle = new Circle({\n    r: 150,\n});\n\ncircle.style.fill = 'none';\n",paraId:82,tocIndex:28},{value:"在 Blink 中所有的 CSS 属性元数据都定义在一个 JSON 列表中，它描述了样式系统应该如何解析、计算样式值。",paraId:83,tocIndex:29},{value:"属性的元数据包含以下关键信息：",paraId:84,tocIndex:29},{value:"属性名。例如 fill width r",paraId:85,tocIndex:29},{value:"值解析器。从字符串到 CSSStyleValue。不同属性值自然需要不同的解析器，例如 fill stroke 可以共享颜色解析器。注意我们只需要实现对于 “值” 的解析，而非类似 ",paraId:85,tocIndex:29},{value:"https://github.com/csstree/csstree",paraId:85,tocIndex:29},{value:" 这样的实现。",paraId:85,tocIndex:29},{value:"是否支持插值。不支持则无法在动画系统中进行平滑过渡。",paraId:85,tocIndex:29},{value:"https://drafts.csswg.org/css-values-4/#combining-values",paraId:85,tocIndex:29},{value:"是否支持继承。例如 font-size 需要支持。在 D3 中有大量类似的技巧。",paraId:85,tocIndex:29},{value:"是否独立。例如 visibility 就不是，需要考虑祖先节点才能得到最终的计算值。",paraId:85,tocIndex:29},{value:"默认值。例如 fill 的默认值为 black（SVG 规范）",paraId:85,tocIndex:29},{value:"关键词列表。例如 width 属性支持 auto 关键词。",paraId:85,tocIndex:29},{value:"别名列表。例如 line-width 的别名 stroke-width。",paraId:85,tocIndex:29},{value:"默认值对于“属性是否支持继承”的定义不同：",paraId:86,tocIndex:30},{value:"https://developer.mozilla.org/en-US/docs/Web/CSS/initial_value",paraId:87,tocIndex:30},{value:"For inherited properties, the initial value is used on the root element only, as long as no specified value is supplied.",paraId:88,tocIndex:30},{value:"For non-inherited properties, the initial value is used on all elements, as long as no specified value is supplied.",paraId:88,tocIndex:30},{value:"因此对于 G 的根节点，在创建时需要设置所有 ",paraId:89,tocIndex:30},{value:"inherited",paraId:89,tocIndex:30},{value:" 属性的默认值，例如 ",paraId:89,tocIndex:30},{value:"visibility",paraId:89,tocIndex:30},{value:" 在属性元数据中定义如下，它支持继承：",paraId:89,tocIndex:30},{value:"{\n  name: 'visibility',\n  keywords: ['visible', 'hidden'],\n  inherited: true,\n  interpolable: true,\n  defaultValue: 'visible',\n  handler: CSSPropertyVisibility,\n}\n",paraId:90,tocIndex:30},{value:"由于支持继承，子元素虽然没有设置过 ",paraId:91,tocIndex:30},{value:"visibility",paraId:91,tocIndex:30},{value:"，默认情况下得到的计算值也会是 ",paraId:91,tocIndex:30},{value:"visible",paraId:91,tocIndex:30},{value:"。",paraId:91,tocIndex:30},{value:"对于属性值的解析经历以下阶段：",paraId:92,tocIndex:31},{value:"原始值（通常是字符串）转换成 CSSStyleUnit，称作 computed value",paraId:93,tocIndex:31},{value:"将 computed value 计算后得到 used value",paraId:93,tocIndex:31},{value:"https://developer.mozilla.org/en-US/docs/Web/CSS/computed_value",paraId:94,tocIndex:31},{value:"在这一步需要：",paraId:95,tocIndex:31},{value:"处理特殊的关键词（通常是通用的），例如 ",paraId:96,tocIndex:31},{value:"initial",paraId:97,tocIndex:31},{value:" ",paraId:96,tocIndex:31},{value:"inherit",paraId:98,tocIndex:31},{value:"做一些值计算，需要布局阶段参与的除外",paraId:96,tocIndex:31},{value:"通过 ",paraId:99,tocIndex:31},{value:"computedStyleMap",paraId:100,tocIndex:31},{value:" 方法可以获取 computed value map，这是一个 ",paraId:99,tocIndex:31},{value:"Map",paraId:99,tocIndex:31},{value:" 类型：",paraId:99,tocIndex:31},{value:"/**\n * computed values\n */\nconst styleMap = circle.computedStyleMap();\n\nexpect((styleMap.get('r') as CSSUnitValue).equals(CSS.px(100))).to.be.true;\nconst fill = styleMap.get('fill') as CSSRGB;\nexpect(fill.r).toBe(255);\nexpect(fill.g).toBe(0);\nexpect(fill.b).toBe(0);\nexpect(fill.alpha).toBe(1);\n",paraId:101,tocIndex:31},{value:"但是 computed value 并不能直接用于渲染，例如百分比、相对长度都需要进一步计算。",paraId:102,tocIndex:31},{value:"https://developer.mozilla.org/en-US/docs/Web/CSS/used_value",paraId:103,tocIndex:32},{value:"进一步处理 computed value，得到最终送入渲染管线的值。",paraId:104,tocIndex:32},{value:"例如 ",paraId:105,tocIndex:32},{value:"CSS.percent(50)",paraId:105,tocIndex:32},{value:" 需要计算得到 ",paraId:105,tocIndex:32},{value:"CSS.px(?)",paraId:105,tocIndex:32},{value:"。",paraId:105,tocIndex:32},{value:"在 CSS 中定义新属性方法如下：",paraId:106,tocIndex:33},{value:"https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty",paraId:107,tocIndex:33},{value:"CSS.registerProperty({\n    name: '--my-color',\n    syntax: '<color>',\n    inherits: false,\n    initialValue: '#c0ffee',\n});\n",paraId:108,tocIndex:33},{value:"随后就可以在 CSS 中使用这个属性。其中比较关键的是 ",paraId:109,tocIndex:33},{value:"syntax",paraId:109,tocIndex:33},{value:"，局限性是只能使用浏览器内置的实现，无法做到真正意义上的自定义解析。",paraId:109,tocIndex:33},{value:"在该",paraId:110,tocIndex:33},{value:"示例",paraId:111,tocIndex:33},{value:"中，我们注册了多种不同类型的自定义属性，让它们支持插值。",paraId:110,tocIndex:33},{value:"import { CSS, PropertySyntax } from '@antv/g';\n\n// 注册自定义属性\nCSS.registerProperty({\n    name: 'myNumber',\n    syntax: PropertySyntax.NUMBER, // 使用内置的 “数字” 解析器\n    initialValue: '0',\n    interpolable: true, // 支持动画过程中的插值\n});\n\n// 对自定义属性应用动画\nconst animation = myCustomElement.animate(\n    [\n        {\n            myNumber: 0,\n        },\n        {\n            myNumber: 1,\n        },\n    ],\n    { duration: 2000, fill: 'both' },\n);\n",paraId:112,tocIndex:33},{value:"字符串形式的属性名。需要保证全局唯一，不能与内置属性冲突，可加上命名空间前缀。",paraId:113,tocIndex:34},{value:"是否支持继承。",paraId:114,tocIndex:35},{value:"默认值。",paraId:115,tocIndex:36},{value:"是否支持插值。只有支持才能应用",paraId:116,tocIndex:37},{value:"动画",paraId:117,tocIndex:37},{value:"。",paraId:116,tocIndex:37},{value:"例如在下面的自定义元素中，我们定义了自定义属性 ",paraId:118,tocIndex:37},{value:"angle",paraId:118,tocIndex:37},{value:"，它使用 ",paraId:118,tocIndex:37},{value:"<angle>",paraId:118,tocIndex:37},{value:" 解析器并支持插值：",paraId:118,tocIndex:37},{value:"CSS.registerProperty({\n    name: 'angle',\n    syntax: PropertySyntax.ANGLE,\n    initialValue: '0',\n    interpolable: true,\n});\n",paraId:119,tocIndex:37},{value:"目前我们支持的解析器如下：",paraId:120,tocIndex:38},{value:"/**\n * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type\n */\nexport enum PropertySyntax {\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#coordinate\n   */\n  COORDINATE = '<coordinate>',\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#color\n   */\n  COLOR = '<color>',\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#paint\n   */\n  PAINT = '<paint>',\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#number\n   */\n  NUMBER = '<number>',\n  /**\n   * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/angle\n   */\n  ANGLE = '<angle>',\n  /**\n   * <number> with range 0..1\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#opacity_value\n   */\n  OPACITY_VALUE = '<opacity-value>',\n  /**\n   * <number> with range 0..Infinity\n   */\n  SHADOW_BLUR = '<shadow-blur>',\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#length\n   */\n  LENGTH = '<length>',\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#percentage\n   */\n  PERCENTAGE = '<percentage>',\n  LENGTH_PERCENTAGE = '<length> | <percentage>',\n\n  LENGTH_PERCENTAGE_12 = '[<length> | <percentage>]{1,2}',\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/margin#formal_syntax\n   */\n  LENGTH_PERCENTAGE_14 = '[<length> | <percentage>]{1,4}',\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#list-of-ts\n   */\n  LIST_OF_POINTS = '<list-of-points>',\n  PATH = '<path>',\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/filter#formal_syntax\n   */\n  FILTER = '<filter>',\n  Z_INDEX = '<z-index>',\n  OFFSET_PATH = '<offset-path>',\n  OFFSET_DISTANCE = '<offset-distance>',\n  CLIP_PATH = '<clip-path>',\n  TRANSFORM = '<transform>',\n  TRANSFORM_ORIGIN = '<transform-origin>',\n  TEXT = '<text>',\n  TEXT_TRANSFORM = '<text-transform>',\n}\n",paraId:121,tocIndex:38}]},87773:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(62370);const d=[{value:"在浏览器中，过去很长一段时间 CSS 的解析对于前端开发者都是一个黑盒。我们只能通过 ",paraId:0},{value:"el.style.width = '50%'",paraId:0},{value:" 这样非结构化的字符串与样式系统交互。",paraId:0},{value:"CSS Typed OM API",paraId:1},{value:" 允许使用 JS 操作解析后的属性值，它也是 ",paraId:1},{value:"CSS Houdini",paraId:1},{value:" 的基础。以上面的 ",paraId:1},{value:"width: '50%'",paraId:1},{value:" 为例，字符串形式的属性值会被解析成 ",paraId:1},{value:"CSS.percent(50)",paraId:1},{value:"，方便进行下一步的计算。",paraId:1},{value:"我们在 ",paraId:2,tocIndex:0},{value:"CSS",paraId:2,tocIndex:0},{value:" 上提供了一系列快捷的创建方法：",paraId:2,tocIndex:0},{value:"import { CSS } from '@antv/g';\n\nCSS.number(5);\nCSS.px(5);\nCSS.em(1.2);\nCSS.percent(50);\n",paraId:3,tocIndex:0},{value:"创建一个 ",paraId:4,tocIndex:1},{value:"CSSUnitValue",paraId:5,tocIndex:1},{value:"，单位为 ",paraId:4,tocIndex:1},{value:"UnitType.kNumber",paraId:4,tocIndex:1},{value:"，以下两种写法一致：",paraId:4,tocIndex:1},{value:"import { CSS, CSSUnitValue } from '@antv/g';\n\nCSS.number(5);\nnew CSSUnitValue(5); // 默认单位就是 UnitType.kNumber\n",paraId:6,tocIndex:1},{value:"我们会用它存储 ",paraId:7,tocIndex:1},{value:"<number>",paraId:8,tocIndex:1},{value:" 类型属性值的解析结果，例如 ",paraId:7,tocIndex:1},{value:"opacity: 0.5",paraId:7,tocIndex:1},{value:" 会被解析成 ",paraId:7,tocIndex:1},{value:"CSS.number(0.5)",paraId:7,tocIndex:1},{value:" 后保存在 ",paraId:7,tocIndex:1},{value:"computedStyle.opacity",paraId:7,tocIndex:1},{value:" 中。",paraId:7,tocIndex:1},{value:"创建一个 ",paraId:9,tocIndex:2},{value:"CSSUnitValue",paraId:10,tocIndex:2},{value:"，单位为 ",paraId:9,tocIndex:2},{value:"UnitType.kPixels",paraId:9,tocIndex:2},{value:"，以下两种写法一致：",paraId:9,tocIndex:2},{value:"import { CSS, CSSUnitValue } from '@antv/g';\n\nCSS.px(5);\nnew CSSUnitValue(5, 'px');\n",paraId:11,tocIndex:2},{value:"我们会用它存储 ",paraId:12,tocIndex:2},{value:"<length>",paraId:13,tocIndex:2},{value:" 类型属性值的解析结果，例如 ",paraId:12,tocIndex:2},{value:"r: 50",paraId:12,tocIndex:2},{value:" 会被解析成 ",paraId:12,tocIndex:2},{value:"CSS.px(50)",paraId:12,tocIndex:2},{value:" 后保存在 ",paraId:12,tocIndex:2},{value:"computedStyle.r",paraId:12,tocIndex:2},{value:" 中。",paraId:12,tocIndex:2},{value:"创建一个 ",paraId:14,tocIndex:3},{value:"CSSUnitValue",paraId:15,tocIndex:3},{value:"，单位为 ",paraId:14,tocIndex:3},{value:"UnitType.kEms",paraId:14,tocIndex:3},{value:"，以下两种写法一致：",paraId:14,tocIndex:3},{value:"import { CSS, CSSUnitValue } from '@antv/g';\n\nCSS.em(5);\nnew CSSUnitValue(5, 'em');\n",paraId:16,tocIndex:3},{value:"创建一个 ",paraId:17,tocIndex:4},{value:"CSSUnitValue",paraId:18,tocIndex:4},{value:"，单位为 ",paraId:17,tocIndex:4},{value:"UnitType.kRems",paraId:17,tocIndex:4},{value:"，以下两种写法一致：",paraId:17,tocIndex:4},{value:"import { CSS, CSSUnitValue } from '@antv/g';\n\nCSS.rem(5);\nnew CSSUnitValue(5, 'rem');\n",paraId:19,tocIndex:4},{value:"它是以下类型的基类。",paraId:20,tocIndex:5},{value:"继承自 CSSStyleValue。提供一系列数学运算。",paraId:21,tocIndex:6},{value:"例如我们可以这样表示 ",paraId:22,tocIndex:6},{value:"10px + 10%",paraId:22,tocIndex:6},{value:" 这样的属性值：",paraId:22,tocIndex:6},{value:"const length = new CSSUnitValue(10, 'px');\nconst percent = new CSSUnitValue(10, '%');\nconst result = percent.add(length);\n\n// 字符串表示\nexpect(result.toString()).toBe('calc(10% + 10px)');\nexpect(result.toSum('px', 'percent').toString()).toBe('calc(10px + 10%)');\nexpect(result.toSum('percent', 'px').toString()).toBe('calc(10% + 10px)');\n",paraId:23,tocIndex:6},{value:"https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue",paraId:24,tocIndex:6},{value:"反映该属性值代表何种类型（CSSNumericType），例如 ",paraId:25,tocIndex:7},{value:"<length>",paraId:25,tocIndex:7},{value:"、",paraId:25,tocIndex:7},{value:"<angle>",paraId:25,tocIndex:7},{value:" 等等：",paraId:25,tocIndex:7},{value:"https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue/type",paraId:26,tocIndex:7},{value:"// <number>\nconst number = new CSSUnitValue(10);\nexpect(number.type()).to.eqls({\n    length: 0,\n    angle: 0,\n    time: 0,\n    frequency: 0,\n    resolution: 0,\n    flex: 0,\n    percent: 0,\n    percentHint: 'length',\n});\n\n// <length>\nconst length = new CSSUnitValue(10, 'px');\nexpect(length.type()).to.eqls({\n    length: 1,\n    angle: 0,\n    time: 0,\n    frequency: 0,\n    resolution: 0,\n    flex: 0,\n    percent: 0,\n    percentHint: 'length',\n});\n",paraId:27,tocIndex:7},{value:"提供不同单位间的转换。方法签名如下：",paraId:28,tocIndex:8},{value:"to(unit: UnitType | string): CSSUnitValue;\n",paraId:29,tocIndex:8},{value:"https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue/to",paraId:30,tocIndex:8},{value:"例如在不同角度单位间转换：",paraId:31,tocIndex:8},{value:"const degValue = new CSSUnitValue(360, 'deg');\n\nexpect(degValue.to('deg').value).to.eqls(360);\nexpect(degValue.to('rad').value).to.eqls(deg2rad(360));\nexpect(degValue.to('turn').value).to.eqls(deg2turn(360));\n",paraId:32,tocIndex:8},{value:"如果当前单位和目标单位间无法进行转换（例如把 'px' 转成 'deg'），会返回 null。",paraId:33,tocIndex:8},{value:"尽可能完成不同单位间的计算。方法签名如下：",paraId:34,tocIndex:9},{value:"toSum(...unit_strings: string[]): CSSMathSum {}\n",paraId:35,tocIndex:9},{value:"https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue/toSum",paraId:36,tocIndex:9},{value:"例如我们希望简化表达式的计算结果，使用 'px' 和 '%'：",paraId:37,tocIndex:9},{value:"let v = CSS.px('20').add(CSS.percent('4')).add(CSS.px('20'));\nv.toString(); // => \"calc(20px + 4% + 20px)\"\nv.toSum('px', 'percent').toString(); // => \"calc(40px + 4%)\"\n",paraId:38,tocIndex:9},{value:"需要注意的是，传入的单位顺序会影响最终表达式的值：",paraId:39,tocIndex:9},{value:"const length = new CSSUnitValue(10, 'px');\nconst percent = new CSSUnitValue(10, '%');\nconst result = percent.add(length);\n\nexpect(result.toString()).toBe('calc(10% + 10px)');\nexpect(result.toSum('px', 'percent').toString()).toBe('calc(10px + 10%)');\nexpect(result.toSum('percent', 'px').toString()).toBe('calc(10% + 10px)');\n",paraId:40,tocIndex:9},{value:"类型和数值都要求完全一致，例如类型都是 ",paraId:41,tocIndex:10},{value:"<length>",paraId:41,tocIndex:10},{value:"，单位都是 'px'。",paraId:41,tocIndex:10},{value:"https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue/equals",paraId:42,tocIndex:10},{value:"实现加法。",paraId:43,tocIndex:11},{value:"https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue/add",paraId:44,tocIndex:11},{value:"let mathSum = CSS.px('23').add(CSS.percent('4'));\n// Prints \"calc(23px + 4%)\"\nconsole.log(mathSum.toString());\n",paraId:45,tocIndex:11},{value:"实现减法。",paraId:46,tocIndex:12},{value:"https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue/sub",paraId:47,tocIndex:12},{value:"let mathSum = CSS.px('23').sub(CSS.percent('4'));\n// Prints \"calc(23px - 4%)\"\nconsole.log(mathSum.toString());\n",paraId:48,tocIndex:12},{value:"https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue/mul",paraId:49,tocIndex:13},{value:"https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue/div",paraId:50,tocIndex:14},{value:"数值 + 单位。继承自 CSSNumericValue。",paraId:51,tocIndex:19},{value:"目前我们支持以下单位的枚举值：",paraId:52,tocIndex:19},{value:"export enum UnitType {\n  kUnknown,\n  // <number>\n  kNumber,\n  // <percentage>\n  kPercentage,\n  // <length>\n  kEms,\n  kRems,\n  kPixels,\n  // <angle>\n  kDegrees,\n  kRadians,\n  kGradians,\n  kTurns,\n}\n",paraId:53,tocIndex:19},{value:"在创建时除了使用枚举值，还可以使用字符串，因此以下三种写法一致：",paraId:54,tocIndex:19},{value:"import { CSS, CSSUnitValue, UnitType } from '@antv/g';\n\nCSS.px(5);\nnew CSSUnitValue(5, UnitType.kPixels);\nnew CSSUnitValue(5, 'px');\n",paraId:55,tocIndex:19},{value:"枚举值和字符串的映射关系如下：",paraId:56,tocIndex:19},{value:"UnitType.kNumber = 'number';\nUnitType.kPercentage = '%' | 'percent';\nUnitType.kEms = 'em';\nUnitType.kRems = 'rem';\nUnitType.kPixels = 'px';\nUnitType.kDegrees = 'deg';\nUnitType.kRadians = 'rad';\nUnitType.kGradians = 'grad';\nUnitType.kTurns = 'turn';\n",paraId:57,tocIndex:19},{value:"返回单位。",paraId:58,tocIndex:20},{value:"返回数值。",paraId:59,tocIndex:21},{value:"代表关键词，例如 ",paraId:60,tocIndex:22},{value:"unset",paraId:60,tocIndex:22},{value:" ",paraId:60,tocIndex:22},{value:"initial",paraId:60,tocIndex:22},{value:" ",paraId:60,tocIndex:22},{value:"inherit",paraId:60,tocIndex:22},{value:" 等。",paraId:60,tocIndex:22},{value:"https://developer.mozilla.org/en-US/docs/Web/API/CSSKeywordValue",paraId:61,tocIndex:22},{value:"const display = new CSSKeywordValue('initial');\ndisplay.value; // 'initial';\n",paraId:62,tocIndex:23},{value:"继承自 CSSColorValue。",paraId:63,tocIndex:25},{value:"const value = new CSSRGB(0, 0, 0);\n\nexpect(value.toString()).to.eqls('rgba(0,0,0,1)');\n",paraId:64,tocIndex:25}]},89960:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(36642);const d=[{value:"在 CSS 中，渐变是通过函数创建的，例如线性渐变 ",paraId:0},{value:"linear-gradient",paraId:0},{value:"：",paraId:0},{value:"background: linear-gradient(#e66465, #9198e5);\n",paraId:1},{value:"我们沿用了该语法，因此可以在支持渐变的属性中使用：",paraId:2},{value:"rect.style.fill = 'linear-gradient(#e66465, #9198e5)';\n",paraId:3},{value:"其中渐变色列表 ",paraId:4},{value:"<color-stop-list>",paraId:4},{value:" 形如：",paraId:4},{value:"radial-gradient(cyan 0%, transparent 20%, salmon 40%)",paraId:4},{value:"，使用 ",paraId:4},{value:"<color>",paraId:5},{value:" 和 ",paraId:4},{value:"<percentage>",paraId:6},{value:" 的组合。",paraId:4},{value:"在该",paraId:7},{value:"示例",paraId:8},{value:"中我们展示了目前支持的渐变效果，包括线性和径向渐变、多个渐变叠加等：",paraId:7},{value:"线性渐变用于创建一个表示两种或多种颜色线性渐变的图片。",paraId:9,tocIndex:0},{value:"这个教程",paraId:9,tocIndex:0},{value:"可以帮助你理解线性渐变方向的含义和计算逻辑。",paraId:9,tocIndex:0},{value:"用法完全可以参考 CSS ",paraId:10,tocIndex:0},{value:"linear-gradient",paraId:10,tocIndex:0},{value:"，但有以下区别：",paraId:10,tocIndex:0},{value:"渐变方向在 CSS 中默认为从下到上，而我们为了和 Canvas / SVG 保持一致，使用从左到右。",paraId:11,tocIndex:0},{value:"因此一个从左到右方向，旋转角度为 0 的线性渐变如下，",paraId:12,tocIndex:0},{value:"示例",paraId:13,tocIndex:0},{value:"：",paraId:12,tocIndex:0},{value:"rect.style.fill = 'linear-gradient(0deg, blue, green 40%, red)';\n",paraId:14,tocIndex:0},{value:"最后和 CSS 一致，多组渐变可以叠加：",paraId:15,tocIndex:0},{value:"rect.style.fill = `linear-gradient(217deg, rgba(255,0,0,.8), rgba(255,0,0,0) 70.71%),\n            linear-gradient(127deg, rgba(0,255,0,.8), rgba(0,255,0,0) 70.71%),\n            linear-gradient(336deg, rgba(0,0,255,.8), rgba(0,0,255,0) 70.71%)`;\n",paraId:16,tocIndex:0},{value:"径向渐变由从原点发出的两种或者多种颜色之间的逐步过渡组成。",paraId:17,tocIndex:1},{value:"用法完全可以参考 CSS ",paraId:18,tocIndex:1},{value:"radial-gradient",paraId:18,tocIndex:1},{value:"。",paraId:18,tocIndex:1},{value:"因此一个渐变中心位于图形中心，从红过渡到蓝再到绿的径向渐变如下，",paraId:19,tocIndex:1},{value:"示例",paraId:20,tocIndex:1},{value:"：",paraId:19,tocIndex:1},{value:"rect.style.fill = 'radial-gradient(circle at center, red, blue, green 100%)';\n",paraId:21,tocIndex:1},{value:"注意事项：",paraId:22,tocIndex:1},{value:"形状仅支持 ",paraId:23,tocIndex:1},{value:"circle",paraId:23,tocIndex:1},{value:" 不支持 ",paraId:23,tocIndex:1},{value:"ellipse",paraId:23,tocIndex:1},{value:"支持指定 ",paraId:23,tocIndex:1},{value:"circle",paraId:23,tocIndex:1},{value:" 半径：\n",paraId:23,tocIndex:1},{value:"'closest-side'",paraId:24,tocIndex:1},{value:" 圆心到包围盒最近边的距离",paraId:24,tocIndex:1},{value:"'farthest-corner'",paraId:24,tocIndex:1},{value:" ",paraId:24,tocIndex:1},{value:"默认值",paraId:24,tocIndex:1},{value:"。圆心到包围盒最远角的距离",paraId:24,tocIndex:1},{value:"'closest-corner'",paraId:24,tocIndex:1},{value:" 圆心到包围盒最近角的距离",paraId:24,tocIndex:1},{value:"'farthest-side'",paraId:24,tocIndex:1},{value:" 圆心到包围盒最远边的距离",paraId:24,tocIndex:1},{value:"<length>",paraId:24,tocIndex:1},{value:" 指定长度，例如 ",paraId:24,tocIndex:1},{value:"'radial-gradient(circle 80px at center, red 100%, blue 100%)'",paraId:24,tocIndex:1},{value:"下图分别展示了 ",paraId:25,tocIndex:1},{value:"'closest-side'",paraId:25,tocIndex:1},{value:" ",paraId:25,tocIndex:1},{value:"'farthest-side'",paraId:25,tocIndex:1},{value:" 和 ",paraId:25,tocIndex:1},{value:"80px",paraId:25,tocIndex:1},{value:" 的效果：",paraId:25,tocIndex:1},{value:"支持指定圆心位置，相对包围盒左上角定位，例如 ",paraId:26,tocIndex:1},{value:"radial-gradient(circle at 50px 50px, red, blue, green 100%)",paraId:26,tocIndex:1},{value:"：\n",paraId:26,tocIndex:1},{value:"'top'",paraId:27,tocIndex:1},{value:" 上方边缘中点",paraId:27,tocIndex:1},{value:"'left'",paraId:27,tocIndex:1},{value:" 左侧边缘中点",paraId:27,tocIndex:1},{value:"'bottom'",paraId:27,tocIndex:1},{value:" 下方边缘中点",paraId:27,tocIndex:1},{value:"'right'",paraId:27,tocIndex:1},{value:" 右侧边缘中点",paraId:27,tocIndex:1},{value:"'center'",paraId:27,tocIndex:1},{value:" 水平垂直居中",paraId:27,tocIndex:1},{value:"'top left'",paraId:27,tocIndex:1},{value:" 左上角",paraId:27,tocIndex:1},{value:"'left top'",paraId:27,tocIndex:1},{value:" 同 ",paraId:27,tocIndex:1},{value:"'top left'",paraId:27,tocIndex:1},{value:"'top right'",paraId:27,tocIndex:1},{value:" 右上角",paraId:27,tocIndex:1},{value:"'bottom left'",paraId:27,tocIndex:1},{value:" 左下角",paraId:27,tocIndex:1},{value:"'bottom right'",paraId:27,tocIndex:1},{value:" 右下角",paraId:27,tocIndex:1},{value:"<length> <length>",paraId:27,tocIndex:1},{value:" 指定长度，例如 ",paraId:27,tocIndex:1},{value:"'25% 25%'",paraId:27,tocIndex:1},{value:" 或者 ",paraId:27,tocIndex:1},{value:"'50px 50px'",paraId:27,tocIndex:1},{value:"下图分别展示了 ",paraId:28,tocIndex:1},{value:"'50px 50px'",paraId:28,tocIndex:1},{value:"，",paraId:28,tocIndex:1},{value:"'top right'",paraId:28,tocIndex:1},{value:" 和 ",paraId:28,tocIndex:1},{value:"'left'",paraId:28,tocIndex:1},{value:" 的效果：",paraId:28,tocIndex:1},{value:"和线性渐变一样，也支持多组叠加",paraId:29,tocIndex:1},{value:"l",paraId:30,tocIndex:3},{value:" 表示使用线性渐变，绿色的字体为可变量，由用户自己填写。",paraId:30,tocIndex:3},{value:"// example\n// 使用渐变色描边，渐变角度为 0，渐变的起始点颜色 #ffffff，中点的渐变色为 #7ec2f3，结束的渐变色为 #1890ff\nstroke: 'l(0) 0:#ffffff 0.5:#7ec2f3 1:#1890ff';\n",paraId:31,tocIndex:3},{value:"r",paraId:32,tocIndex:3},{value:" 表示使用放射状渐变，绿色的字体为可变量，由用户自己填写，开始圆的 ",paraId:32,tocIndex:3},{value:"x",paraId:32,tocIndex:3},{value:"、",paraId:32,tocIndex:3},{value:"y",paraId:32,tocIndex:3},{value:"、",paraId:32,tocIndex:3},{value:"r",paraId:32,tocIndex:3},{value:" 值均为相对值(0 至 1 范围)。",paraId:32,tocIndex:3},{value:"// example\n// 使用渐变色填充，渐变起始圆的圆心坐标为被填充物体的包围盒中心点，半径为(包围盒对角线长度 / 2) 的 0.1 倍，渐变的起始点颜色 #ffffff，中点的渐变色为 #7ec2f3，结束的渐变色为 #1890ff\nfill: 'r(0.5, 0.5, 0.1) 0:#ffffff 1:#1890ff';\n",paraId:33,tocIndex:3}]},89082:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(64342);const d=[{value:"在 CSS 中，当没有为属性设置值时，可继承属性将从父元素上获取计算值。",paraId:0},{value:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/inheritance",paraId:1},{value:"例如 CSS 的 ",paraId:2},{value:"color",paraId:2},{value:" 属性是可继承的，因此对于未设置该属性的 ",paraId:2},{value:"<em>",paraId:2},{value:" 元素，它将使用父元素的值 ",paraId:2},{value:"green",paraId:2},{value:"：",paraId:2},{value:"p { color: green; }\n\n<p>This paragraph has <em>emphasized text</em> in it.</p>\n",paraId:3},{value:"我们在 G 中实现了一套样式系统，同样支持继承。例如我们创建一个 ",paraId:4},{value:"Text",paraId:5},{value:"，并未指定 ",paraId:4},{value:"fontSize",paraId:4},{value:" 或者 ",paraId:4},{value:"fontFamily",paraId:4},{value:" 这些属性，但它依然可以被渲染出来，因为它加入画布后继承了根节点上的默认样式：",paraId:4},{value:"fontSize: '16px'; fontFamily: 'sans-serif'",paraId:4},{value:"：",paraId:4},{value:"const text = new Text({\n    style: {\n        x: 100,\n        y: 100,\n        text: 'hello',\n    },\n});\n\ncanvas.appendChild(text);\n",paraId:6},{value:"在该",paraId:7},{value:"示例",paraId:8},{value:"中，修改根节点的字号同样会影响到子元素，配合 ",paraId:7},{value:"rem",paraId:7},{value:" 这样的单位我们可以轻松实现“弹性布局”：",paraId:7},{value:"canvas.document.documentElement.style.fontSize = `32px`;\n",paraId:9},{value:"和浏览器一样，默认值（",paraId:10,tocIndex:0},{value:"initial value",paraId:10,tocIndex:0},{value:"）会在根节点上应用可继承属性。",paraId:10,tocIndex:0},{value:"例如浏览器默认的 ",paraId:11,tocIndex:0},{value:"fontSize",paraId:11,tocIndex:0},{value:" 是 ",paraId:11,tocIndex:0},{value:"16px",paraId:11,tocIndex:0},{value:"。我们在 G 中给",paraId:11,tocIndex:0},{value:"根节点",paraId:12,tocIndex:0},{value:"设置了如下样式：",paraId:11,tocIndex:0},{value:"expect(documentElement.style.fill).to.equal('');\nexpect(documentElement.style.fillOpacity).to.equal('1');\nexpect(documentElement.style.fontFamily).to.equal('sans-serif');\nexpect(documentElement.style.fontSize).to.equal('16px');\nexpect(documentElement.style.fontStyle).to.equal('normal');\nexpect(documentElement.style.fontVariant).to.equal('normal');\nexpect(documentElement.style.fontWeight).to.equal('normal');\nexpect(documentElement.style.height).to.equal('');\nexpect(documentElement.style.lineCap).to.equal('butt');\nexpect(documentElement.style.lineDashOffset).to.equal('0');\nexpect(documentElement.style.lineJoin).to.equal('miter');\nexpect(documentElement.style.lineWidth).to.equal('1');\nexpect(documentElement.style.opacity).to.equal('');\nexpect(documentElement.style.stroke).to.equal('');\nexpect(documentElement.style.strokeOpacity).to.equal('1');\nexpect(documentElement.style.textTransform).to.equal('none');\nexpect(documentElement.style.textAlign).to.equal('start');\nexpect(documentElement.style.textBaseline).to.equal('alphabetic');\nexpect(documentElement.style.transformOrigin).to.equal('');\nexpect(documentElement.style.visibility).to.equal('visible');\nexpect(documentElement.style.pointerEvents).to.equal('auto');\nexpect(documentElement.style.width).to.equal('');\nexpect(documentElement.style.x).to.equal(0);\nexpect(documentElement.style.y).to.equal(0);\nexpect(documentElement.style.z).to.equal(0);\nexpect(documentElement.style.zIndex).to.equal(0);\n",paraId:13,tocIndex:0},{value:"目前我们支持的可继承属性如下：",paraId:14,tocIndex:1},{value:"属性名",paraId:15,tocIndex:1},{value:"初始值",paraId:15,tocIndex:1},{value:"适用元素",paraId:15,tocIndex:1},{value:"是否可继承",paraId:15,tocIndex:1},{value:"是否支持动画",paraId:15,tocIndex:1},{value:"computed value",paraId:15,tocIndex:1},{value:"fillOpacity",paraId:15,tocIndex:1},{value:"'1'",paraId:15,tocIndex:1},{value:"所有",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"<number>",paraId:15,tocIndex:1},{value:"strokeOpacity",paraId:15,tocIndex:1},{value:"'1'",paraId:15,tocIndex:1},{value:"所有",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"<number>",paraId:15,tocIndex:1},{value:"lineWidth",paraId:15,tocIndex:1},{value:"'1'",paraId:15,tocIndex:1},{value:"所有",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"<length> <percentage>",paraId:15,tocIndex:1},{value:"lineJoin",paraId:15,tocIndex:1},{value:"'miter'",paraId:15,tocIndex:1},{value:"所有",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"否",paraId:15,tocIndex:1},{value:"<keywords>",paraId:15,tocIndex:1},{value:"lineCap",paraId:15,tocIndex:1},{value:"'butt'",paraId:15,tocIndex:1},{value:"所有",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"否",paraId:15,tocIndex:1},{value:"<keywords>",paraId:15,tocIndex:1},{value:"lineDash",paraId:15,tocIndex:1},{value:"无",paraId:15,tocIndex:1},{value:"所有",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"<array>",paraId:15,tocIndex:1},{value:"lineDashOffset",paraId:15,tocIndex:1},{value:"'0'",paraId:15,tocIndex:1},{value:"所有",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"<length> <percentage>",paraId:15,tocIndex:1},{value:"visibility",paraId:15,tocIndex:1},{value:"'visible'",paraId:15,tocIndex:1},{value:"所有",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"否",paraId:15,tocIndex:1},{value:"<keywords>",paraId:15,tocIndex:1},{value:"pointerEvents",paraId:15,tocIndex:1},{value:"'auto'",paraId:15,tocIndex:1},{value:"所有",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"否",paraId:15,tocIndex:1},{value:"<keywords>",paraId:15,tocIndex:1},{value:"fontSize",paraId:15,tocIndex:1},{value:"'16px'",paraId:15,tocIndex:1},{value:"所有",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"<length> <percentage>",paraId:15,tocIndex:1},{value:"fontFamily",paraId:15,tocIndex:1},{value:"'sans-serif'",paraId:15,tocIndex:1},{value:"所有",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"否",paraId:15,tocIndex:1},{value:"<keywords>",paraId:15,tocIndex:1},{value:"fontStyle",paraId:15,tocIndex:1},{value:"'normal'",paraId:15,tocIndex:1},{value:"所有",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"否",paraId:15,tocIndex:1},{value:"<keywords>",paraId:15,tocIndex:1},{value:"fontWeight",paraId:15,tocIndex:1},{value:"'normal'",paraId:15,tocIndex:1},{value:"所有",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"否",paraId:15,tocIndex:1},{value:"<keywords>",paraId:15,tocIndex:1},{value:"fontVariant",paraId:15,tocIndex:1},{value:"'normal'",paraId:15,tocIndex:1},{value:"所有",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"否",paraId:15,tocIndex:1},{value:"<keywords>",paraId:15,tocIndex:1},{value:"textBaseline",paraId:15,tocIndex:1},{value:"'alphabetic'",paraId:15,tocIndex:1},{value:"所有",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"否",paraId:15,tocIndex:1},{value:"<keywords>",paraId:15,tocIndex:1},{value:"textAlign",paraId:15,tocIndex:1},{value:"'start'",paraId:15,tocIndex:1},{value:"所有",paraId:15,tocIndex:1},{value:"是",paraId:15,tocIndex:1},{value:"否",paraId:15,tocIndex:1},{value:"<keywords>",paraId:15,tocIndex:1}]},22773:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(5763);const d=[{value:"我们在 CSS 中会使用到大量的样式属性（",paraId:0},{value:"style",paraId:0},{value:"），有些会影响元素的外观，有些会影响元素的布局：",paraId:0},{value:"div {\n    display: 'flex'; // 使用 Flex 布局\n    color: 'red'; // 字体颜色\n    opacity: 0.5;\n}\n",paraId:1},{value:"在 SVG 中同样存在类似的属性（",paraId:2},{value:"attribute",paraId:2},{value:"），例如绘制一个半径为 5 的红色半透明圆形：",paraId:2},{value:'<circle r="5" fill="red" opacity="0.5" />\n',paraId:3},{value:"两者在部分属性上存在重合，我们将其结合，因此在 G 中实现上述效果可以这么做：",paraId:4},{value:"const circle = new Circle({\n    // 从 CSS 中而来\n    style: {\n        r: 5, // 从 SVG 属性中来\n        fill: 'red', // 从 SVG 属性中来\n        opacity: 0.5, // 两者的重合属性\n    },\n});\n",paraId:5},{value:"在现代浏览器中，",paraId:6},{value:"CSS",paraId:6},{value:" 提供了一系列 API 帮助前端开发者更好地与样式系统这个“黑盒”交互：",paraId:6},{value:"CSS Typed OM",paraId:7},{value:" 将用户传入的字符串转换成 JS 表示，并提供数学运算等工具方法",paraId:7},{value:"CSS Properties & Values API",paraId:7},{value:" 支持自定义样式属性",paraId:7},{value:"CSS Layout API",paraId:7},{value:" 支持自定义布局，实现浏览器中还不支持的布局算法。",paraId:7},{value:"我们参考了 Blink（目前 WebKit 还不支持 CSS Typed OM 等）的实现，设计了一套简易的样式系统（暂不支持样式规则），实现了以上 CSS API。初始化时通过 CSS Properties & Values API 注册了一系列内置属性，在自定义图形中也可以用该方式注册自定义属性。在解析属性时使用 CSS Typed OM 完成，例如 ",paraId:8},{value:"r: 5",paraId:8},{value:" 会被解析成 ",paraId:8},{value:"CSS.px(5)",paraId:8},{value:"。如果用户设置了布局属性 ",paraId:8},{value:"display",paraId:8},{value:"，我们会在布局阶段使用 CSS Layout API 完成布局计算。",paraId:8},{value:"我们希望通过这一套样式系统，让布局变得更简单，用户完全可以避免复杂的手动计算、使用 ",paraId:9},{value:"setPosition()",paraId:9},{value:" 设置元素位置，通过布局属性轻松完成任务。想象一下在浏览器支持 ",paraId:9},{value:"display: flex",paraId:9},{value:" 之前，那些让元素居中的奇技淫巧：",paraId:9},{value:"container.appendChild(child1);\ncontainer.appendChild(child2);\n\n// 设置容器使用 Flex 布局，直接完成子元素的定位\ncontainer.style.display = 'flex';\n\n// or 手动进行一系列复杂的布局计算\nconst [x1, y1, x2, y2] = heavyLifting(container, child1, child2);\nchild1.setPosition(x1, y1);\nchild2.setPosition(x2, y2);\n",paraId:10},{value:"在浏览器中，过去很长一段时间 CSS 的解析对于前端开发者都是一个黑盒。",paraId:11,tocIndex:0},{value:"我们只能通过 ",paraId:12,tocIndex:0},{value:"el.style.width = '50%'",paraId:12,tocIndex:0},{value:" 这样非结构化的字符串与样式系统交互。",paraId:12,tocIndex:0},{value:"不同的样式属性支持不同的类型，例如圆的半径 ",paraId:13,tocIndex:0},{value:"r",paraId:13,tocIndex:0},{value:" 支持长度 ",paraId:13,tocIndex:0},{value:"<length>",paraId:13,tocIndex:0},{value:" 和百分比 ",paraId:13,tocIndex:0},{value:"<percentage>",paraId:13,tocIndex:0},{value:"，我们可以使用字符串表示：",paraId:13,tocIndex:0},{value:"circle.style.r = '5px';\ncircle.style.r = '50%';\n",paraId:14,tocIndex:0},{value:"我们会将这样的字符串解析成 ",paraId:15,tocIndex:0},{value:"CSSStyleValue",paraId:16,tocIndex:0},{value:"，例如 ",paraId:15,tocIndex:0},{value:"CSS.px(5)",paraId:15,tocIndex:0},{value:" 和 ",paraId:15,tocIndex:0},{value:"CSS.percent(50)",paraId:15,tocIndex:0},{value:"，更多信息详见 ",paraId:15,tocIndex:0},{value:"CSS Typed OM",paraId:17,tocIndex:0},{value:"。",paraId:15,tocIndex:0},{value:"显然，一个属性的元数据（是否可以继承、是否支持动画、默认值等）会影响到我们对于属性值的解析。",paraId:18,tocIndex:1}]},69358:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(39869);const d=[{value:"就像可平铺的瓷砖、地板一样，有时我们希望使用重复的相同图案填充图形。",paraId:0},{value:"在该",paraId:1},{value:"示例",paraId:2},{value:"中我们展示了目前支持的 Pattern（模版填充）效果，来源可以包括图片 URL，",paraId:1},{value:"HTMLImageElement",paraId:1},{value:"，",paraId:1},{value:"HTMLCanvasElement",paraId:1},{value:"，",paraId:1},{value:"HTMLVideoElement",paraId:1},{value:" 和 ",paraId:1},{value:"Rect",paraId:3},{value:" 等，同时还可以指定填充重复方向：",paraId:1},{value:"在支持 Pattern 的样式属性（例如 ",paraId:4},{value:"fill",paraId:4},{value:"）中，可以使用一个对象描述，包含来源、填充模式和变换：",paraId:4},{value:"rect.style.fill = {\n    image: 'http://example.png',\n    repetition: 'repeat',\n    transform: 'rotate(30deg)',\n};\n",paraId:5},{value:"支持的参数如下：",paraId:6},{value:"interface Pattern {\n    image: string | CanvasImageSource | Rect;\n    repetition?: 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';\n    transform?: string;\n}\n",paraId:7},{value:"必填。支持以下来源：",paraId:8,tocIndex:0},{value:"图片 URL，例如 ",paraId:9,tocIndex:0},{value:"'http://example.png'",paraId:9,tocIndex:0},{value:"HTMLImageElement",paraId:9,tocIndex:0},{value:"HTMLCanvasElement",paraId:9,tocIndex:0},{value:"HTMLVideoElement",paraId:9,tocIndex:0},{value:"Rect",paraId:10,tocIndex:0},{value:"这是较为常见的一种用法，使用图片 URL 作为 Pattern 来源：",paraId:11,tocIndex:1},{value:"// <img> URL\nrect.style.fill = {\n    image: 'https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*jgjxQ57sACsAAAAAAAAAAAAAARQnAQ',\n    repetition: 'repeat',\n};\n",paraId:12,tocIndex:1},{value:"除了使用图片 URL，还可以传入 ",paraId:13,tocIndex:2},{value:"Image",paraId:13,tocIndex:2},{value:" 对象作为来源：",paraId:13,tocIndex:2},{value:"// HTMLImageElement(<img>)\nconst image = new window.Image();\nimage.onload = () => {\n    const rect2 = new Rect({\n        style: {\n            x: 300,\n            y: 50,\n            width: 200,\n            height: 100,\n            fill: {\n                image,\n                repetition: 'repeat',\n            },\n        },\n    });\n};\nimage.crossOrigin = 'Anonymous';\nimage.src =\n    'https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*jgjxQ57sACsAAAAAAAAAAAAAARQnAQ';\n",paraId:14,tocIndex:2},{value:"<video>",paraId:15,tocIndex:3},{value:" 也可以作为填充来源。",paraId:15,tocIndex:3},{value:"// HTMLVideoElement(<video>)\nconst video = document.createElement('video');\nvideo.src =\n    'https://gw.alipayobjects.com/v/rms_6ae20b/afts/video/A*VD0TTbZB9WMAAAAAAAAAAAAAARQnAQ/720P';\nvideo.crossOrigin = 'Anonymous';\nvideo.autoplay = true;\nvideo.controls = false;\nvideo.muted = true;\nvideo.height = 100;\nvideo.width = 200;\n\nvideo.onloadeddata = function () {\n    const rect5 = new Rect({\n        style: {\n            x: 50,\n            y: 350,\n            width: 200,\n            height: 100,\n            fill: {\n                image: video,\n                repetition: 'no-repeat',\n            },\n        },\n    });\n    canvas.appendChild(rect5);\n};\n",paraId:16,tocIndex:3},{value:"除了使用图片、视频作为来源，还可以使用程序化生成，此时就需要使用到 ",paraId:17,tocIndex:4},{value:"<canvas>",paraId:17,tocIndex:4},{value:" 以及原生 ",paraId:17,tocIndex:4},{value:"Canvas API",paraId:17,tocIndex:4},{value:"。",paraId:17,tocIndex:4},{value:"在该",paraId:18,tocIndex:4},{value:"示例",paraId:19,tocIndex:4},{value:"中，我们使用了 HTMLCanvasElement 先绘制了一个 20 * 20 的模版，再使用它进行填充：",paraId:18,tocIndex:4},{value:"// @see https://observablehq.com/@awoodruff/canvas-cartography-nacis-2019\nconst patternCanvas = document.createElement('canvas');\npatternCanvas.width = 20;\npatternCanvas.height = 20;\nconst ctx = patternCanvas.getContext('2d');\nctx.strokeStyle = '#333';\nctx.lineWidth = 1;\nctx.beginPath();\nfor (let i = 0.5; i < 20; i += 5) {\n    ctx.moveTo(0, i);\n    ctx.lineTo(20, i);\n}\nctx.stroke();\n\nconst rect3 = new Rect({\n    style: {\n        x: 50,\n        y: 200,\n        width: 200,\n        height: 100,\n        fill: {\n            image: patternCanvas,\n            repetition: 'repeat',\n        },\n    },\n});\n",paraId:20,tocIndex:4},{value:"上述使用原生 ",paraId:21,tocIndex:5},{value:"Canvas API",paraId:21,tocIndex:5},{value:" 程序化生成 Pattern 有以下局限性：",paraId:21,tocIndex:5},{value:"如果想在 SVG 渲染器中使用 Canvas API 生成的 Pattern，只能通过引用 Canvas 导出图片的方式，这将导致丧失矢量图的优秀特性，例如放大后变模糊",paraId:22,tocIndex:5},{value:"学习成本高，尤其是复杂 Pattern 定义困难",paraId:22,tocIndex:5},{value:"因此我们希望使用 G 的图形 API 定义 Pattern，与定义场景保持一致。一方面统一的描述能力提升易用性，让用户不必接触底层渲染 API；另一方面也让我们得以在不同渲染器中使用不同的 Pattern 实现，例如在 SVG 中使用原生 ",paraId:23,tocIndex:5},{value:"<pattern>",paraId:23,tocIndex:5},{value:" 提升清晰度，下图为放大后 Canvas 和 SVG 的对比。",paraId:23,tocIndex:5},{value:"在下面的 ",paraId:24,tocIndex:5},{value:"示例",paraId:25,tocIndex:5},{value:" 中，我们创建了一个 ",paraId:24,tocIndex:5},{value:"16 * 16",paraId:24,tocIndex:5},{value:" 的 Pattern，白色背景上包含一个红点。可以看出和常规定义场景的用法别无二致：",paraId:24,tocIndex:5},{value:"const background = new Rect({\n    style: {\n        width: 16,\n        height: 16,\n        fill: 'red',\n    },\n});\nconst dot = new Circle({\n    style: {\n        cx: 8,\n        cy: 8,\n        r: 6,\n        fill: 'white',\n    },\n});\nbackground.appendChild(dot);\n",paraId:26,tocIndex:5},{value:"然后将 Pattern 平铺应用图形上，同时通过 ",paraId:27,tocIndex:5},{value:"transform",paraId:28,tocIndex:5},{value:" 旋转一定角度：",paraId:27,tocIndex:5},{value:"const rect = new Rect({\n    style: {\n        fill: {\n            image: background,\n            repetition: 'repeat',\n            transform: 'rotate(30deg)',\n        },\n    },\n});\n",paraId:29,tocIndex:5},{value:"效果如下：",paraId:30,tocIndex:5},{value:"最后下面提到的 ",paraId:31,tocIndex:5},{value:"g-pattern",paraId:32,tocIndex:5},{value:" 也是通过这种方式定义的。",paraId:31,tocIndex:5},{value:"选填。支持以下模式，可以在该",paraId:33,tocIndex:6},{value:"示例",paraId:34,tocIndex:6},{value:"中查看：",paraId:33,tocIndex:6},{value:"'repeat'",paraId:35,tocIndex:6},{value:" 默认值，沿水平和垂直方向平铺",paraId:35,tocIndex:6},{value:"'repeat-x'",paraId:35,tocIndex:6},{value:" 沿水平方向平铺",paraId:35,tocIndex:6},{value:"'repeat-y'",paraId:35,tocIndex:6},{value:" 沿垂直方向平铺",paraId:35,tocIndex:6},{value:"'no-repeat'",paraId:35,tocIndex:6},{value:" 不平铺",paraId:35,tocIndex:6},{value:"选填。有时我们希望对模式进行变换，例如旋转一定角度，此时可以使用 ",paraId:36,tocIndex:7},{value:"transform",paraId:36,tocIndex:7},{value:" 属性，取值和 CSS Transform 完全一致。",paraId:36,tocIndex:7},{value:"在下面的",paraId:37,tocIndex:7},{value:"示例",paraId:38,tocIndex:7},{value:"中，我们希望让模式旋转起来：",paraId:37,tocIndex:7},{value:"rect.style.fill = {\n    image: canvas,\n    repetition: 'repeat',\n    transform: `rotate(30deg)`,\n};\n",paraId:39,tocIndex:7},{value:"需要注意的是，SVG 中的 ",paraId:40,tocIndex:7},{value:"patternTransform",paraId:40,tocIndex:7},{value:" 和 CSS Transform 的取值有些许不同，矢量图是没有单位的，仅支持 ",paraId:40,tocIndex:7},{value:"transform_functions",paraId:40,tocIndex:7},{value:"，因此例如 ",paraId:40,tocIndex:7},{value:"rotate(20deg)",paraId:40,tocIndex:7},{value:" 需要去掉单位改写成 ",paraId:40,tocIndex:7},{value:"rotate(20)",paraId:40,tocIndex:7},{value:"，",paraId:40,tocIndex:7},{value:"transform(20px, 30px)",paraId:40,tocIndex:7},{value:" 同理。但我们在内部进行了统一处理，因此可以完全使用 CSS Transform 的取值。",paraId:40,tocIndex:7},{value:"参考 ",paraId:41,tocIndex:8},{value:"nivo patterns",paraId:41,tocIndex:8},{value:" 我们提供了一些内置模式，还可以通过更加友好的参数调整外观。目前我们支持以下三种模式：",paraId:41,tocIndex:8},{value:"dots",paraId:42,tocIndex:8},{value:" 由圆点构成的模式",paraId:42,tocIndex:8},{value:"lines",paraId:42,tocIndex:8},{value:" 由直线构成的模式",paraId:42,tocIndex:8},{value:"squares",paraId:42,tocIndex:8},{value:" 由正方形构成的模式",paraId:42,tocIndex:8},{value:"这三种模式方法签名如下，参数为模式的样式配置：",paraId:43,tocIndex:8},{value:"dots(cfg?: DotPatternCfg): HTMLCanvasElement;\nlines(cfg?: LinePatternCfg): HTMLCanvasElement;\nsquares(cfg?: SquarePatternCfg): HTMLCanvasElement;\n",paraId:44,tocIndex:8},{value:"在该",paraId:45,tocIndex:8},{value:"示例",paraId:46,tocIndex:8},{value:"中，我们使用了圆点模式，并通过 ",paraId:45,tocIndex:8},{value:"transform",paraId:47,tocIndex:8},{value:" 对其进行了一些变换：",paraId:45,tocIndex:8},{value:"import { dots } from '@antv/g-pattern';\n\nrect.style.fill = {\n    image: dots({\n        size: 6,\n        padding: 2,\n        fill: '#ff0000',\n        isStagger: true,\n    }),\n    repetition: 'repeat',\n    transform: `rotate(30deg) scale(1.2)`,\n};\n",paraId:48,tocIndex:8},{value:"三种模式支持的样式配置公共属性如下：",paraId:49,tocIndex:8},{value:"属性名",paraId:50,tocIndex:8},{value:"类型",paraId:50,tocIndex:8},{value:"介绍",paraId:50,tocIndex:8},{value:"backgroundColor",paraId:50,tocIndex:8},{value:"string",paraId:50,tocIndex:8},{value:"贴图的背景色，默认值为 ",paraId:50,tocIndex:8},{value:"'transparent'",paraId:50,tocIndex:8},{value:"backgroundOpacity",paraId:50,tocIndex:8},{value:"number",paraId:50,tocIndex:8},{value:"贴图的背景色透明度，默认值为 ",paraId:50,tocIndex:8},{value:"1",paraId:50,tocIndex:8},{value:"fill",paraId:50,tocIndex:8},{value:"string",paraId:50,tocIndex:8},{value:"贴图元素的填充色，",paraId:50,tocIndex:8},{value:"dots",paraId:50,tocIndex:8},{value:" 和 ",paraId:50,tocIndex:8},{value:"squares",paraId:50,tocIndex:8},{value:" 默认值为 ",paraId:50,tocIndex:8},{value:"'#fff'",paraId:50,tocIndex:8},{value:"，",paraId:50,tocIndex:8},{value:"fillOpacity",paraId:50,tocIndex:8},{value:"number",paraId:50,tocIndex:8},{value:"贴图元素填充的透明度，默认值为 1",paraId:50,tocIndex:8},{value:"stroke",paraId:50,tocIndex:8},{value:"string",paraId:50,tocIndex:8},{value:"贴图元素的描边色，",paraId:50,tocIndex:8},{value:"dots",paraId:50,tocIndex:8},{value:" 和 ",paraId:50,tocIndex:8},{value:"squares",paraId:50,tocIndex:8},{value:" 为 ",paraId:50,tocIndex:8},{value:"'transparent'",paraId:50,tocIndex:8},{value:"，",paraId:50,tocIndex:8},{value:"lines",paraId:50,tocIndex:8},{value:" 为 ",paraId:50,tocIndex:8},{value:"'#fff'",paraId:50,tocIndex:8},{value:"strokeOpacity",paraId:50,tocIndex:8},{value:"number",paraId:50,tocIndex:8},{value:"贴图元素的描边透明度色，默认值为 1",paraId:50,tocIndex:8},{value:"lineWidth",paraId:50,tocIndex:8},{value:"number",paraId:50,tocIndex:8},{value:"贴图元素的描边粗细，",paraId:50,tocIndex:8},{value:"dots",paraId:50,tocIndex:8},{value:" 和 ",paraId:50,tocIndex:8},{value:"squares",paraId:50,tocIndex:8},{value:" 为 ",paraId:50,tocIndex:8},{value:"0",paraId:50,tocIndex:8},{value:"，",paraId:50,tocIndex:8},{value:"lines",paraId:50,tocIndex:8},{value:" 为 ",paraId:50,tocIndex:8},{value:"2",paraId:50,tocIndex:8},{value:"opacity",paraId:50,tocIndex:8},{value:"number",paraId:50,tocIndex:8},{value:"贴图元素整体的透明度，默认值为 1",paraId:50,tocIndex:8},{value:"dots",paraId:51,tocIndex:9},{value:" 模式支持额外配置如下，",paraId:51,tocIndex:9},{value:"示例",paraId:52,tocIndex:9},{value:"：",paraId:51,tocIndex:9},{value:"属性名",paraId:53,tocIndex:9},{value:"类型",paraId:53,tocIndex:9},{value:"介绍",paraId:53,tocIndex:9},{value:"size",paraId:53,tocIndex:9},{value:"number",paraId:53,tocIndex:9},{value:"圆点的大小，默认为 6",paraId:53,tocIndex:9},{value:"padding",paraId:53,tocIndex:9},{value:"number",paraId:53,tocIndex:9},{value:"圆点之间的间隔，默认为 2",paraId:53,tocIndex:9},{value:"isStagger",paraId:53,tocIndex:9},{value:"boolean",paraId:53,tocIndex:9},{value:"圆点之间是否交错，默认为 true",paraId:53,tocIndex:9},{value:"lines",paraId:54,tocIndex:10},{value:" 模式支持额外配置如下，",paraId:54,tocIndex:10},{value:"示例",paraId:55,tocIndex:10},{value:"：",paraId:54,tocIndex:10},{value:"属性名",paraId:56,tocIndex:10},{value:"类型",paraId:56,tocIndex:10},{value:"介绍",paraId:56,tocIndex:10},{value:"spacing",paraId:56,tocIndex:10},{value:"number",paraId:56,tocIndex:10},{value:"两条线之间的距离，默认为 5",paraId:56,tocIndex:10},{value:"squares",paraId:57,tocIndex:11},{value:" 模式支持额外配置如下，",paraId:57,tocIndex:11},{value:"示例",paraId:58,tocIndex:11},{value:"：",paraId:57,tocIndex:11},{value:"属性名",paraId:59,tocIndex:11},{value:"类型",paraId:59,tocIndex:11},{value:"介绍",paraId:59,tocIndex:11},{value:"size",paraId:59,tocIndex:11},{value:"number",paraId:59,tocIndex:11},{value:"矩形的大小，默认为 6",paraId:59,tocIndex:11},{value:"padding",paraId:59,tocIndex:11},{value:"number",paraId:59,tocIndex:11},{value:"矩形之间的间隔，默认为 1",paraId:59,tocIndex:11},{value:"isStagger",paraId:59,tocIndex:11},{value:"boolean",paraId:59,tocIndex:11},{value:"矩形之间是否交错，默认为 true",paraId:59,tocIndex:11},{value:"不能。使用 Rect 描述 Pattern 是非常合适的，其宽高刚好可以作为 Pattern 的尺寸，而填充色也代表了背景色。",paraId:60,tocIndex:13},{value:"在描述复杂 pattern 时利用场景图能力，可以在其中添加基础图形作为其子元素。",paraId:61,tocIndex:13},{value:"暂不支持。如果要更新，请重新创建一个 Rect。",paraId:62,tocIndex:14},{value:"不再推荐使用 4.0 中支持的如下格式，可以看出无论在记忆成本还是表达能力上都有很大局限性。",paraId:63,tocIndex:15},{value:"p",paraId:64,tocIndex:15},{value:": 表示使用纹理，绿色的字体为可变量，由用户自己填写。",paraId:64,tocIndex:15},{value:"a",paraId:64,tocIndex:15},{value:": 该模式在水平和垂直方向重复；",paraId:64,tocIndex:15},{value:"x",paraId:64,tocIndex:15},{value:": 该模式只在水平方向重复；",paraId:64,tocIndex:15},{value:"y",paraId:64,tocIndex:15},{value:": 该模式只在垂直方向重复；",paraId:64,tocIndex:15},{value:"n",paraId:64,tocIndex:15},{value:": 该模式只显示一次（不重复）。",paraId:64,tocIndex:15},{value:"纹理的内容可以直接是图片或者 ",paraId:64,tocIndex:15},{value:"Data URLs",paraId:64,tocIndex:15},{value:"。",paraId:64,tocIndex:15},{value:"// example\n// 使用纹理填充，在水平和垂直方向重复图片\nfill: 'p(a)https://gw.alipayobjects.com/zos/rmsportal/ibtwzHXSxomqbZCPMLqS.png';\n",paraId:65,tocIndex:15}]},82033:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(81507);const d=[{value:"Web Components",paraId:0},{value:" 允许扩展浏览器内置的 HTML 元素并完成复用。在使用声明式写法的同时，这也是一种与视图层（React Vue Svelte 等）无关的方案。当然如果有需要，视图层也很容易基于它继续封装。",paraId:0},{value:"在该 ",paraId:1},{value:"示例",paraId:2},{value:" 中，我们使用 HTML 语法定义",paraId:1},{value:"场景图",paraId:3},{value:"，避免了大量诸如 ",paraId:1},{value:"appendChild",paraId:4},{value:" 这样的命令式调用。而对于各个图形则非常类似 SVG 的用法，属性值都以字符串形式存在。",paraId:1},{value:'<g-canvas renderer="canvas" width="400" height="400">\n    <g-rect\n        fill="#2f54eb"\n        radius="0 24px 24px"\n        x="12px"\n        y="24px"\n        width="200px"\n        height="50px"\n    >\n        <g-circle fill="#adc6ff" r="16px" cx="25px" cy="25px"></g-circle>\n        <g-text fill="#fff" x="50px" y="20px">我是一段文字</g-text>\n    </g-rect>\n</g-canvas>\n',paraId:5},{value:"局限性：",paraId:6},{value:"自定义元素的属性值只支持 ",paraId:7},{value:"string",paraId:7},{value:" 和 ",paraId:7},{value:"boolean",paraId:7},{value:"事件绑定这样必须要使用命令式 API 的情况下，需要使用 ",paraId:7},{value:"ref",paraId:7},{value:"同样有以下两种使用方式。",paraId:8,tocIndex:0},{value:"使用 CDN：",paraId:9,tocIndex:0},{value:'<script src="https://unpkg.com/@antv/g"><\/script>\n<script src="https://unpkg.com/@antv/g-canvas"><\/script>\n<script src="https://unpkg.com/@antv/g-web-components"><\/script>\n',paraId:10,tocIndex:0},{value:"使用 NPM module:",paraId:11,tocIndex:0},{value:"import '@antv/g';\nimport '@antv/g-canvas';\nimport '@antv/g-web-components';\n",paraId:12,tocIndex:0},{value:"安装完成之后会使用 ",paraId:13,tocIndex:0},{value:"CustomElementRegistry.define()",paraId:13,tocIndex:0},{value:" 自动完成相关组件的注册。",paraId:13,tocIndex:0},{value:"目前支持以下自定义元素。大部分都可以参考对应图形的命令式 API。",paraId:14,tocIndex:1},{value:' type="button" class="ant-btn ant-btn-text ant-btn-icon-only button comment-link">',paraId:15},{value:' type="button" class="ant-btn ant-btn-text ant-btn-icon-only button comment-link">',paraId:15},{value:"可参考 ",paraId:16,tocIndex:3},{value:"Circle",paraId:17,tocIndex:3},{value:"。",paraId:16,tocIndex:3},{value:' type="button" class="ant-btn ant-btn-text ant-btn-icon-only button comment-link">',paraId:15},{value:"可参考 ",paraId:18,tocIndex:4},{value:"Ellipse",paraId:19,tocIndex:4},{value:"。",paraId:18,tocIndex:4},{value:' type="button" class="ant-btn ant-btn-text ant-btn-icon-only button comment-link">',paraId:15},{value:"可参考 ",paraId:20,tocIndex:5},{value:"Rect",paraId:21,tocIndex:5},{value:"。",paraId:20,tocIndex:5},{value:"需要注意 ",paraId:22,tocIndex:5},{value:"radius",paraId:23,tocIndex:5},{value:" 需要使用数组字符串形式：",paraId:22,tocIndex:5},{value:'<g-rect\n    radius="0 24px 24px"\n    x="12px"\n    y="24px"\n    width="200px"\n    height="50px"\n></g-rect>\n',paraId:24,tocIndex:5},{value:' type="button" class="ant-btn ant-btn-text ant-btn-icon-only button comment-link">',paraId:15},{value:"可参考 ",paraId:25,tocIndex:6},{value:"Line",paraId:26,tocIndex:6},{value:"。",paraId:25,tocIndex:6},{value:' type="button" class="ant-btn ant-btn-text ant-btn-icon-only button comment-link">',paraId:15},{value:"可参考 ",paraId:27,tocIndex:7},{value:"Path",paraId:28,tocIndex:7},{value:"。",paraId:27,tocIndex:7},{value:"需要注意路径定义一定要使用字符串形式。",paraId:29,tocIndex:7},{value:'<g-path\n    transform="translate(0, 100px)"\n    stroke="#2f54eb"\n    path="M 0,40 C 5.5555555555555545,40,22.222222222222218,44.44444444444445,33.33333333333333,40 C 44.444444444444436, ..."\n></g-path>\n',paraId:30,tocIndex:7}]},68855:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(66565);const d=[{value:"我们提供了一款 Chrome 浏览器插件，用于开发时审查画布中的元素。",paraId:0},{value:"https://github.com/antvis/g/tree/next/packages/g-devtool",paraId:1}]},90588:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(38052);const d=[{value:"G 内置了一些渲染相关的统计信息，可以通过 ",paraId:0},{value:"canvas.getStats",paraId:0},{value:" 获取，例如在每一帧中获取：",paraId:0},{value:"import { CanvasEvent } from '@antv/g';\n\ncanvas.addEventListener(CanvasEvent.AFTER_RENDER, () => {\n    canvas.getStats(); // { total: 0, rendered: 0 }\n});\n",paraId:1},{value:"目前包含的统计信息如下：",paraId:2},{value:"total 当前帧中需要渲染的图形总数",paraId:3},{value:"rendered 当前帧中实际渲染的图形数目",paraId:3},{value:"其中 total 不一定等于当前场景中包含的图形数量，例如相比上一帧，当前帧所有图形都没有发生变化，此时不应该发生重绘，total 为 0。",paraId:4},{value:"在某些情况下 rendered 会比 total 少，例如图形被剔除（处于视口 / 视锥范围之外）。",paraId:5}]},96456:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(7426);const d=[{value:"在使用 G 开发时，有很多通用的第三方工具可以辅助我们开发调试。",paraId:0},{value:"stats.js",paraId:1,tocIndex:0},{value:" 常用于展示 FPS。配合 G 使用时可以监听 ",paraId:1,tocIndex:0},{value:"CanvasEvent 画布事件",paraId:2,tocIndex:0},{value:"，在每一帧结束时更新：",paraId:1,tocIndex:0},{value:"import { CanvasEvent } from '@antv/g';\n\n// 创建 stats\nconst stats = new Stats();\nstats.showPanel(0);\nconst $stats = stats.dom;\n$stats.style.position = 'absolute';\n$stats.style.left = '0px';\n$stats.style.top = '0px';\nconst $wrapper = document.getElementById('container');\n$wrapper.appendChild($stats);\n\n// 在每一帧结束时刷新帧数\ncanvas.addEventListener(CanvasEvent.AFTER_RENDER, () => {\n    stats.update();\n});\n",paraId:3,tocIndex:0},{value:"如果使用 ",paraId:4,tocIndex:1},{value:"g-webgl",paraId:4,tocIndex:1},{value:" 作为",paraId:4,tocIndex:1},{value:"渲染器",paraId:5,tocIndex:1},{value:"，可以安装 Chrome 浏览器插件 ",paraId:4,tocIndex:1},{value:"Spector.js",paraId:4,tocIndex:1},{value:"，捕获当前帧执行的所有 WebGL API：",paraId:4,tocIndex:1}]},85359:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(97319);const d=[{value:"在事件监听器的回调函数中，我们可以取得事件对象并访问其上的属性和方法。这些属性和方法和 DOM Event API 保持一致，因此可以直接参考它们的文档。",paraId:0},{value:"我们会尽量将原生事件规范化到 ",paraId:1},{value:"PointerEvent",paraId:1},{value:" 事件对象后统一处理，可以在 ",paraId:1},{value:"nativeEvent",paraId:2},{value:" 上访问原生事件。",paraId:1},{value:"事件对象上常用的属性包括事件类型、当前触发事件的图形、位置等，其中位置和",paraId:3,tocIndex:0},{value:"坐标系",paraId:4,tocIndex:0},{value:"相关。",paraId:3,tocIndex:0},{value:"事件类型：",paraId:5,tocIndex:1},{value:"pointerup",paraId:6,tocIndex:1},{value:"pointerdown",paraId:6,tocIndex:1},{value:"pointerupoutside",paraId:6,tocIndex:1},{value:"pointermove",paraId:6,tocIndex:1},{value:"pointercancel",paraId:6,tocIndex:1},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Event/type",paraId:7,tocIndex:1},{value:"原生事件对象。当我们调用 ",paraId:8,tocIndex:2},{value:"preventDefault",paraId:9,tocIndex:2},{value:" 方法时，会调用原生事件对象上的同名方法。",paraId:8,tocIndex:2},{value:"指向 ",paraId:10,tocIndex:3},{value:"Canvas",paraId:11,tocIndex:3},{value:"。",paraId:10,tocIndex:3},{value:"https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/view",paraId:12,tocIndex:3},{value:"事件触发时是否伴随 ",paraId:13,tocIndex:4},{value:"alt",paraId:13,tocIndex:4},{value:" 的按下。",paraId:13,tocIndex:4},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/altKey",paraId:14,tocIndex:4},{value:"事件触发时是否伴随 ",paraId:15,tocIndex:5},{value:"meta",paraId:15,tocIndex:5},{value:" 的按下。",paraId:15,tocIndex:5},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/metaKey",paraId:16,tocIndex:5},{value:"事件触发时是否伴随 ",paraId:17,tocIndex:6},{value:"ctrl",paraId:17,tocIndex:6},{value:" 的按下。",paraId:17,tocIndex:6},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/ctrlKey",paraId:18,tocIndex:6},{value:"事件触发时是否伴随 ",paraId:19,tocIndex:7},{value:"shift",paraId:19,tocIndex:7},{value:" 的按下。",paraId:19,tocIndex:7},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/shiftKey",paraId:20,tocIndex:7},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Event/timeStamp",paraId:21,tocIndex:8},{value:"事件创建时的时间戳",paraId:22,tocIndex:8},{value:"当前所处的事件阶段。有以下三个枚举值：",paraId:23,tocIndex:9},{value:"CAPTURING_PHASE = 1;\nAT_TARGET = 2;\nBUBBLING_PHASE = 3;\n",paraId:24,tocIndex:9},{value:"例如配合 ",paraId:25,tocIndex:9},{value:"capture",paraId:25,tocIndex:9},{value:" 配置项，仅在捕获阶段处理事件：",paraId:25,tocIndex:9},{value:"circle.addEventListener(\n    'click',\n    (e: FederatedEvent) => {\n        console.log(e.eventPhase); // e.CAPTURING_PHASE\n    },\n    { capture: true },\n);\n",paraId:26,tocIndex:9},{value:"事件对象携带的数据对象。例如在触发 click 时，会带上点击次数。",paraId:27,tocIndex:10},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent/detail",paraId:28,tocIndex:10},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Event/target",paraId:29,tocIndex:11},{value:"当前触发事件的 ",paraId:30,tocIndex:11},{value:"EventTarget",paraId:31,tocIndex:11},{value:"。",paraId:30,tocIndex:11},{value:"在实现事件委托时很有用，例如有这样一个场景，类似 DOM 中的 ",paraId:32,tocIndex:11},{value:"ul/li",paraId:32,tocIndex:11},{value:"：",paraId:32,tocIndex:11},{value:"Group(ul) - Rect(li) - Rect(li);\n",paraId:33,tocIndex:11},{value:"我们可以在 ",paraId:34,tocIndex:11},{value:"ul",paraId:34,tocIndex:11},{value:" 上监听事件，当点击每一个 ",paraId:34,tocIndex:11},{value:"li",paraId:34,tocIndex:11},{value:" 时都会触发：",paraId:34,tocIndex:11},{value:"const ul = new Group();\nconst li1 = new Rect();\nconst li2 = new Rect();\nul.appendChild(li1);\nul.appendChild(li2);\n\nul.addEventListener(\n    'click',\n    (e) => {\n        e.target; // li1 或者 li2\n        e.currentTarget; // ul\n    },\n    false,\n);\n",paraId:35,tocIndex:11},{value:"示例",paraId:36},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Event/currentTarget",paraId:37,tocIndex:12},{value:"总是指向事件绑定的元素。",paraId:38,tocIndex:12},{value:"ul.addEventListener(\n    'click',\n    (e) => {\n        e.currentTarget; // ul\n    },\n    false,\n);\n",paraId:39,tocIndex:12},{value:"在 ",paraId:40,tocIndex:13},{value:"Canvas 坐标系/世界坐标系",paraId:41,tocIndex:13},{value:"下，以画布 DOM 元素的左上角为原点，X 轴正向指向屏幕右侧，Y 轴正向指向屏幕下方。可以与 ",paraId:40,tocIndex:13},{value:"viewportX/Y",paraId:42,tocIndex:13},{value:" 互相转换，",paraId:40,tocIndex:13},{value:"详见",paraId:43,tocIndex:13},{value:"：",paraId:40,tocIndex:13},{value:"canvas.canvas2Viewport({ x: e.canvasX, y: e.canvasY }); // Point { x: 100, y: 100 }\ncanvas.viewport2Canvas({ x: e.viewportX, y: e.viewportY }); // Point { x: 0, y: 0 }\n",paraId:44,tocIndex:13},{value:"别名为 x/y，因此以下写法等价：",paraId:45,tocIndex:13},{value:"e.canvasX;\ne.x;\n\ne.canvasY;\ne.y;\n",paraId:46,tocIndex:13},{value:"在 ",paraId:47,tocIndex:14},{value:"Viewport 坐标系",paraId:48,tocIndex:14},{value:"下，考虑相机变换。",paraId:47,tocIndex:14},{value:"可以与 ",paraId:49,tocIndex:14},{value:"canvasX/Y",paraId:50,tocIndex:14},{value:" 互相转换，",paraId:49,tocIndex:14},{value:"详见",paraId:51,tocIndex:14},{value:"：",paraId:49,tocIndex:14},{value:"canvas.canvas2Viewport({ x: e.canvasX, y: e.canvasY }); // Point { x: 100, y: 100 }\ncanvas.viewport2Canvas({ x: e.viewportX, y: e.viewportY }); // Point { x: 0, y: 0 }\n",paraId:52,tocIndex:14},{value:"可以与 ",paraId:53,tocIndex:14},{value:"clientX/Y",paraId:54,tocIndex:14},{value:" 互相转换，",paraId:53,tocIndex:14},{value:"详见",paraId:55,tocIndex:14},{value:"：",paraId:53,tocIndex:14},{value:"canvas.viewport2Client({ x: 0, y: 0 }); // Point { x: 100, y: 100 }\ncanvas.client2Viewport({ x: 100, y: 100 }); // Point { x: 0, y: 0 }\n",paraId:56,tocIndex:14},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/clientX",paraId:57,tocIndex:15},{value:"在",paraId:58,tocIndex:15},{value:"浏览器坐标系",paraId:59,tocIndex:15},{value:"下，左上角为 ",paraId:58,tocIndex:15},{value:"(0, 0)",paraId:58,tocIndex:15},{value:"。G 不会修改原生事件上的该属性，因此两者完全相同：",paraId:58,tocIndex:15},{value:"e.clientX;\ne.nativeEvent.clientX;\n",paraId:60,tocIndex:15},{value:"可以与 ",paraId:61,tocIndex:15},{value:"viewportX/Y",paraId:62,tocIndex:15},{value:" 互相转换，",paraId:61,tocIndex:15},{value:"详见",paraId:63,tocIndex:15},{value:"：",paraId:61,tocIndex:15},{value:"canvas.viewport2Client({ x: 0, y: 0 }); // Point { x: 100, y: 100 }\ncanvas.client2Viewport({ x: 100, y: 100 }); // Point { x: 0, y: 0 }\n",paraId:64,tocIndex:15},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/screenX",paraId:65,tocIndex:16},{value:"在",paraId:66,tocIndex:16},{value:"屏幕坐标系",paraId:67,tocIndex:16},{value:"下，不考虑页面滚动。G 不会修改原生事件上的该属性，因此两者完全相同：",paraId:66,tocIndex:16},{value:"e.screenX;\ne.nativeEvent.screenX;\n",paraId:68,tocIndex:16},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/pageX",paraId:69,tocIndex:17},{value:"在",paraId:70,tocIndex:17},{value:"文档坐标系",paraId:71,tocIndex:17},{value:"下，考虑页面滚动。G 不会修改原生事件上的该属性，因此两者完全相同：",paraId:70,tocIndex:17},{value:"e.pageX;\ne.nativeEvent.pageX;\n",paraId:72,tocIndex:17},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/movementX",paraId:73,tocIndex:18},{value:"当前事件和上一个 ",paraId:74,tocIndex:18},{value:"mousemove",paraId:74,tocIndex:18},{value:" 事件之间鼠标在水平方向上的移动值。换句话说，这个值是这样计算的: ",paraId:74,tocIndex:18},{value:"currentEvent.movementX = currentEvent.screenX - previousEvent.screenX",paraId:74,tocIndex:18},{value:"返回事件的设备类型，返回值如下：",paraId:75,tocIndex:20},{value:"pointer 代表 ",paraId:76,tocIndex:20},{value:"PointerEvent",paraId:76,tocIndex:20},{value:"mouse 代表 ",paraId:76,tocIndex:20},{value:"MouseEvent",paraId:76,tocIndex:20},{value:"touch 代表 ",paraId:76,tocIndex:20},{value:"TouchEvent",paraId:76,tocIndex:20},{value:"https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType",paraId:77,tocIndex:20},{value:"返回一个可以唯一地识别和触摸平面接触的点的值。这个值在这根手指（或触摸笔等）所引发的所有事件中保持一致，直到它离开触摸平面。",paraId:78,tocIndex:21},{value:"https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId",paraId:79,tocIndex:21},{value:"是否是 primary pointer。在多指触控场景下，代表当前事件由主触点产生。",paraId:80,tocIndex:22},{value:"https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary",paraId:81,tocIndex:22},{value:"标识鼠标事件哪个按键被点击。0 为左键，1 为鼠标滚轮，2 为右键。",paraId:82,tocIndex:23},{value:"https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button",paraId:83,tocIndex:23},{value:"https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons",paraId:84,tocIndex:24},{value:"接触面积宽度。如果原生事件为 MouseEvent，返回 1。",paraId:85,tocIndex:25},{value:"https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width",paraId:86,tocIndex:25},{value:"接触面积高度。如果原生事件为 MouseEvent，返回 1。",paraId:87,tocIndex:26},{value:"https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height",paraId:88,tocIndex:26},{value:"触点与屏幕在 Y-Z 平面上的角度。如果原生事件为 MouseEvent 返回固定值 ",paraId:89,tocIndex:27},{value:"0",paraId:89,tocIndex:27},{value:"。",paraId:89,tocIndex:27},{value:"https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX",paraId:90,tocIndex:27},{value:"触点与屏幕在 X-Z 平面上的角度。如果原生事件为 MouseEvent 返回固定值 ",paraId:91,tocIndex:28},{value:"0",paraId:91,tocIndex:28},{value:"。",paraId:91,tocIndex:28},{value:"https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY",paraId:92,tocIndex:28},{value:"返回对应的手指挤压触摸平面的压力大小，从 ",paraId:93,tocIndex:29},{value:"0.0",paraId:93,tocIndex:29},{value:" (没有压力)到 ",paraId:93,tocIndex:29},{value:"1.0",paraId:93,tocIndex:29},{value:" (最大压力)的浮点数。如果原生事件为 MouseEvent 返回固定值 ",paraId:93,tocIndex:29},{value:"0.5",paraId:93,tocIndex:29},{value:"。",paraId:93,tocIndex:29},{value:"https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure",paraId:94,tocIndex:29},{value:"https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tangentialPressure",paraId:95,tocIndex:30},{value:"顺时针旋转角度。如果原生事件为 MouseEvent 返回固定值 ",paraId:96,tocIndex:31},{value:"0",paraId:96,tocIndex:31},{value:"。",paraId:96,tocIndex:31},{value:"https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/twist",paraId:97,tocIndex:31},{value:"在鼠标滚轮事件中，可以获取滚动量。",paraId:98,tocIndex:32},{value:"WheelEvent",paraId:99,tocIndex:33},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/WheelEvent",paraId:100,tocIndex:33},{value:"滚轮的横向/纵向/Z 轴的滚动量。",paraId:101,tocIndex:33},{value:"事件对象上的某些方法可以控制事件传播时的行为，例如阻止冒泡等。",paraId:102,tocIndex:34},{value:"阻止监听同一事件的其他事件监听器被调用，同时阻止冒泡。",paraId:103,tocIndex:35},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation",paraId:104,tocIndex:35},{value:"例如在图形上绑定了多个 click 监听器：",paraId:105,tocIndex:35},{value:"// group -> circle\n\ncircle.on(\n    'click',\n    () => {\n        // 正常执行\n    },\n    false,\n);\n\ncircle.on(\n    'click',\n    (e) => {\n        // 正常执行\n        e.stopImmediatePropagation();\n    },\n    false,\n);\n\ncircle.on(\n    'click',\n    () => {\n        // 之后注册的监听器，不会执行\n    },\n    false,\n);\n\ngroup.on(\n    'click',\n    () => {\n        // 由于阻止了向上冒泡，同样不会执行\n    },\n    false,\n);\n",paraId:106,tocIndex:35},{value:"阻止捕获和冒泡阶段中当前事件的进一步传播。",paraId:107,tocIndex:36},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation",paraId:108,tocIndex:36},{value:"与 ",paraId:109,tocIndex:36},{value:"stopImmediatePropagation",paraId:109,tocIndex:36},{value:" 的区别是并不会阻止监听同一事件的其他事件监听器被调用。",paraId:109,tocIndex:36},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault",paraId:110,tocIndex:37},{value:"阻止浏览器默认行为。对于 Passive 事件调用该方法无效，并且会抛出警告。",paraId:111,tocIndex:37},{value:"关于 wheel 事件的解决方案可以参考：",paraId:112,tocIndex:37},{value:"在 Chrome 中禁止页面默认滚动行为",paraId:113,tocIndex:37},{value:"。",paraId:112,tocIndex:37},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Event/composedPath",paraId:114,tocIndex:38},{value:"返回事件路径，是包含 ",paraId:115,tocIndex:38},{value:"EventTarget",paraId:116,tocIndex:38},{value:" 的数组，类似旧版 G 中的 ",paraId:115,tocIndex:38},{value:"propagationPath",paraId:115,tocIndex:38},{value:"。在这个数组中，",paraId:115,tocIndex:38},{value:"event.target",paraId:115,tocIndex:38},{value:" 为数组的第一个元素，",paraId:115,tocIndex:38},{value:"场景图根节点",paraId:117,tocIndex:38},{value:"、",paraId:115,tocIndex:38},{value:"Document",paraId:118,tocIndex:38},{value:" 和 ",paraId:115,tocIndex:38},{value:"Canvas",paraId:119,tocIndex:38},{value:" 为数组末尾的三个元素。",paraId:115,tocIndex:38},{value:"仍然以类似 DOM ",paraId:120,tocIndex:38},{value:"ul/li",paraId:120,tocIndex:38},{value:" 场景为例：",paraId:120,tocIndex:38},{value:"Group(ul) - Rect(li) - Rect(li);\n",paraId:121,tocIndex:38},{value:"在 ",paraId:122,tocIndex:38},{value:"ul",paraId:122,tocIndex:38},{value:" 上监听事件，当点击每一个 ",paraId:122,tocIndex:38},{value:"li",paraId:122,tocIndex:38},{value:" 时都会触发，事件传播路径为 ",paraId:122,tocIndex:38},{value:"[li1, ul, Group, Document, Canvas]",paraId:122,tocIndex:38},{value:"：",paraId:122,tocIndex:38},{value:"const ul = new Group();\nconst li1 = new Rect();\nconst li2 = new Rect();\nul.appendChild(li1);\nul.appendChild(li2);\n\nul.addEventListener(\n    'click',\n    (e) => {\n        const path = e.composedPath(); // [li1, ul, Group, Document, Canvas];\n    },\n    false,\n);\n",paraId:123,tocIndex:38},{value:"示例",paraId:124},{value:"目前在事件系统中会重复使用事件对象，避免大量事件对象的创建。被重复使用的对象仅用于携带不同的数据，例如坐标信息、原生事件对象等，因此生命周期限定在事件处理器内，一旦试图缓存整个事件对象并在事件处理器之外使用，就会导致意料之外的结果。因此推荐缓存事件对象上携带的数据而非对象本身。",paraId:125,tocIndex:39},{value:"在保留上述性能考虑的基础上，我们也提供了一个 clone 方法，当用户真的想缓存时会创建新的事件对象，例如：",paraId:126,tocIndex:39},{value:"circle.addEventListener('click', (e) => {\n    const newEvent = e.clone();\n});\n",paraId:127,tocIndex:39},{value:"克隆后的事件对象将保留原事件对象上的一切属性。",paraId:128,tocIndex:39},{value:"目前我们暂时只支持交互事件，即 ",paraId:129,tocIndex:39},{value:"PointerEvent",paraId:130,tocIndex:39},{value:" 和 ",paraId:129,tocIndex:39},{value:"WheelEvent",paraId:131,tocIndex:39},{value:"。其他事件例如 AnimationEvent 和 CustomEvent 暂不支持。",paraId:129,tocIndex:39}]},11621:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(21360);const d=[{value:"参考 ",paraId:0,tocIndex:0},{value:"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#the_value_of_this_within_the_handler",paraId:0,tocIndex:0},{value:"在事件监听器内部 ",paraId:1,tocIndex:0},{value:"this",paraId:1,tocIndex:0},{value:" 指向应该与 ",paraId:1,tocIndex:0},{value:"e.currentTarget",paraId:1,tocIndex:0},{value:" 相同。但如果使用了箭头函数，将丢失上下文：",paraId:1,tocIndex:0},{value:"circle.addEventListener('mouseenter', function (e) {\n    console.log(this); // circle\n    console.log(e.currentTarget === this); // true\n});\n\ncircle.addEventListener('mouseleave', () => {\n    console.log(this); // undefined\n});\n",paraId:2,tocIndex:0},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mouseenter_event",paraId:3,tocIndex:1},{value:"mouseenter 不会冒泡，而 mouseover 会。同理 mouseleave 不会冒泡，而 mouseout 会。",paraId:4,tocIndex:1},{value:"事件系统只会响应 Canvas 画布范围之内的事件，例如监听了 mousemove 时，在画布之外的其他页面区域移动并不会触发该事件处理器。当拾取到画布空白区域（未命中任何可见图形）时，事件对象的 ",paraId:5,tocIndex:2},{value:"target",paraId:6,tocIndex:2},{value:" 属性会返回 ",paraId:5,tocIndex:2},{value:"Document",paraId:7,tocIndex:2},{value:"：",paraId:5,tocIndex:2},{value:"canvas.addEventListener('mousemove', (e) => {\n    if (e.target.nodeName === 'document') {\n        // 在空白区域移动\n    }\n});\n",paraId:8,tocIndex:2},{value:"一些内置事件有触发顺序，例如 click 事件会在 pointerdown 和 pointerup 触发之后。在这个过程中，有可能出现 pointerdown 和 pointerup 事件 target 不一致的情况。例如在一个图形上按下鼠标，移动到另一个图形上再抬起鼠标，此时我们会在这两个 target 共同的祖先节点上（例如场景图的根节点 ",paraId:9,tocIndex:3},{value:"document.documentElement",paraId:10,tocIndex:3},{value:"）触发 click 事件。",paraId:9,tocIndex:3},{value:"可以在",paraId:11,tocIndex:3},{value:"这个例子",paraId:12,tocIndex:3},{value:"中尝试。",paraId:11,tocIndex:3},{value:"有时我们需要禁止掉页面默认的滚动行为，例如实现缩放类的需求时。禁用默认行为可以使用 ",paraId:13,tocIndex:4},{value:"preventDefault",paraId:14,tocIndex:4},{value:"，但以下代码在 Chrome 中执行并不会生效，页面依然可以滚动：",paraId:13,tocIndex:4},{value:"canvas.addEventListener('wheel', (e) => {\n  e.preventDefault();\n});\n",paraId:15,tocIndex:4},{value:"造成这个问题的原因是 G 在监听画布事件的 wheel 事件时，添加了 ",paraId:16,tocIndex:4},{value:"passive: true",paraId:16,tocIndex:4},{value:" 这个配置项：",paraId:16,tocIndex:4},{value:"// $el 为画布的 DOM 元素，g-canvas/webgl 为 <canvas>，g-svg 为 <svg>\n$el.addEventListener('wheel', onPointerWheel, {\n    passive: true,\n    capture: true,\n});\n",paraId:17,tocIndex:4},{value:"关于 Passive 事件处理器，可以参考知乎的这篇文章：",paraId:18,tocIndex:4},{value:"https://zhuanlan.zhihu.com/p/24555031",paraId:18,tocIndex:4},{value:" 。简而言之是通过这个选项可以提升浏览器的滚动流畅度，相当于提前告知浏览器“我不会阻止你的默认滚动行为”。",paraId:18,tocIndex:4},{value:"现在回到我们的问题，如果用户确实需要禁止默认滚动行为，可以在画布的 DOM 节点上手动添加一个非 Passive 的事件处理器，",paraId:19,tocIndex:4},{value:"g-plugin-control",paraId:19,tocIndex:4},{value:" 插件就是这么做的。如何获取画布的 DOM 节点可以使用 ",paraId:19,tocIndex:4},{value:"getDomElement",paraId:20,tocIndex:4},{value:"：",paraId:19,tocIndex:4},{value:"canvas\n    .getContextService()\n    .getDomElement() // g-canvas/webgl 为 <canvas>，g-svg 为 <svg>\n    .addEventListener(\n        'wheel',\n        (e) => {\n            e.preventDefault();\n        },\n        { passive: false },\n    );\n",paraId:21,tocIndex:4},{value:"其他绝大部分原生事件，尤其是需要绑定在 window/document 上的键盘、剪切板事件用法在 G 中并没有特殊之处，可以直接参考相关事件文档。",paraId:22,tocIndex:5},{value:"有时我们想禁用掉浏览器默认的右键菜单，此时可以在 ",paraId:23,tocIndex:6},{value:"contextmenu",paraId:23,tocIndex:6},{value:" 事件处理函数中通过 ",paraId:23,tocIndex:6},{value:"preventDefault()",paraId:23,tocIndex:6},{value:" 方法禁用默认行为。如何获取画布的 DOM 节点可以使用 ",paraId:23,tocIndex:6},{value:"getDomElement",paraId:24,tocIndex:6},{value:"：",paraId:23,tocIndex:6},{value:"canvas\n    .getContextService()\n    .getDomElement() // g-canvas/webgl 为 <canvas>，g-svg 为 <svg>\n    .addEventListener('contextmenu', (e) => {\n        e.preventDefault();\n    });\n",paraId:25,tocIndex:6},{value:"需要注意的是，由于 rightup / down 事件的默认行为并不是弹出系统菜单，因此以下写法无效：",paraId:26,tocIndex:6},{value:"// wrong\ncanvas.addEventListener('rightup', (e) => {\n    e.preventDefault();\n});\n",paraId:27,tocIndex:6},{value:"可以直接使用 ",paraId:28,tocIndex:7},{value:"KeyboardEvent",paraId:28,tocIndex:7},{value:"：",paraId:28,tocIndex:7},{value:"window.addEventListener('keydown', () => {}, false);\n",paraId:29,tocIndex:7},{value:"但目前我们还没有实现 A11y 相关的功能，例如使用 tab 在画布内图形间切换选中。",paraId:30,tocIndex:7},{value:"可以直接使用 ",paraId:31,tocIndex:8},{value:"ClipboardEvent",paraId:31,tocIndex:8},{value:"我们并没有内置 focus/blur 这样的",paraId:32,tocIndex:9},{value:"焦点事件",paraId:32,tocIndex:9},{value:"，因此以下代码无效：",paraId:32,tocIndex:9},{value:"circle.addEventListener('focus', () => {});\ncircle.addEventListener('blur', () => {});\n",paraId:33,tocIndex:9},{value:"可以通过 click/mouseenter/mouseleave 等事件实现焦点相关功能。",paraId:34,tocIndex:9},{value:"示例",paraId:35,tocIndex:9},{value:"由于需要尽可能兼容 PC 和移动端事件，我们并没有监听原生的 ",paraId:36,tocIndex:10},{value:"dblclick",paraId:36,tocIndex:10},{value:" 事件，而是通过监听 pointerdown 与 pointerup，将一定时间间隔（200ms）内的点击次数记录在 ",paraId:36,tocIndex:10},{value:"detail",paraId:37,tocIndex:10},{value:" 属性中，这样就可以区分单击与双击：",paraId:36,tocIndex:10},{value:"canvas.addEventListener('click', (e) => {\n    if (e.detail === 2) {\n        // 双击\n    } else if (e.detail === 1) {\n        // 单击\n    }\n});\n",paraId:38,tocIndex:10},{value:"在旧版中支持以下在事件名中表示委托的写法，格式为 ",paraId:39,tocIndex:11},{value:"[被委托图形 name]:[事件名]",paraId:39,tocIndex:11},{value:"，",paraId:39,tocIndex:11},{value:"示例",paraId:40,tocIndex:11},{value:"：",paraId:39,tocIndex:11},{value:"// 监听所有 name 为 node 的图形上冒泡上来的 click 事件\ngraph.on('node:click', () => {});\n\n// 等价于\ngraph.addEventListener('click', (e) => {\n    if (e.target.name === 'node') {\n    }\n});\n",paraId:41,tocIndex:11},{value:"前面提到过，事件绑定不在核心事件系统中完成，应当交给对应渲染环境插件。例如使用 DOM API 绑定/解绑的 ",paraId:42,tocIndex:13},{value:"g-plugin-dom-interaction",paraId:43,tocIndex:13},{value:"，其他环境例如小程序应当自行编写插件。",paraId:42,tocIndex:13},{value:"在这一类插件中，我们需要在 ",paraId:44,tocIndex:13},{value:"init",paraId:44,tocIndex:13},{value:" 中完成绑定，在 ",paraId:44,tocIndex:13},{value:"destroy",paraId:44,tocIndex:13},{value:" 中完成解绑。在实现绑定时，需要将该渲染环境下的多个（如有）原生事件映射到 G 的标准事件处理器上。",paraId:44,tocIndex:13},{value:"// g-plugin-dom-interaction\n\nconst onPointerDown = (ev: InteractivePointerEvent) => {\n    renderingService.hooks.pointerDown.call(ev);\n};\n\nrenderingService.hooks.init.tap(DOMInteractionPlugin.tag, () => {\n    // 事件绑定，使用 DOM API\n    $el.addEventListener(\n        'pointerdown', // 原生事件\n        onPointerDown, // G 标准事件处理器\n        true,\n    );\n\n    // 如果需要支持移动端\n    if (supportsTouchEvents) {\n        $el.addEventListener('touchstart', onPointerDown, true);\n    }\n    // 省略其他\n});\n\nrenderingService.hooks.destroy.tap(DOMInteractionPlugin.tag, () => {\n    // 事件解绑\n});\n",paraId:45,tocIndex:13},{value:"不同渲染环境使用不同的拾取插件，用于判定原生事件的 EventTarget：",paraId:46,tocIndex:14},{value:"g-plugin-canvas-picker",paraId:47,tocIndex:14},{value:" 主要使用数学运算",paraId:48,tocIndex:14},{value:"g-plugin-svg-picker",paraId:49,tocIndex:14},{value:" 使用现成 SVG API",paraId:48,tocIndex:14},{value:"g-plugin-device-renderer",paraId:50,tocIndex:14},{value:" 使用 GPU 颜色编码",paraId:48,tocIndex:14},{value:"在 ",paraId:51,tocIndex:15},{value:"g-plugin-a11y",paraId:52,tocIndex:15},{value:" 中，我们监听了键盘事件用于导航。",paraId:51,tocIndex:15}]},859:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(43115);const d=[{value:"当我们想实现除基础事件之外的某些“高级事件”时，例如常见的手势和拖拽，可以通过组合这些基础事件实现。得益于场景图对于 DOM API 的兼容，我们也可以直接使用已有生态，让这些库以为仍然在操作 DOM。",paraId:0},{value:"以 ",paraId:1,tocIndex:0},{value:"Hammer.js",paraId:1,tocIndex:0},{value:" 这样的手势库为例，由于完全兼容 DOM API，我们可以直接把 ",paraId:1,tocIndex:0},{value:"DisplayObject",paraId:1,tocIndex:0},{value:" 传入。另外需要通过 ",paraId:1,tocIndex:0},{value:"inputClass",paraId:1,tocIndex:0},{value:" 告知 Hammer.js 我们的输入事件为 PointerEvent，无需考虑例如 TouchEvent 等交互事件，",paraId:1,tocIndex:0},{value:"示例",paraId:2,tocIndex:0},{value:"：",paraId:1,tocIndex:0},{value:"import Hammer from 'hammerjs';\n\nconst hammer = new Hammer(circle, {\n    inputClass: Hammer.PointerEventInput, // 告知 Hammer.js 我们的输入事件为 PointerEvent\n});\nhammer.on('press', (e) => {\n    console.log(\"You're pressing me!\");\n    console.log(e.target); // circle\n});\n",paraId:3,tocIndex:0},{value:"在该",paraId:4,tocIndex:1},{value:"示例",paraId:5,tocIndex:1},{value:"中实现了 Pinch 手势，参考 ",paraId:4,tocIndex:1},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events/Pinch_zoom_gestures",paraId:4,tocIndex:1},{value:"核心思路是无需关心 Mouse/TouchEvent，通过监听 PointerEvents 根据事件对象上的 ",paraId:6,tocIndex:1},{value:"pointerId",paraId:7,tocIndex:1},{value:" 跟踪管理屏幕上的触控点。",paraId:6,tocIndex:1},{value:"Interact.js",paraId:8,tocIndex:2},{value:" 是一个包含了 Drag&Drop，Resize，手势等功能的交互库。",paraId:8,tocIndex:2},{value:"以拖拽为例：",paraId:9,tocIndex:2},{value:"import interact from 'interactjs';\n\ninteract(\n    circle, // 待拖拽对象\n    {\n        context: canvas.document, // 将画布 document 传入\n    },\n).draggable({\n    startAxis: 'xy', // 允许水平垂直两个方向的拖拽\n    lockAxis: 'start', // 锁定拖拽方向为初始设定\n    onmove: function (event) {\n        const { dx, dy } = event; // interact.js 将 dx/dy 挂载在事件对象上\n        circle.translateLocal(dx, dy); // 移动该对象\n    },\n});\n",paraId:10,tocIndex:2},{value:"示例",paraId:11},{value:"如果觉得 interact.js 太重，可以选择使用我们提供的简单拖放插件：",paraId:12,tocIndex:3},{value:"g-plugin-dragndrop",paraId:13,tocIndex:3},{value:"。",paraId:12,tocIndex:3},{value:"该插件完全基于 ",paraId:14,tocIndex:3},{value:"PointerEvents",paraId:15,tocIndex:3},{value:" 实现拖放功能。在该",paraId:14,tocIndex:3},{value:"示例",paraId:16,tocIndex:3},{value:"中，我们监听了足球的 drag 事件，用以移动它到正确的位置，同时监听了球门的 dragover 事件，当足球划过球门区域时改变透明度：",paraId:14,tocIndex:3},{value:"除了使用以上现成的库，我们还可以通过组合监听 PointerEvents 实现简单的拖拽效果，",paraId:17,tocIndex:4},{value:"g-plugin-dragndrop",paraId:18,tocIndex:4},{value:" 内部就是这么实现的，参考了 ",paraId:17,tocIndex:4},{value:"Drag'n'Drop with mouse events",paraId:17,tocIndex:4},{value:"：",paraId:17,tocIndex:4},{value:"ball.addEventListener('pointerdown', function (event) {\n    let shiftX = event.clientX - ball.getBoundingClientRect().left;\n    let shiftY = event.clientY - ball.getBoundingClientRect().top;\n\n    moveAt(event.canvasX, event.canvasY);\n\n    function moveAt(canvasX, canvasY) {\n        ball.style.x = canvasX - shiftX + 'px';\n        ball.style.y = canvasY - shiftY + 'px';\n    }\n\n    async function onMouseMove(event) {\n        moveAt(event.canvasX, event.canvasY);\n    }\n\n    canvas.document.addEventListener('pointermove', onMouseMove);\n\n    ball.addEventListener(\n        'pointerup',\n        function () {\n            canvas.document.removeEventListener('pointermove', onMouseMove);\n        },\n        { once: true },\n    );\n});\n",paraId:19,tocIndex:4},{value:"示例",paraId:20}]},34074:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(60612);const d=[{value:"事件系统能提供丰富的交互，在设计时我们遵循两个原则：",paraId:0},{value:"尽可能和 DOM API 保持一致，除了能降低学习成本，最重要的是能接入已有生态（例如手势库）。",paraId:1},{value:"仅提供标准事件。拖拽、手势等高级事件通过扩展方式定义。",paraId:1},{value:"熟悉 ",paraId:2},{value:"DOM 事件流",paraId:2},{value:" 的开发者对以下概念肯定不陌生：",paraId:2},{value:"事件对象上有一个指向 EventTarget 的引用，在 DOM 中自然是 DOM 元素，在 G 中是 ",paraId:3},{value:"EventTarget",paraId:4},{value:"事件流包含捕获和冒泡阶段，可以通过事件对象上的某些方法介入它们",paraId:3},{value:"可以为某个事件添加一个或多个监听器，它们按照注册顺序依次触发",paraId:3},{value:"下图展示了事件传播的三个阶段，在捕获阶段自顶向下依次触发监听器，到达目标节点后向上冒泡。在监听器中可以通过 ",paraId:5},{value:"eventPhase",paraId:6},{value:" 获取当前所处的阶段。下图来自 ",paraId:5},{value:"https://javascript.info/bubbling-and-capturing#capturing",paraId:5},{value:"目前我们支持以下",paraId:7},{value:"基础事件",paraId:8},{value:"，尽可能兼容了 DOM 事件流，因此在下面的很多 API 介绍中我们都附上了 DOM Event API 对应的参考链接。",paraId:7},{value:"例如我们想给这个圆形增加简单的鼠标移入/移出的交互效果，",paraId:9},{value:"示例",paraId:10},{value:"circle.addEventListener('mouseenter', () => {\n    circle.attr('fill', '#2FC25B');\n});\ncircle.addEventListener('mouseleave', () => {\n    circle.attr('fill', '#1890FF');\n});\n",paraId:11},{value:"目前我们支持对于以下两类事件的监听：交互事件和场景图事件。前者和 DOM Event API 中提供的大部分鼠标、触屏事件相同，后者则是基于场景图在节点添加、删除、属性变换时触发。",paraId:12,tocIndex:0},{value:"浏览器对于交互事件的支持历经了以下阶段，详见：",paraId:13,tocIndex:1},{value:"https://javascript.info/pointer-events#the-brief-history",paraId:13,tocIndex:1},{value:"最早支持的是 ",paraId:14,tocIndex:1},{value:"MouseEvent",paraId:14,tocIndex:1},{value:"随着移动设备普及，",paraId:14,tocIndex:1},{value:"TouchEvent",paraId:14,tocIndex:1},{value:" 出现，同时也触发 ",paraId:14,tocIndex:1},{value:"MouseEvent",paraId:14,tocIndex:1},{value:"再后来新的设备又出现了，比如 pen，这样一来各种事件结构各异，使用起来非常痛苦（例如 hammer.js 为了",paraId:14,tocIndex:1},{value:"兼容性的处理",paraId:14,tocIndex:1},{value:"）",paraId:14,tocIndex:1},{value:"新的标准被提出，",paraId:14,tocIndex:1},{value:"PointerEvent",paraId:14,tocIndex:1},{value:" 希望涵盖以上所有输入设备",paraId:14,tocIndex:1},{value:"下图来自：",paraId:15,tocIndex:1},{value:"https://w3c.github.io/pointerevents/",paraId:15,tocIndex:1},{value:"于是如今 Level 2 的 PointerEvent 已经被所有主流浏览器支持：",paraId:16,tocIndex:1},{value:"https://www.w3.org/TR/pointerevents2/",paraId:16,tocIndex:1},{value:"新的运行环境也都使用 PointerEvent 这样的统一定义，不再有 Touch / Mouse / PenEvent，例如：",paraId:17,tocIndex:1},{value:"Flutter：",paraId:18,tocIndex:1},{value:"https://api.flutter.dev/flutter/gestures/PointerEvent-class.html",paraId:18,tocIndex:1},{value:"Kraken：",paraId:18,tocIndex:1},{value:"https://zhuanlan.zhihu.com/p/371640453",paraId:18,tocIndex:1},{value:"因此我们推荐直接使用 PointerEvent。多指触控的手势也完全可以实现，例如：",paraId:19,tocIndex:1},{value:"Pinch 的实现：",paraId:20,tocIndex:1},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events/Pinch_zoom_gestures",paraId:20,tocIndex:1},{value:"目前支持监听如下交互事件：",paraId:21,tocIndex:1},{value:"Pointer 系列：",paraId:22,tocIndex:1},{value:"pointerdown",paraId:23,tocIndex:1},{value:"pointerup",paraId:23,tocIndex:1},{value:"pointerupoutside",paraId:23,tocIndex:1},{value:"pointertap",paraId:23,tocIndex:1},{value:"pointerover",paraId:23,tocIndex:1},{value:"pointerenter",paraId:23,tocIndex:1},{value:"pointerleave",paraId:23,tocIndex:1},{value:"pointerout",paraId:23,tocIndex:1},{value:"Mouse 系列：",paraId:24,tocIndex:1},{value:"mousedown 鼠标左键按下",paraId:25,tocIndex:1},{value:"rightdown 鼠标右键按下",paraId:25,tocIndex:1},{value:"mouseup 鼠标左键抬起",paraId:25,tocIndex:1},{value:"rightup 鼠标右键抬起",paraId:25,tocIndex:1},{value:"mouseupoutside 鼠标左键抬起时与按下时图形不同",paraId:25,tocIndex:1},{value:"rightupoutside 鼠标右键抬起与按下时图形不同",paraId:25,tocIndex:1},{value:"click 单击 & 双击 ",paraId:25,tocIndex:1},{value:"如何区分?",paraId:26,tocIndex:1},{value:"mousemove 鼠标持续在该图形上移动",paraId:25,tocIndex:1},{value:"mouseover 鼠标从该图形上移入，会冒泡",paraId:25,tocIndex:1},{value:"mouseout 鼠标从该图形上移出，会冒泡",paraId:25,tocIndex:1},{value:"mouseenter 鼠标从该图形上移入，不会冒泡",paraId:25,tocIndex:1},{value:"mouseleave 鼠标从该图形上移出，不会冒泡",paraId:25,tocIndex:1},{value:"wheel 滚轮",paraId:25,tocIndex:1},{value:"Touch 系列：",paraId:27,tocIndex:1},{value:"touchstart",paraId:28,tocIndex:1},{value:"touchend",paraId:28,tocIndex:1},{value:"touchendoutside",paraId:28,tocIndex:1},{value:"touchmove",paraId:28,tocIndex:1},{value:"touchcancel",paraId:28,tocIndex:1},{value:"除了交互事件，我们还可以监听一些场景图相关的事件，例如在画布上监听每一个节点的首次加载（g-svg 会在此时创建当前图形相关的 DOM），",paraId:29,tocIndex:2},{value:"示例",paraId:30,tocIndex:2},{value:"import { ElementEvent } from '@antv/g';\n\ncanvas.addEventListener(ElementEvent.MOUNTED, (e) => {\n    e.target;\n});\n",paraId:31,tocIndex:2},{value:"目前我们支持如下场景图相关事件：",paraId:32,tocIndex:2},{value:"CHILD_INSERTED 作为父节点有子节点添加时触发",paraId:33,tocIndex:2},{value:"INSERTED 作为子节点被添加时触发",paraId:33,tocIndex:2},{value:"CHILD_REMOVED 作为父节点有子节点移除时触发",paraId:33,tocIndex:2},{value:"REMOVED 作为子节点被移除时触发",paraId:33,tocIndex:2},{value:"MOUNTED 首次进入画布时触发",paraId:33,tocIndex:2},{value:"UNMOUNTED 从画布中移除时触发",paraId:33,tocIndex:2},{value:"ATTR_MODIFIED 修改属性时触发",paraId:33,tocIndex:2},{value:"DESTROY 销毁时触发",paraId:33,tocIndex:2},{value:"在下面的例子中，画布监听 INSERTED REMOVED MOUNTED 和 UNMOUNTED 事件。在加入、移除场景图时，以下事件会依次触发：",paraId:34,tocIndex:2},{value:"canvas.addEventListener(ElementEvent.INSERTED, (e) => {\n    console.log(ElementEvent.INSERTED, e.target);\n});\n// 省略其他事件监听器\n\nparent.appendChild(child); // 构建父子关系\ncanvas.appendChild(parent); // 加入场景图\ncanvas.removeChild(parent, false); // 从场景图中移除，但不销毁\n\n// MOUNTED parent 父节点载入\n// MOUNTED child 子节点载入\n// INSERTED parent 父节点加入场景图\n// REMOVED parent 父节点被移除场景图\n// UNMOUNTED child 子节点卸载\n// UNMOUNTED parent 父节点卸载\n",paraId:35,tocIndex:2},{value:"为图形添加事件监听器，可以完全参考 DOM Event API：",paraId:36,tocIndex:4},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener",paraId:36,tocIndex:4},{value:"方法签名：",paraId:37,tocIndex:4},{value:"target.addEventListener(type, listener, options);\ntarget.addEventListener(type, listener, useCapture);\n",paraId:38,tocIndex:4},{value:"其中参数为：",paraId:39,tocIndex:4},{value:"type 事件名称，",paraId:40,tocIndex:4},{value:"内置标准事件",paraId:41,tocIndex:4},{value:" 或",paraId:40,tocIndex:4},{value:"自定义事件名",paraId:42,tocIndex:4},{value:"listener 事件监听器，支持以下两种写法：\n",paraId:40,tocIndex:4},{value:"处理函数 ",paraId:43,tocIndex:4},{value:"Function",paraId:43,tocIndex:4},{value:"EventListener",paraId:43,tocIndex:4},{value:" 对象，形如 ",paraId:43,tocIndex:4},{value:"{ handleEvent: Function }",paraId:43,tocIndex:4},{value:"options ",paraId:40,tocIndex:4},{value:"可选",paraId:40,tocIndex:4},{value:"capture ",paraId:44,tocIndex:4},{value:"boolean",paraId:44,tocIndex:4},{value:"，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。",paraId:44,tocIndex:4},{value:"once ",paraId:44,tocIndex:4},{value:"boolean",paraId:44,tocIndex:4},{value:"，表示 listener 在添加之后最多只调用一次。如果是 ",paraId:44,tocIndex:4},{value:"true",paraId:44,tocIndex:4},{value:"， listener 会在其被调用之后自动移除。",paraId:44,tocIndex:4},{value:"useCapture ",paraId:40,tocIndex:4},{value:"可选",paraId:40,tocIndex:4},{value:" ",paraId:40,tocIndex:4},{value:"boolean",paraId:40,tocIndex:4},{value:" 默认为 ",paraId:40,tocIndex:4},{value:"false",paraId:40,tocIndex:4},{value:"。如果是 ",paraId:40,tocIndex:4},{value:"true",paraId:40,tocIndex:4},{value:"，向上冒泡的事件不会触发 listener。",paraId:40,tocIndex:4},{value:"// 二者等价\nbutton.addEventListener('click', () => {});\nbutton.addEventListener('click', {\n  handleEvent(e): {}\n});\n",paraId:45,tocIndex:4},{value:"注册仅在捕获阶段执行的监听器：",paraId:46,tocIndex:4},{value:"circle.addEventListener('click', () => {}, { capture: true });\ncircle.addEventListener('click', () => {}, true);\n",paraId:47,tocIndex:4},{value:"注册仅执行一次的监听器：",paraId:48,tocIndex:4},{value:"circle.addEventListener('click', () => {}, { once: true });\n",paraId:49,tocIndex:4},{value:"为了兼容旧版 G API，也支持使用 ",paraId:50,tocIndex:4},{value:"on",paraId:50,tocIndex:4},{value:"，因此以下写法等价：",paraId:50,tocIndex:4},{value:"circle.addEventListener('mouseenter', () => {});\ncircle.on('mouseenter', () => {});\n",paraId:51,tocIndex:4},{value:"关于监听器内 this 的指向问题可以参考",paraId:52,tocIndex:4},{value:"该小节",paraId:53,tocIndex:4},{value:"。",paraId:52,tocIndex:4},{value:"移除事件监听器",paraId:54,tocIndex:5},{value:"circle.removeEventListener('click', handler);\n",paraId:55,tocIndex:5},{value:"为了兼容旧版 G API，也支持使用 ",paraId:56,tocIndex:5},{value:"off",paraId:56,tocIndex:5},{value:"，因此以下写法等价：",paraId:56,tocIndex:5},{value:"circle.removeEventListener('mouseenter', () => {});\ncircle.off('mouseenter', () => {});\n",paraId:57,tocIndex:5},{value:"移除所有事件监听器。",paraId:58,tocIndex:6},{value:"为了兼容旧版 G API，也支持使用 ",paraId:59,tocIndex:6},{value:"off",paraId:59,tocIndex:6},{value:"，因此以下写法等价：",paraId:59,tocIndex:6},{value:"circle.removeAllEventListeners();\ncircle.off();\n",paraId:60,tocIndex:6},{value:"手动触发事件，和交互触发的事件一样会经历完整的事件传播流程。",paraId:61,tocIndex:7},{value:"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent",paraId:62,tocIndex:7},{value:"⚠️ 在一个图形上手动触发事件前，必须保证该元素已经添加到画布上",paraId:63,tocIndex:7},{value:"除了内置标准事件，有时我们也需要触发一些自定义事件，参考 ",paraId:64,tocIndex:8},{value:"Web CustomEvent",paraId:64,tocIndex:8},{value:"，我们也支持如下写法，",paraId:64,tocIndex:8},{value:"示例",paraId:65,tocIndex:8},{value:"：",paraId:64,tocIndex:8},{value:"import { CustomEvent } from '@antv/g';\n\nconst event = new CustomEvent('build', { detail: { prop1: 'xx' } });\ncircle.addEventListener('build', (e) => {\n    e.target; // circle\n    e.detail; // { prop1: 'xx' }\n});\n\ncircle.dispatchEvent(event);\n",paraId:66,tocIndex:8},{value:"其中 CustomEvent 构造函数参数如下：",paraId:67,tocIndex:8},{value:"eventName 事件名 ",paraId:68,tocIndex:8},{value:"string",paraId:68,tocIndex:8},{value:" ",paraId:68,tocIndex:8},{value:"必填",paraId:68,tocIndex:8},{value:"eventObject 事件对象 ",paraId:68,tocIndex:8},{value:"选填",paraId:68,tocIndex:8},{value:" 包含以下属性：\n",paraId:68,tocIndex:8},{value:"detail 自定义数据 ",paraId:69,tocIndex:8},{value:"any",paraId:69,tocIndex:8},{value:"为了兼容旧版 G API，也支持使用 ",paraId:70,tocIndex:8},{value:"emit",paraId:70,tocIndex:8},{value:"：",paraId:70,tocIndex:8},{value:"circle.on('build', (e) => {\n    e.target; // circle\n    e.detail; // { prop1: 'xx' }\n});\ncircle.emit('build', { prop1: 'xx' });\n",paraId:71,tocIndex:8}]},5121:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(72429);const d=[{value:"创建画布，使用渲染器的方式和之前渲染相关的教程并无差别，只是在创建渲染器时，需要确认在支持 WebGPU 的浏览器环境下运行。另外由于不涉及渲染，画布大小我们选择长宽为 1 即可。",paraId:0,tocIndex:0},{value:"import { Canvas, CanvasEvent } from '@antv/g';\nimport { DeviceRenderer, Renderer } from '@antv/g-webgpu';\nimport { Plugin, Kernel } from '@antv/g-plugin-gpgpu';\n\nconst { BufferUsage } = DeviceRenderer;\n\nconst renderer = new Renderer();\n// 注册 GPGPU 插件\nrenderer.registerPlugin(new Plugin());\n\n// 创建画布\nconst $wrapper = document.getElementById('container');\nconst canvas = new Canvas({\n    container: $wrapper,\n    width: 1,\n    height: 1,\n    renderer,\n});\n",paraId:1,tocIndex:0},{value:"在创建一个计算任务时，我们需要获取 GPU 设备（Device），用它创建 Buffer 等底层对象。在画布的 ",paraId:2,tocIndex:1},{value:"READY",paraId:3,tocIndex:1},{value:" 事件处理器中或者等待 ",paraId:2,tocIndex:1},{value:"canvas.ready",paraId:2,tocIndex:1},{value:" Promise 完成后，我们都可以通过渲染器获取 Device，",paraId:2,tocIndex:1},{value:"完整 Device API",paraId:4,tocIndex:1},{value:"：",paraId:2,tocIndex:1},{value:"import { CanvasEvent } from '@antv/g';\n\n// 等待画布准备就绪\ncanvas.addEventListener(CanvasEvent.READY, () => {\n    // 通过渲染器获取 Device\n    const plugin = renderer.getPlugin('device-renderer');\n    const device = plugin.getDevice();\n\n    // 使用 Device 创建 GPU 相关对象，见下节\n});\n\n// 或者\nawait canvas.ready;\nconst plugin = renderer.getPlugin('device-renderer');\nconst device = plugin.getDevice();\n",paraId:5,tocIndex:1},{value:"因此 g-plugin-gpgpu 插件提供了 Kernel 用于描述计算任务，除了传入上一节获取的 device，还需要通过 computeShader 使用字符串描述：",paraId:6,tocIndex:2},{value:"import { Kernel } from '@antv/g-plugin-gpgpu';\n\nconst kernel = new Kernel(device, {\n    computeShader: `...`,\n});\n",paraId:7,tocIndex:2},{value:"定义好了 Kernel，我们需要向它传递输入，结束后获取输出结果。分配内存的工作在 Host 侧执行，通过 Device 创建 Buffer，其中 ",paraId:8,tocIndex:3},{value:"usage",paraId:8,tocIndex:3},{value:" 需要与 Compute Shader 中定义的内存用途对应，同时进行内存初始数据的写入。",paraId:8,tocIndex:3},{value:"const firstMatrixBuffer = device.createBuffer({\n    usage: BufferUsage.STORAGE,\n    viewOrSize: firstMatrix, // new Float32Array([2 /* rows */, 4 /* columns */, 1, 2, 3, 4, 5, 6, 7, 8])\n});\n",paraId:9,tocIndex:3},{value:"创建完 Buffer 之后，需要绑定到 Kernel 的指定位置（与 Compute Shader 中的 binding 对应）：",paraId:10,tocIndex:3},{value:"kernel.setBinding(0, firstMatrixBuffer);\n",paraId:11,tocIndex:3},{value:"下面列出 usage 与 Compute Shader 中 Buffer 对应的常用配置：",paraId:12,tocIndex:3},{value:"var<storage, read>",paraId:13,tocIndex:3},{value:" 对应 ",paraId:13,tocIndex:3},{value:"BufferUsage.STORAGE",paraId:13,tocIndex:3},{value:"var<storage, read_write>",paraId:13,tocIndex:3},{value:" 对应 ",paraId:13,tocIndex:3},{value:"BufferUsage.STORAGE | BufferUsage.COPY_SRC",paraId:13,tocIndex:3},{value:"var<uniform>",paraId:13,tocIndex:3},{value:" 对应 ",paraId:13,tocIndex:3},{value:"BufferUsage.UNIFORM | BufferUsage.COPY_DST | BufferUsage.COPY_SRC",paraId:13,tocIndex:3},{value:"使用 ",paraId:14,tocIndex:4},{value:"dispatch",paraId:14,tocIndex:4},{value:" 可以分配线程网格大小，执行计算管线。在矩阵乘法的例子中，如果线程组的大小为 ",paraId:14,tocIndex:4},{value:"1 * 1",paraId:14,tocIndex:4},{value:"，网格大小就是 ",paraId:14,tocIndex:4},{value:"M * N",paraId:14,tocIndex:4},{value:"：",paraId:14,tocIndex:4},{value:"const x = Math.ceil(firstMatrix[0] / WORKGROUP_SIZE_X);\nconst y = Math.ceil(secondMatrix[1] / WORKGROUP_SIZE_Y);\nkernel.dispatch(x, y);\n",paraId:15,tocIndex:4},{value:"在计算完成后，我们需要读取结果矩阵中的数据，这是一次 GPU 到 CPU 的异步读取操作：",paraId:16,tocIndex:4},{value:"const readback = device.createReadback();\nconst result = await readback.readBuffer(resultBuffer); // Float32Array([...])\n",paraId:17,tocIndex:4}]},45850:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(40584);const d=[{value:"使用图形渲染 API 实现的经典 GPGPU 的原理可以简单总结为：用纹理映射实现的科学计算 (compulation by texturing)。考虑到兼容性，我们在 WebGL 中也使用了这个方式。",paraId:0},{value:"下图来自：「GPGPU 编程技术 - 从 GLSL、CUDA 到 OpenCL」 ",paraId:1},{value:"通常来说图形渲染 API 最终的输出目标就是屏幕，显示渲染结果。但是在 GPGPU 场景中我们只是希望在 CPU 侧读取最终的计算结果。因此会使用到渲染 API 提供的离屏渲染功能 --- 渲染到纹理，其中的关键技术就是使用帧缓存对象（Framebuffer Object - FBO）作为渲染对象。",paraId:2,tocIndex:0},{value:"但是这种方式存在一个明显的限制，对于所有线程，纹理缓存要么是只读的，要么就是只写的，没法实现一个线程在读纹理，另一个在写纹理。本质上是由 GPU 的硬件设计决定的，如果想要实现多个线程同时对同一个纹理进行读/写操作，需要设计复杂的同步机制避免读写冲突，势必会影响到线程并行执行的效率。",paraId:3,tocIndex:0},{value:"因此在经典 GPGPU 的实现中，通常我们会准备两个纹理，一个用来保存输入数据，一个用来保存输出数据。这也是为何我们只允许使用一个 ",paraId:4,tocIndex:0},{value:"@out",paraId:4,tocIndex:0},{value:" 声明来输出变量。",paraId:4,tocIndex:0},{value:"我们的数据存储在显存中，使用 RGBA 的纹理格式，每一个图元包含 4 个通道，因此在 GWebGPU 中使用 ",paraId:5,tocIndex:0},{value:"vec4[]",paraId:5,tocIndex:0},{value:" 是最省内存的数据格式。如果使用 ",paraId:5,tocIndex:0},{value:"float[]",paraId:5,tocIndex:0},{value:"，每个图元中 GBA 三个通道就被浪费了。当然数据类型的决定权在开发者，可以根据实际程序中访问方便程度决定。",paraId:5,tocIndex:0},{value:"我们的计算逻辑写在片元着色器（Fragment Shader）中，在渲染管线的光栅化阶段，每个像素被分配给一个线程进行着色，达到并行效果。",paraId:6,tocIndex:1},{value:"如果映射到 CPU 中的计算概念，纹理可以看作是数组，而片元着色器执行的程序就是循环语句。",paraId:7,tocIndex:1},{value:"一个 3D 模型由很多个三角面组成，理论上每个三角面都可以继续无限细分，但给每个三角面着色是很消耗性能的。更快的做法是贴图，把一张二维位图（纹理）贴在模型的表面，这个过程就是纹理映射。我们不需要为模型每一个顶点定义纹理坐标，只需要定义四个角的坐标，剩余的交给渲染管线做插值即可。",paraId:8,tocIndex:2},{value:"很多算法需要连续运行多次，例如 G6 中使用的布局算法需要迭代多次达到稳定状态。上一次迭代中输出的计算结果，需要作为下一次迭代的输入。在实际实现中，我们会分配两张纹理缓存，每次迭代后对输入和输出纹理进行 swap。",paraId:9,tocIndex:3},{value:"「GPGPU 编程技术 - 从 GLSL、CUDA 到 OpenCL」",paraId:10,tocIndex:4},{value:"🔗",paraId:10,tocIndex:4},{value:"http://www.vizitsolutions.com/portfolio/webgl/gpgpu/",paraId:10,tocIndex:4}]},16332:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(41256);const d=[{value:"由于硬件结构不同，GPU 与 CPU 擅长执行不同类型的计算任务。特别的，在单指令流多数据流（SIMD）场景下，GPU 的运算速度远超 CPU。",paraId:0,tocIndex:0},{value:"下图来自：",paraId:1,tocIndex:0},{value:"https://www.techpowerup.com/199624/nvidia-to-launch-geforce-337-50-beta-later-today",paraId:1,tocIndex:0},{value:"，清晰的展示了 GPU 在每秒浮点数运算次数与数据吞吐量两项指标下的巨大优势。",paraId:1,tocIndex:0},{value:"GPU 强大的计算能力早已不局限于渲染，",paraId:2,tocIndex:0},{value:"G",paraId:2,tocIndex:0},{value:"eneral-",paraId:2,tocIndex:0},{value:"p",paraId:2,tocIndex:0},{value:"urpose computing on ",paraId:2,tocIndex:0},{value:"g",paraId:2,tocIndex:0},{value:"raphics ",paraId:2,tocIndex:0},{value:"p",paraId:2,tocIndex:0},{value:"rocessing ",paraId:2,tocIndex:0},{value:"u",paraId:2,tocIndex:0},{value:"nits 即 GPU 通用计算概念的提出将这种能力推向了更广阔的计算场景。",paraId:2,tocIndex:0},{value:"早期的经典系列书籍 GPU Gems ",paraId:3,tocIndex:0},{value:"Gem2 🔗",paraId:3,tocIndex:0},{value:" ",paraId:3,tocIndex:0},{value:"Gem3 🔗",paraId:3,tocIndex:0},{value:" 中就收录了大量通用计算领域的实践，包括了视频解码、实时加解密、图片压缩、随机数生成、仿真等等。",paraId:3,tocIndex:0},{value:"现代的 GPU 更是针对特定类型的计算任务设计硬件。例如 NVIDIA 的 Turing 架构中就包含了专门进行张量计算的 Tensor Core 和光线追踪计算的 RT Core。",paraId:4,tocIndex:0},{value:"为了降低开发者面向 GPU 编程的门槛，Nvidia 提出了 CUDA（",paraId:5,tocIndex:0},{value:"C",paraId:5,tocIndex:0},{value:"ompute ",paraId:5,tocIndex:0},{value:"U",paraId:5,tocIndex:0},{value:"nified ",paraId:5,tocIndex:0},{value:"D",paraId:5,tocIndex:0},{value:"evice ",paraId:5,tocIndex:0},{value:"A",paraId:5,tocIndex:0},{value:"rchitecture，统一计算架构），开发者可以使用 C、Java、Python 等语言编写自己的计算任务代码。",paraId:5,tocIndex:0},{value:"而作为前端开发者，我们面对的适合并行的数据密集型计算任务也越来越多，是否能在 Web 端使用 GPGPU 技术呢？",paraId:6,tocIndex:0},{value:"事实上，在 Web 端已经有了很多优秀的 GPGPU 实践，例如：",paraId:7,tocIndex:1},{value:"tensorflow.js",paraId:8,tocIndex:1},{value:"。用户通过 API 组合调用完成计算任务。",paraId:8,tocIndex:1},{value:"GPU.js",paraId:8,tocIndex:1},{value:"。用户使用 JS 编写简单的计算任务。",paraId:8,tocIndex:1},{value:"Stardust.js",paraId:8,tocIndex:1},{value:"。用户使用 Mark 语言定义计算任务，实现 Sanddance 效果。",paraId:8,tocIndex:1},{value:"从实现角度看，以上方案都使用 WebGL 图形 API 来模拟并不支持的 Compute Shader，具体来说都是通过常规渲染管线中可编程的 Vertex/Fragment Shader 完成，如果对我们的实现感兴趣，可以阅读",paraId:9,tocIndex:2},{value:"经典 GPGPU 的实现原理",paraId:10,tocIndex:2},{value:"。下图来自 ",paraId:9,tocIndex:2},{value:"http://www.vizitsolutions.com/portfolio/webgl/gpgpu/",paraId:9,tocIndex:2},{value:"，简单展示了基本的实现过程：",paraId:9,tocIndex:2},{value:"这当然是出于兼容性考虑，Compute Shader 中本应具有的线程组、共享内存、同步等机制都无法通过 Vertex/Fragment Shader 模拟。另外计算管线相比常规渲染管线也要精简很多。下图中左右两侧分别是 Vulkan 的可编程渲染与计算管线，来自 ",paraId:11,tocIndex:2},{value:"https://vulkan.lunarg.com/doc/view/1.0.26.0/windows/vkspec.chunked/ch09.html",paraId:11,tocIndex:2},{value:"：",paraId:11,tocIndex:2},{value:"当然 WebGL 2 也考虑过原生支持 Compute Shader，毕竟这也是 OpenGL ES 3.1 中的核心特性。甚至 ",paraId:12,tocIndex:2},{value:"WebGL 2.0 Compute 草案",paraId:12,tocIndex:2},{value:" 和 ",paraId:12,tocIndex:2},{value:"DEMO",paraId:12,tocIndex:2},{value:" 也早就提出了。但由于苹果的不支持，目前 WebGL 2.0 Compute 也仅能在 Windows Chrome/Edge 下运行。同理 WebGL 2.0 的 Transform Feedback 作为另一个选择也存在兼容性问题。",paraId:12,tocIndex:2},{value:"下图来自 ",paraId:13,tocIndex:2},{value:"https://slideplayer.com/slide/16710114/",paraId:13,tocIndex:2},{value:"，展示了 WebGL 与 OpenGL 的对应关系：",paraId:13,tocIndex:2},{value:"而作为 WebGL 的继任者 WebGPU，目前得到了各大浏览器厂商的",paraId:14,tocIndex:3},{value:"支持",paraId:14,tocIndex:3},{value:"，可以在以下浏览器中体验（需要开启实验特性 webgpu flag）：",paraId:14,tocIndex:3},{value:"Chrome Canary",paraId:15,tocIndex:3},{value:"Edge Canary",paraId:15,tocIndex:3},{value:"Safari Technology Preview",paraId:15,tocIndex:3},{value:"目前 Chrome 94 版本已经通过 Origin trial 支持：",paraId:16,tocIndex:3},{value:"https://web.dev/gpu/",paraId:16,tocIndex:3},{value:"下图来自：",paraId:17,tocIndex:3},{value:"https://www.chromestatus.com/feature/6213121689518080",paraId:17,tocIndex:3},{value:"，作为现代化的图形 API，WebGPU 的一大特性就是支持 Compute Shader。这理所当然成为了未来我们的第一选择：",paraId:17,tocIndex:3},{value:"除了计算，浏览器实现 WebGPU API 时封装了 Vulkan、DX12、Metal 这些现代化图形 API 而非 OpenGL，进一步降低了驱动开销，也更好地支持多线程。对于使用者而言，过去 WebGL API 中存在的种种问题也将得到解决。目前 WebGPU 的 Shader 语言已经确定为 ",paraId:18,tocIndex:3},{value:"WGSL",paraId:18,tocIndex:3},{value:"。",paraId:18,tocIndex:3},{value:"虽然 WebGPU 还处于开发中阶段，但也有了很多优秀的实践，例如：",paraId:19,tocIndex:3},{value:"tensorflow.js 正在尝试 ",paraId:20,tocIndex:3},{value:"基于 WebGPU 的 backend 实现",paraId:20,tocIndex:3},{value:"。",paraId:20,tocIndex:3},{value:"Babylon.js 正在尝试实现 ",paraId:20,tocIndex:3},{value:"基于 WebGPU 渲染引擎",paraId:20,tocIndex:3},{value:"。",paraId:20,tocIndex:3},{value:"当我们从通用计算领域聚焦到可视化场景时，会发现存在着很多适合 GPU 执行的可并行计算任务，例如：",paraId:21,tocIndex:4},{value:"布局计算。G6 中的 ",paraId:22,tocIndex:4},{value:"Fruchterman 布局算法",paraId:22,tocIndex:4},{value:"是一个很典型的例子，在每次迭代中每个节点的位置都需要根据其他节点位置进行计算，并且需要经历很多次迭代才能达到稳定状态，因此计算量很大。",paraId:22,tocIndex:4},{value:"Instanced-based 可视化。Stardust.js 正是针对这个场景，例如 sanddance 效果。",paraId:22,tocIndex:4},{value:"data transformation。在海量数据要求高交互的图表场景下，很多可并行的算法例如 reduce & scan 都可以在 GPU 中执行。P4 & P5（IEEE TRANSACTIONS ON VISUALIZATION AND COMPUTER GRAPHICS, VOL. 26, NO. 3, MARCH 2020） 在这方面有很多实践。",paraId:22,tocIndex:4}]},26548:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(75080);const d=[{value:"参考 CUDA 的编程模型，了解它有助于我们写出高性能的并行代码： ",paraId:0},{value:"https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#programming-model",paraId:0},{value:"在 CUDA 中 Kernel（核函数）在 GPU 侧（Device）并行，CPU 侧（Host）负责写入、读取数据，指定线程组大小，调用 Kernel 等串行任务：",paraId:1,tocIndex:0},{value:"两者是需要配合执行的，例如在 Host 中分配内存，再拷贝到 Device 中：",paraId:2,tocIndex:0},{value:"//allocate memory\ncudaMalloc((void**) &d_in_V, V.size() *sizeof(int));\n\n//copy to device memory\ncudaMemcpy(d_in_V, V.data(), V.size() *sizeof(int), cudaMemcpyHostToDevice);\n",paraId:3,tocIndex:0},{value:"以下面的 CUDA 程序（矩阵加法）为例，核函数在 GPU 每一个线程间并行，每个线程根据自己的编号领取部分数据进行运算，将结果写回全局数组中。在加法中每一个线程负责两个矩阵间同位置元素的计算：",paraId:4,tocIndex:0},{value:"// Kernel 定义\n__global__ void MatAdd(\n  float A[N][N], // 输入数组1\n  float B[N][N], // 输入数组2\n  float C[N][N]) // 结果数组\n{\n    int i = blockIdx.x * blockDim.x + threadIdx.x; // 这些都是线程组相关的内置变量，仅 Kernel 函数中可使用\n    int j = blockIdx.y * blockDim.y + threadIdx.y;\n    if (i < N && j < N)\n        C[i][j] = A[i][j] + B[i][j]; // 执行加法并写回\n}\n\nint main()\n{\n    // ... 省略创建 buffer 过程\n    // Kernel invocation\n    dim3 threadsPerBlock(16, 16); // 指定线程组大小\n    dim3 numBlocks(N / threadsPerBlock.x, N / threadsPerBlock.y);\n    MatAdd<<<numBlocks, threadsPerBlock>>>(A, B, C); // 调用 Kernel 函数\n}\n",paraId:5,tocIndex:0},{value:"“single source” 无疑是 CUDA 的一大亮点，即 Host、Device 代码都用 C++ 编写，对于使用者无疑大大减少了学习成本。而使用渲染 API 的 Compute Shader 肯定无法做到这一点，Device 代码必须使用 Shader 语言写，类似 RPC 调用使得同步变得困难，同时 Shader 语言限制颇多（无递归、参数类型受限）。",paraId:6,tocIndex:1},{value:"下图来自该 ",paraId:7,tocIndex:1},{value:"PPT",paraId:7,tocIndex:1},{value:"，对比了 CUDA 和 Compute Shader 的差异：",paraId:7,tocIndex:1},{value:"CUDA C++ 让开发者可以用 C++ 编写核函数，使用 nvcc 编译成 GPU 可执行的代码。如果我们想在 Web 端做同样的事情，JS 语言并不好扩展，换言之 Device 和 Host 代码很难写在一起。",paraId:8,tocIndex:1},{value:"一个简单的做法是将 Device 代码写在字符串中，利用 WebGPU API 提供的计算管线。下一个问题是字符串中的 Device 代码应该使用哪种语言呢？",paraId:9,tocIndex:1},{value:"WGSL。使用 WebGPU 的 Shader 语言最直接，但对于前端开发者有一定学习成本（但其实还好，只需要学 Compute Shader），另外在字符串里写代码会丧失语法高亮。",paraId:10,tocIndex:1},{value:"TS。让前端开发者写 TS 代码，通过编译器生成 WGSL。之前 GWebGPU 这个项目就是这种思路，配合编辑器插件能提供语法高亮。",paraId:10,tocIndex:1},{value:"尽管 CUDA 和 Compute Shader 用法差异大，但对于同一个算法来说，将 CUDA 实现移植到 Compute Shader 中并不难，只要 Compute Shader 的特性足够丰富。",paraId:11,tocIndex:1},{value:"GPU 线程和通常意义上我们理解的线程还不太一样，这些线程执行同样的指令，只是使用不同的数据（SIMD）。在核函数中每个线程通过 ID 找到自己负责的数据。",paraId:12,tocIndex:2},{value:"下图来自 ",paraId:13,tocIndex:3},{value:"http://on-demand.gputechconf.com/gtc/2010/presentations/S12312-DirectCompute-Pre-Conference-Tutorial.pdf",paraId:13,tocIndex:3},{value:"，仅展示网格与线程组的层次关系，并不局限于 DirectCompute。",paraId:13,tocIndex:3},{value:"通过 ",paraId:14,tocIndex:3},{value:"dispatch(x, y, z)",paraId:14,tocIndex:3},{value:" 分配一个 3 维的线程网格（Grid）",paraId:14,tocIndex:3},{value:"网格中包含了许多线程组（Work Group、Thread Group、Thread Block、本地工作组不同叫法），每一个线程组中又包含了许多线程，线程组也是 3 维的，一般在 Shader 中通过 ",paraId:14,tocIndex:3},{value:"numthreads(x, y, z)",paraId:14,tocIndex:3},{value:" 指定",paraId:14,tocIndex:3},{value:"我们的 Shader 程序最终会运行在每一个线程上。对于每一个线程，可以获取自己在线程组中的 3 维坐标，也可以获取线程组在整个线程网格中的 3 维坐标，以此映射到不同的数据上",paraId:14,tocIndex:3},{value:"在 CUDA 中使用如下方式分配 Blocks 数量和每个 Block 中的线程数量：",paraId:15,tocIndex:3},{value:"dim3 threadsPerBlock(16, 16); // 指定线程组大小\ndim3 numBlocks(N / threadsPerBlock.x, N / threadsPerBlock.y);\nMatAdd<<<numBlocks, threadsPerBlock>>>(A, B, C); // 调用 Kernel 函数\n",paraId:16,tocIndex:3},{value:"而在 Compute Shader 中使用如下语法： ",paraId:17,tocIndex:3},{value:"https://www.w3.org/TR/WGSL/#entry-point-attributes",paraId:17,tocIndex:3},{value:"@compute @workgroup_size(8,4,1)\n",paraId:18,tocIndex:3},{value:"网格、线程组与线程的对应关系也体现在 GPU 的硬件实现上。",paraId:19,tocIndex:4},{value:"GPU 上有很多个 SM(Streaming Multiprocessor)，每一个 SM 包含了很多核心，下图为 CUDA 实现的对应关系：",paraId:20,tocIndex:4},{value:"下图来自：",paraId:21,tocIndex:4},{value:"http://www.adms-conf.org/2019-presentations/ADMS19_nvidia_keynote.pdf",paraId:21,tocIndex:4},{value:"现在我们了解了网格、线程组和线程的层次关系，在每一个线程执行 Shader 程序时，需要了解自己在所在线程组中的坐标、线程组在整个线程网格中的坐标。下图来自 ",paraId:22,tocIndex:5},{value:"https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-attributes-numthreads?redirectedfrom=MSDN",paraId:22,tocIndex:5},{value:"，展示了这些坐标的计算逻辑：",paraId:22,tocIndex:5},{value:"变量名",paraId:23,tocIndex:5},{value:"类型",paraId:23,tocIndex:5},{value:"说明",paraId:23,tocIndex:5},{value:"numWorkGroups",paraId:23,tocIndex:5},{value:"ivec3",paraId:23,tocIndex:5},{value:"dispatch 的线程工作组数目",paraId:23,tocIndex:5},{value:"workGroupSize",paraId:23,tocIndex:5},{value:"ivec3",paraId:23,tocIndex:5},{value:"Shader 内通过 ",paraId:23,tocIndex:5},{value:"numthreads",paraId:23,tocIndex:5},{value:" 声明的每一个线程工作组包含的线程数",paraId:23,tocIndex:5},{value:"workGroupID",paraId:23,tocIndex:5},{value:"ivec3",paraId:23,tocIndex:5},{value:"当前线程工作组的索引。取值范围为 ",paraId:23,tocIndex:5},{value:"(0, 0, 0)",paraId:23,tocIndex:5},{value:" 到 ",paraId:23,tocIndex:5},{value:"(numWorkGroups.x - 1, numWorkGroups.y - 1, numWorkGroups.z - 1)",paraId:23,tocIndex:5},{value:" 之间",paraId:23,tocIndex:5},{value:"localInvocationID",paraId:23,tocIndex:5},{value:"ivec3",paraId:23,tocIndex:5},{value:"当前线程在自己线程组中的索引。取值范围为 ",paraId:23,tocIndex:5},{value:"(0, 0, 0) 到 (workGroupSize.x - 1, * workGroupSize.y - 1, workGroupSize.z - 1)",paraId:23,tocIndex:5},{value:" 之间",paraId:23,tocIndex:5},{value:"globalInvocationID",paraId:23,tocIndex:5},{value:"ivec3",paraId:23,tocIndex:5},{value:"当前线程在全局线程组中的索引。计算方法为 ",paraId:23,tocIndex:5},{value:"workGroupID * workGroupSize + localInvocationID",paraId:23,tocIndex:5},{value:"localInvocationIndex",paraId:23,tocIndex:5},{value:"int",paraId:23,tocIndex:5},{value:"当前线程在自己线程组中的一维索引，计算方法为 ",paraId:23,tocIndex:5},{value:"localInvocationID.z * workGroupSize.x * workGroupSize.y + localInvocationID.y * workGroupSize.x + localInvocationID.x",paraId:23,tocIndex:5},{value:"在某些计算任务中，每个线程不仅需要处理自己负责的那一部分数据，可能还需要读取、修改其他线程处理过的数据，此时就需要共享内存与同步了。",paraId:24,tocIndex:6},{value:"来自：",paraId:25,tocIndex:6},{value:"https://zhuanlan.zhihu.com/p/128996252",paraId:25,tocIndex:6},{value:"一个变量被声明为 shared，那么它将被保存到特定的位置，从而对同一个本地工作组内所有计算着色器可见。如果某个计算着色器请求对共享变量进行写入，那么这个数据的修改信息将最终通知给同一个本地工作组的所有着色器。通常访问共享 shared 变量的性能会远好于访问图像或者着色器存储缓存（如主内存）的性能。因为着色器会将共享内存作为局部量处理，并且可以在设备中进行拷贝，所以访问共享变量可能比使用缓冲区的方法更迅速。因此，如果着色器需要对同一处内存进行大量的访问，优先考虑将内存拷贝到共享变量中，然后操作。",paraId:26,tocIndex:6},{value:"既然涉及到共享内存，肯定就需要设置同步点：",paraId:27,tocIndex:6},{value:"运行屏障（execution barrier），可以通过 barrier() 函数触发。如果计算着色器的一个请求遇到 barrier，那么它会停止运行，等待同一个本地工作组的所有请求也到达 barrier，然后才会执行后面的代码。",paraId:28,tocIndex:6},{value:"例如在我们实现的 Reduce 求和的",paraId:29,tocIndex:6},{value:"例子",paraId:30,tocIndex:6},{value:"中，使用了：",paraId:29,tocIndex:6},{value:"线程间共享内存",paraId:31,tocIndex:6},{value:"workgroupBarrier",paraId:31,tocIndex:6},{value:"var<workgroup> shared : array<f32, 128>;\n\nworkgroupBarrier();\n",paraId:32,tocIndex:6}]},11835:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(74199);const d=[{value:"我们参考 ",paraId:0},{value:"cuGraph",paraId:0},{value:" 以及其他 CUDA 实现，基于 ",paraId:0},{value:"g-plugin-gpgpu",paraId:1},{value:" 背后的 WebGPU 能力实现常见的图分析算法，达到大规模节点边数据量下并行加速的目的。",paraId:0},{value:"对比 G6 目前提供的 ",paraId:2},{value:"CPU 串行版本",paraId:2},{value:"有很大提升。",paraId:2},{value:"算法名",paraId:3},{value:"节点 / 边",paraId:3},{value:"CPU 耗时",paraId:3},{value:"GPU 耗时",paraId:3},{value:"Speed up",paraId:3},{value:"SSSP",paraId:3},{value:"1k 节点 5k 边",paraId:3},{value:"27687.10 ms",paraId:3},{value:"261.60 ms",paraId:3},{value:"~100x",paraId:3},{value:"PageRank",paraId:3},{value:"1k 节点 500k 边",paraId:3},{value:"13641.50 ms",paraId:3},{value:"130.20 ms",paraId:3},{value:"~100x",paraId:3},{value:"在使用前需要确认运行环境与数据这两项前置条件。",paraId:4,tocIndex:0},{value:"目前（2022-3-21）在 Chrome 94 正式版本以上即支持 WebGPU，但由于我们使用最新的 WGSL 语法，推荐更新浏览器到最新版。",paraId:5,tocIndex:1},{value:"目前在生产环境使用，需要启用 Origin Trial 以支持 WebGPU 特性（Chrome 100 以上将不再需要）：",paraId:6,tocIndex:1},{value:"获取 Token",paraId:7,tocIndex:1},{value:"在页面中添加 ",paraId:7,tocIndex:1},{value:"<meta>",paraId:7,tocIndex:1},{value:" 标签，附上上一步获取的 Token，例如通过 DOM API：",paraId:7,tocIndex:1},{value:"const tokenElement = document.createElement('meta');\ntokenElement.httpEquiv = 'origin-trial';\ntokenElement.content = 'AkIL...5fQ==';\ndocument.head.appendChild(tokenElement);\n",paraId:8,tocIndex:1},{value:"我们的官网已经添加了该 token，因此只需要使用最新版 Chrome 就能正常运行全部算法示例。",paraId:9,tocIndex:1},{value:"我们使用 G6 的",paraId:10,tocIndex:2},{value:"图数据格式",paraId:10,tocIndex:2},{value:"，它也是以下所有算法的第一个固定参数。在内部我们会将其转换成 GPU 内存友好的图存储格式例如 CSR(compressed sparse row)：",paraId:10,tocIndex:2},{value:"const data = {\n    // 点集\n    nodes: [\n        {\n            id: 'node1', // String，该节点存在则必须，节点的唯一标识\n            x: 100, // Number，可选，节点位置的 x 值\n            y: 200, // Number，可选，节点位置的 y 值\n        },\n        {\n            id: 'node2', // String，该节点存在则必须，节点的唯一标识\n            x: 300, // Number，可选，节点位置的 x 值\n            y: 200, // Number，可选，节点位置的 y 值\n        },\n    ],\n    // 边集\n    edges: [\n        {\n            source: 'node1', // String，必须，起始点 id\n            target: 'node2', // String，必须，目标点 id\n        },\n    ],\n};\n",paraId:11,tocIndex:2},{value:"如果数据格式不满足以上要求，算法将无法正常执行。",paraId:12,tocIndex:2},{value:"我们提供以下两种方式使用：",paraId:13,tocIndex:3},{value:"没有 G 的 ",paraId:14,tocIndex:3},{value:"Canvas 画布",paraId:15,tocIndex:3},{value:"，仅希望用它执行算法，不涉及渲染。这也是最简单的使用方式。",paraId:14,tocIndex:3},{value:"已有 G 的 ",paraId:14,tocIndex:3},{value:"Canvas 画布",paraId:16,tocIndex:3},{value:"，例如正在使用它渲染，此时仅需要调用算法。",paraId:14,tocIndex:3},{value:"创建一个 WebGPUGraph，内部会完成画布创建、插件注册等一系列初始化工作。完成后直接调用算法：",paraId:17,tocIndex:4},{value:"import { WebGPUGraph } from '@antv/webgpu-graph';\nconst graph = new WebGPUGraph();\n\n(async () => {\n    // 调用算法\n    const result = await graph.pageRank(data);\n})();\n",paraId:18,tocIndex:4},{value:"如果已经在使用 G 的 Canvas 画布进行渲染，可以复用它，并执行以下操作：",paraId:19,tocIndex:5},{value:"注册 ",paraId:20,tocIndex:5},{value:"g-plugin-gpgpu",paraId:21,tocIndex:5},{value:" 插件",paraId:20,tocIndex:5},{value:"等待画布初始化",paraId:20,tocIndex:5},{value:"获取 GPU ",paraId:20,tocIndex:5},{value:"Device",paraId:22,tocIndex:5},{value:"调用算法，此时算法的第一个参数为上一步获取到的 Device",paraId:20,tocIndex:5},{value:"import { Canvas } from '@antv/g';\nimport { Renderer } from '@antv/g-webgpu';\nimport { Plugin } from '@antv/g-plugin-gpgpu';\nimport { pageRank } from '@antv/webgpu-graph';\n\nconst webgpuRenderer = new Renderer();\nwebgpuRenderer.registerPlugin(new Plugin());\n\nconst canvas = new Canvas({\n    container: 'my-canvas-id',\n    width: 1,\n    height: 1,\n    renderer: webgpuRenderer,\n});\n\n(async () => {\n    // 等待画布初始化完成\n    await canvas.ready;\n\n    // 通过渲染器获取 Device\n    const plugin = webgpuRenderer.getPlugin('device-renderer');\n    const device = plugin.getDevice();\n\n    // 调用算法，传入 device 和图数据\n    const result = await pageRank(device, data);\n})();\n",paraId:23,tocIndex:5},{value:"以下所有算法均为异步调用。",paraId:24,tocIndex:5},{value:"为图中每一个节点计算 PageRank 得分。",paraId:25,tocIndex:7},{value:"参数列表如下：",paraId:26,tocIndex:7},{value:"名称",paraId:27,tocIndex:7},{value:"类型",paraId:27,tocIndex:7},{value:"是否必选",paraId:27,tocIndex:7},{value:"描述",paraId:27,tocIndex:7},{value:"graphData",paraId:27,tocIndex:7},{value:"GraphData",paraId:27,tocIndex:7},{value:"true",paraId:27,tocIndex:7},{value:"图数据",paraId:27,tocIndex:7},{value:"epsilon",paraId:27,tocIndex:7},{value:"number",paraId:27,tocIndex:7},{value:"false",paraId:27,tocIndex:7},{value:"判断 PageRank 得分是否稳定的精度值，默认值为 ",paraId:27,tocIndex:7},{value:"1e-05",paraId:27,tocIndex:7},{value:"alpha",paraId:27,tocIndex:7},{value:"number",paraId:27,tocIndex:7},{value:"false",paraId:27,tocIndex:7},{value:"阻尼系数（dumping factor），指任意时刻，用户访问到某节点后继续访问该节点指向的节点的概率，默认值为 ",paraId:27,tocIndex:7},{value:"0.85",paraId:27,tocIndex:7},{value:"。",paraId:27,tocIndex:7},{value:"maxIteration",paraId:27,tocIndex:7},{value:"number",paraId:27,tocIndex:7},{value:"false",paraId:27,tocIndex:7},{value:"迭代次数，默认值为 ",paraId:27,tocIndex:7},{value:"1000",paraId:27,tocIndex:7},{value:"返回值为一个结果数组，包含 ",paraId:28,tocIndex:7},{value:"id",paraId:28,tocIndex:7},{value:" 和 ",paraId:28,tocIndex:7},{value:"score",paraId:28,tocIndex:7},{value:" 属性，形如 ",paraId:28,tocIndex:7},{value:"[{ id: 'A', score: 0.38 }, { id: 'B', score: 0.32 }...]",paraId:28,tocIndex:7},{value:"。",paraId:28,tocIndex:7},{value:"其中数组元素已经按照 ",paraId:29,tocIndex:7},{value:"score",paraId:29,tocIndex:7},{value:" 进行了从高到低的排序，因此第一个元素代表重要性最高的节点。",paraId:29,tocIndex:7},{value:"参考以下 CUDA 版本实现：",paraId:30,tocIndex:7},{value:"https://github.com/princeofpython/PageRank-with-CUDA/blob/main/parallel.cu",paraId:31,tocIndex:7},{value:"https://docs.rapids.ai/api/cugraph/stable/api_docs/api/cugraph.dask.link_analysis.pagerank.pagerank.html",paraId:31,tocIndex:7},{value:"使用方式如下，",paraId:32,tocIndex:7},{value:"示例",paraId:33,tocIndex:7},{value:"：",paraId:32,tocIndex:7},{value:"const result = await graph.pageRank(data);\n// [{id: 'B', score: 0.3902697265148163}, {}...]\n",paraId:34,tocIndex:7},{value:"在较大规模的点边场景下有非常明显的提升：",paraId:35,tocIndex:7},{value:"算法名",paraId:36,tocIndex:7},{value:"节点 / 边",paraId:36,tocIndex:7},{value:"CPU 耗时",paraId:36,tocIndex:7},{value:"GPU 耗时",paraId:36,tocIndex:7},{value:"Speed up",paraId:36,tocIndex:7},{value:"PageRank",paraId:36,tocIndex:7},{value:"1k 节点 500k 边",paraId:36,tocIndex:7},{value:"13641.50 ms",paraId:36,tocIndex:7},{value:"130.20 ms",paraId:36,tocIndex:7},{value:"~100x",paraId:36,tocIndex:7},{value:"⚠️ 目前我们的实现需要使用 V * V 的存储空间，因此节点数量太多会触发 JS 的数组的 ",paraId:37,tocIndex:7},{value:"RangeError",paraId:37,tocIndex:7},{value:"。",paraId:37,tocIndex:7},{value:"单源最短路径，即从一个节点出发，到其他所有节点的最短路径。",paraId:38,tocIndex:9},{value:"参数列表如下：",paraId:39,tocIndex:9},{value:"名称",paraId:40,tocIndex:9},{value:"类型",paraId:40,tocIndex:9},{value:"是否必选",paraId:40,tocIndex:9},{value:"描述",paraId:40,tocIndex:9},{value:"graphData",paraId:40,tocIndex:9},{value:"GraphData",paraId:40,tocIndex:9},{value:"true",paraId:40,tocIndex:9},{value:"图数据",paraId:40,tocIndex:9},{value:"source",paraId:40,tocIndex:9},{value:"string",paraId:40,tocIndex:9},{value:"true",paraId:40,tocIndex:9},{value:"源节点 id",paraId:40,tocIndex:9},{value:"weightPropertyName",paraId:40,tocIndex:9},{value:"string",paraId:40,tocIndex:9},{value:"false",paraId:40,tocIndex:9},{value:"边的权重属性字段名，若不指定，则认为所有边权重相同",paraId:40,tocIndex:9},{value:"maxDistance",paraId:40,tocIndex:9},{value:"number",paraId:40,tocIndex:9},{value:"false",paraId:40,tocIndex:9},{value:"最大距离，默认为 ",paraId:40,tocIndex:9},{value:"1000000",paraId:40,tocIndex:9},{value:"返回值为一个结果数组，形如 ",paraId:41,tocIndex:9},{value:"[{ target: 'A', distance: 10, predecessor: 'B' }, ...]",paraId:41,tocIndex:9},{value:"。其中数组中每一个元素包含以下属性：",paraId:41,tocIndex:9},{value:"target",paraId:42,tocIndex:9},{value:" 路径终点 id",paraId:42,tocIndex:9},{value:"distance",paraId:42,tocIndex:9},{value:" 从源节点到终点的距离",paraId:42,tocIndex:9},{value:"predecessor",paraId:42,tocIndex:9},{value:" 到达 target 的上一个节点 id",paraId:42,tocIndex:9},{value:"参考以下 CUDA 版本实现：",paraId:43,tocIndex:9},{value:"https://www.lewuathe.com/illustration-of-distributed-bellman-ford-algorithm.html",paraId:44,tocIndex:9},{value:"https://github.com/sengorajkumar/gpu_graph_algorithms",paraId:44,tocIndex:9},{value:"https://docs.rapids.ai/api/cugraph/stable/api_docs/api/cugraph.traversal.sssp.sssp.html",paraId:44,tocIndex:9},{value:"以下图为例，我们希望获取以 ",paraId:45,tocIndex:9},{value:"A",paraId:45,tocIndex:9},{value:" 为源节点到所有节点的最短路径：",paraId:45,tocIndex:9},{value:"在图数据中，边的权重字段为 ",paraId:46,tocIndex:9},{value:"weight",paraId:46,tocIndex:9},{value:"，",paraId:46,tocIndex:9},{value:"示例",paraId:47,tocIndex:9},{value:"：",paraId:46,tocIndex:9},{value:"edges: [\n    {\n        source: 'A',\n        target: 'B',\n        weight: 9,\n    },\n    // 省略其他边\n];\n",paraId:48,tocIndex:9},{value:"对于返回结果的解读方法如下，如果我们想获取从 ",paraId:49,tocIndex:9},{value:"A",paraId:49,tocIndex:9},{value:" 到 ",paraId:49,tocIndex:9},{value:"E",paraId:49,tocIndex:9},{value:" 的完整最短路径，可以先从最后一个元素看起，发现 ",paraId:49,tocIndex:9},{value:"E",paraId:49,tocIndex:9},{value:" 的前序节点为 ",paraId:49,tocIndex:9},{value:"B",paraId:49,tocIndex:9},{value:"，然后 ",paraId:49,tocIndex:9},{value:"B",paraId:49,tocIndex:9},{value:" 的前序节点为 ",paraId:49,tocIndex:9},{value:"D",paraId:49,tocIndex:9},{value:"，最终可以得到 ",paraId:49,tocIndex:9},{value:"A -> C -> D -> B -> E",paraId:49,tocIndex:9},{value:" 这样一条完整的最短路径：",paraId:49,tocIndex:9},{value:"const result = await graph.sssp(data, 'A', 'weight');\n\n// 结果如下\n[\n    { target: 'A', distance: 0, predecessor: 'A' },\n    { target: 'B', distance: 8, predecessor: 'D' },\n    { target: 'C', distance: 4, predecessor: 'A' },\n    { target: 'D', distance: 6, predecessor: 'C' },\n    { target: 'E', distance: 11, predecessor: 'B' },\n];\n",paraId:50,tocIndex:9},{value:"需要注意的是，如果起始节点和终点为同一节点，",paraId:51,tocIndex:9},{value:"distance",paraId:51,tocIndex:9},{value:" 等于 0。",paraId:51,tocIndex:9},{value:"在较大规模的点边场景下有非常明显的提升：",paraId:52,tocIndex:9},{value:"算法名",paraId:53,tocIndex:9},{value:"节点 / 边",paraId:53,tocIndex:9},{value:"CPU 耗时",paraId:53,tocIndex:9},{value:"GPU 耗时",paraId:53,tocIndex:9},{value:"Speed up",paraId:53,tocIndex:9},{value:"SSSP",paraId:53,tocIndex:9},{value:"1k 节点 5k 边",paraId:53,tocIndex:9},{value:"27687.10 ms",paraId:53,tocIndex:9},{value:"261.60 ms",paraId:53,tocIndex:9},{value:"~100x",paraId:53,tocIndex:9},{value:"Accelerating large graph algorithms on the GPU using CUDA",paraId:54,tocIndex:10},{value:"Scalable GPU Graph Traversal",paraId:55,tocIndex:11},{value:"https://github.com/rafalk342/bfs-cuda",paraId:55,tocIndex:11},{value:"https://github.com/kaletap/bfs-cuda-gpu",paraId:55,tocIndex:11},{value:"https://github.com/divyanshu-talwar/Parallel-DFS",paraId:56,tocIndex:12},{value:"A CUDA Implementation of the K-Means Clustering Algorithm",paraId:57,tocIndex:14},{value:'"Yinyang" K-means and K-nn using NVIDIA CUDA',paraId:57,tocIndex:14},{value:"Demystifying Louvain’s Algorithm and Its implementation in GPU",paraId:58,tocIndex:16},{value:"https://docs.rapids.ai/api/cugraph/stable/api_docs/api/cugraph.louvain.html",paraId:58,tocIndex:16},{value:"https://github.com/rapidsai/cugraph/tree/branch-22.08/cpp/src/community",paraId:58,tocIndex:16},{value:"K-Core Decomposition with CUDA",paraId:59,tocIndex:17},{value:"Parallel Graph Component Labelling with GPUs and CUDA",paraId:60,tocIndex:18},{value:"GPU-Accelerated Graph Label Propagation for Real-Time Fraud Detection",paraId:60,tocIndex:18},{value:"https://github.com/jiachengpan/cudaMST",paraId:61,tocIndex:19},{value:"https://github.com/Dibyadarshan/GPU-Based-Fast-Minimum-Spanning-Tree",paraId:61,tocIndex:19},{value:"https://github.com/adamantmc/CudaCosineSimilarity",paraId:62,tocIndex:21},{value:"https://github.com/hamham240/cudaGraph/blob/main/src/algos/cudaCD.cu",paraId:63,tocIndex:24}]},57154:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(67349);const d=[{value:"使用 ",paraId:0},{value:"CanvasRenderingContext2D",paraId:0},{value:" 绘制 2D 图形。会在容器中创建一个 ",paraId:0},{value:"<canvas>",paraId:0},{value:" 元素。",paraId:0},{value:"和 ",paraId:1,tocIndex:0},{value:"@antv/g",paraId:1,tocIndex:0},{value:" 一样，也有以下两种使用方式。",paraId:1,tocIndex:0},{value:"安装 ",paraId:2,tocIndex:1},{value:"@antv/g-canvas",paraId:2,tocIndex:1},{value:" 后可以从中获取渲染器：",paraId:2,tocIndex:1},{value:"import { Canvas } from '@antv/g';\nimport { Renderer } from '@antv/g-canvas';\n\nconst canvasRenderer = new Renderer();\n\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer: canvasRenderer,\n});\n",paraId:3,tocIndex:1},{value:'<script\n  src="https://unpkg.com/@antv/g-canvas/dist/index.umd.min.js"\n  type="application/javascript">\n',paraId:4,tocIndex:2},{value:"从 ",paraId:5,tocIndex:2},{value:"G.Canvas2D",paraId:5,tocIndex:2},{value:" 命名空间下可以获取渲染器：",paraId:5,tocIndex:2},{value:"const canvasRenderer = new window.G.Canvas2D.Renderer();\n",paraId:6,tocIndex:2},{value:"在创建渲染器时，可以传入一些初始化配置项，例如：",paraId:7,tocIndex:3},{value:"import { Renderer } from '@antv/g-canvas';\nconst renderer = new Renderer({\n    enableDirtyRectangleRendering: true,\n});\n",paraId:8,tocIndex:3},{value:"是否开启“脏矩形”渲染。开启后将大幅提升 Canvas2D 环境下的渲染性能。默认开启。",paraId:9,tocIndex:4},{value:"一种常见的交互是通过鼠标高亮某个图形。此时场景中仅有一小部分发生了改变，擦除画布中的全部图形再重绘就显得没有必要了。类比 React diff 算法能够找出真正变化的最小部分，“脏矩形”渲染能尽可能复用上一帧的渲染结果，仅绘制变更部分，特别适合 Canvas2D API。",paraId:10,tocIndex:4},{value:"下图展示了这个思路：",paraId:11,tocIndex:4},{value:"当鼠标悬停在圆上时，我们知道了对应的“脏矩形”，也就是这个圆的包围盒",paraId:12,tocIndex:4},{value:"找到场景中与这个包围盒区域相交的其他图形，这里找到了另一个矩形",paraId:12,tocIndex:4},{value:"使用 ",paraId:12,tocIndex:4},{value:"clearRect",paraId:12,tocIndex:4},{value:" 清除这个“脏矩形”，代替清空整个画布",paraId:12,tocIndex:4},{value:"按照 z-index 依次绘制一个矩形和圆形",paraId:12,tocIndex:4},{value:"在以上求交与区域查询的过程中，我们可以复用剔除方案中的优化手段，例如加速结构。在实现中我们使用了 ",paraId:13,tocIndex:4},{value:"RBush",paraId:13,tocIndex:4},{value:"。",paraId:13,tocIndex:4},{value:"显然当动态变化的对象数目太多时，该优化手段就失去了意义，试想经过一番计算合并后的“脏矩形”几乎等于整个画布，那还不如直接清空重绘所有对象。因此例如 Pixi.js 这样的 2D 游戏渲染引擎就",paraId:14,tocIndex:4},{value:"不考虑内置",paraId:14,tocIndex:4},{value:"。",paraId:14,tocIndex:4},{value:"但在可视化这类相对静态的场景下就显得有意义了，例如在触发拾取后只更新图表的局部，其余部分保持不变。",paraId:15,tocIndex:4},{value:"用于 debug，默认关闭，开启后画布会触发 ",paraId:16,tocIndex:5},{value:"CanvasEvent.DIRTY_RECTANGLE",paraId:16,tocIndex:5},{value:" 事件并携带脏矩形信息，可用于后续可视化。",paraId:16,tocIndex:5},{value:"在该",paraId:17,tocIndex:5},{value:"示例",paraId:18,tocIndex:5},{value:"中，当鼠标划过各个圆时，能展示出当前需要被清除的脏矩形，当前帧仅会重绘该区域：",paraId:17,tocIndex:5},{value:"需要注意的是，脏矩形的坐标在 ",paraId:19,tocIndex:5},{value:"Canvas 坐标系下",paraId:20,tocIndex:5},{value:"，如果想使用 HTML 绘制浮层，需要使用",paraId:19,tocIndex:5},{value:"坐标系转换方法",paraId:21,tocIndex:5},{value:"：",paraId:19,tocIndex:5},{value:"// display dirty rectangle\nconst $dirtyRectangle = document.createElement('div');\n$dirtyRectangle.style.cssText = `\nposition: absolute;\npointer-events: none;\nbackground: rgba(255, 0, 0, 0.5);\n`;\n$wrapper.appendChild($dirtyRectangle);\n\ncanvas.addEventListener(CanvasEvent.DIRTY_RECTANGLE, (e) => {\n    const { dirtyRect } = e.detail;\n    const { x, y, width, height } = dirtyRect;\n\n    const dpr = window.devicePixelRatio;\n\n    // convert from canvas coords to viewport\n    $dirtyRectangle.style.left = `${x / dpr}px`;\n    $dirtyRectangle.style.top = `${y / dpr}px`;\n    $dirtyRectangle.style.width = `${width / dpr}px`;\n    $dirtyRectangle.style.height = `${height / dpr}px`;\n});\n",paraId:22,tocIndex:5},{value:"该渲染器内置了以下插件：",paraId:23,tocIndex:6},{value:"g-plugin-canvas-renderer",paraId:24,tocIndex:6},{value:" 使用 ",paraId:25,tocIndex:6},{value:"CanvasRenderingContext2D",paraId:25,tocIndex:6},{value:" 渲染 2D 图形",paraId:25,tocIndex:6},{value:"g-plugin-canvas-picker",paraId:26,tocIndex:6},{value:" 基于数学方法和 ",paraId:25,tocIndex:6},{value:"CanvasRenderingContext2D",paraId:25,tocIndex:6},{value:" 拾取图形",paraId:25,tocIndex:6},{value:"g-plugin-dom-interaction",paraId:27,tocIndex:6},{value:" 基于 DOM API 绑定事件",paraId:25,tocIndex:6},{value:"除了内置插件，还有以下可选插件。",paraId:28,tocIndex:7},{value:"使用 ",paraId:29,tocIndex:8},{value:"rough.js",paraId:29,tocIndex:8},{value:" 的 Canvas 版本进行手绘风格的渲染。",paraId:29,tocIndex:8},{value:"我们提供了 ",paraId:30,tocIndex:8},{value:"g-plugin-rough-canvas-renderer",paraId:31,tocIndex:8},{value:" 插件，注册后会替换掉 ",paraId:30,tocIndex:8},{value:"g-plugin-canvas-renderer",paraId:32,tocIndex:8},{value:" 对于部分 2D 图形的渲染能力。",paraId:30,tocIndex:8},{value:"示例",paraId:33,tocIndex:8},{value:"效果如下：",paraId:34,tocIndex:8},{value:"该渲染器依赖 ",paraId:35,tocIndex:9},{value:"CanvasRenderingContext2D",paraId:35,tocIndex:9},{value:" 渲染能力，并不局限在浏览器端，因此也可以使用 ",paraId:35,tocIndex:9},{value:"node-canvas",paraId:35,tocIndex:9},{value:" 进行服务端渲染。",paraId:35,tocIndex:9},{value:"在我们的",paraId:36,tocIndex:9},{value:"集成测试",paraId:36,tocIndex:9},{value:"中，会在 Node 端配合 ",paraId:36,tocIndex:9},{value:"node-canvas",paraId:36,tocIndex:9},{value:" 渲染结果图片，与基准图片进行比对。其他服务端渲染场景也可以按照以下步骤进行：",paraId:36,tocIndex:9},{value:"使用 ",paraId:37,tocIndex:9},{value:"unregisterPlugin",paraId:38,tocIndex:9},{value:" 卸载掉 ",paraId:37,tocIndex:9},{value:"g-canvas",paraId:39,tocIndex:9},{value:" 中内置的与 DOM API 相关的插件，例如负责事件绑定的 ",paraId:37,tocIndex:9},{value:"g-plugin-dom-interaction",paraId:40,tocIndex:9},{value:"使用 ",paraId:37,tocIndex:9},{value:"node-canvas",paraId:37,tocIndex:9},{value:" 创建一个类 ",paraId:37,tocIndex:9},{value:"Canvas",paraId:37,tocIndex:9},{value:" 对象，通过 ",paraId:37,tocIndex:9},{value:"canvas",paraId:41,tocIndex:9},{value:" 属性传入画布",paraId:37,tocIndex:9},{value:"正常使用 ",paraId:37,tocIndex:9},{value:"g-canvas",paraId:42,tocIndex:9},{value:" 渲染器，通过 G 的 API 创建场景",paraId:37,tocIndex:9},{value:"使用 ",paraId:37,tocIndex:9},{value:"node-canvas",paraId:37,tocIndex:9},{value:" 提供的方法（例如 ",paraId:37,tocIndex:9},{value:"createPNGStream",paraId:37,tocIndex:9},{value:"）输出结果图片",paraId:37,tocIndex:9},{value:"https://github.com/antvis/g/blob/next/integration/",paraId:43,tocIndex:9},{value:"node",paraId:43,tocIndex:9},{value:"tests__/canvas/circle.spec.js",paraId:43,tocIndex:9},{value:"const { createCanvas } = require('canvas');\nconst { Circle, Canvas } = require('@antv/g');\nconst { Renderer } = require('@antv/g-canvas');\n\n// create a node-canvas\nconst nodeCanvas = createCanvas(200, 200);\n\n// create a renderer, unregister plugin relative to DOM\nconst renderer = new Renderer();\nconst domInteractionPlugin = renderer.getPlugin('dom-interaction');\nrenderer.unregisterPlugin(domInteractionPlugin);\n\nconst canvas = new Canvas({\n    width: 200,\n    height: 200,\n    canvas: nodeCanvas, // use node-canvas\n    renderer,\n});\n\nconst circle = new Circle({\n    style: {\n        r: 10,\n        fill: 'red',\n    },\n});\ncanvas.appendChild(circle);\n\n// output image\nconst out = fs.createWriteStream(__dirname + RESULT_IMAGE);\nconst stream = nodeCanvas.createPNGStream();\nstream.pipe(out);\nout.on('finish', () => {});\n",paraId:44,tocIndex:9},{value:"如果希望在 G 绘制之后使用 ",paraId:45,tocIndex:10},{value:"CanvasRenderingContext2D",paraId:45,tocIndex:10},{value:" 继续绘制，可以在 ",paraId:45,tocIndex:10},{value:"CanvasEvent.AFTER_RENDER",paraId:45,tocIndex:10},{value:" 时获取上下文，此时 G 已经完成了绘制，但由于在上下文中设置可 transform，在绘制前需要先清除，然后就可以按照 Canvas 原生坐标系进行绘制：",paraId:45,tocIndex:10},{value:"// 在 G 绘制完接着画\ncanvas.addEventListener(CanvasEvent.AFTER_RENDER, () => {\n    // 获取原生 Canvas2DContext\n    const context = canvas.getContextService().getContext();\n\n    // 重置 transform\n    context.resetTransform();\n\n    // 绘制\n    context.fillStyle = 'red';\n    context.fillRect(200, 200, 100, 100);\n});\n",paraId:46,tocIndex:10},{value:"示例",paraId:47,tocIndex:10}]},71344:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(63869);const d=[{value:"使用 ",paraId:0},{value:"Skia",paraId:0},{value:" 绘制 2D 图形。在运行时异步加载 WASM 格式的 ",paraId:0},{value:"Canvaskit",paraId:0},{value:"，将 ",paraId:0},{value:"WebGL2RenderingContext",paraId:0},{value:" 封装成 ",paraId:0},{value:"SkSurface",paraId:0},{value:" ，进而通过页面上的 ",paraId:0},{value:"<canvas>",paraId:0},{value:" 元素进行绘制。",paraId:0},{value:"Skia 相比 Canvas2D API 提供了更多特性，例如文本段落排版、",paraId:1},{value:"Lottie 动画",paraId:1},{value:"、粒子特效等。除了 Chrome 和 Android，一些跨平台的方案例如 ",paraId:1},{value:"Flutter",paraId:1},{value:"、",paraId:1},{value:"Weex",paraId:1},{value:" 中也使用了它作为底层渲染引擎。",paraId:1},{value:"CodeSandbox 例子",paraId:2},{value:"和 ",paraId:3,tocIndex:0},{value:"@antv/g",paraId:3,tocIndex:0},{value:" 一样，也有以下两种使用方式。",paraId:3,tocIndex:0},{value:"安装 ",paraId:4,tocIndex:1},{value:"@antv/g-canvaskit",paraId:4,tocIndex:1},{value:" 后可以从中获取渲染器：",paraId:4,tocIndex:1},{value:"import { Canvas } from '@antv/g';\nimport { Renderer } from '@antv/g-canvaskit';\n\nconst canvaskitRenderer = new Renderer();\n\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer: canvaskitRenderer,\n});\n",paraId:5,tocIndex:1},{value:'<script\n  src="https://unpkg.com/@antv/g-canvaskit/dist/index.umd.min.js"\n  type="application/javascript">\n',paraId:6,tocIndex:2},{value:"从 ",paraId:7,tocIndex:2},{value:"G.Canvaskit",paraId:7,tocIndex:2},{value:" 命名空间下可以获取渲染器：",paraId:7,tocIndex:2},{value:"const canvasRenderer = new window.G.Canvaskit.Renderer();\n",paraId:8,tocIndex:2},{value:"CanvasKit 的 WASM 文件夹路径。默认值为 ",paraId:9,tocIndex:4},{value:"'https://unpkg.com/canvaskit-wasm@0.34.1/bin/full/'",paraId:9,tocIndex:4},{value:"，即从 CDN 上下载。",paraId:9,tocIndex:4},{value:"在实际使用时，我们可以将 WASM 拷贝到服务器资源目录下（例如配合 webpack 等构建工具），代替从 CDN 加载。在我们的网站中就将该文件拷贝到了根目录（",paraId:10,tocIndex:4},{value:"'/'",paraId:10,tocIndex:4},{value:"）下，此时可以通过 ",paraId:10,tocIndex:4},{value:"wasmDir",paraId:10,tocIndex:4},{value:" 配置项指定文件夹路径：",paraId:10,tocIndex:4},{value:"const canvaskitRenderer = new CanvaskitRenderer({\n    wasmDir: '/',\n});\n",paraId:11,tocIndex:4},{value:"值得一提的是 CanvasKit 提供了多个版本的 WASM 文件：",paraId:12,tocIndex:4},{value:"精简版，约 7.1MB，",paraId:13,tocIndex:4},{value:"'https://unpkg.com/canvaskit-wasm@0.34.1/bin/'",paraId:13,tocIndex:4},{value:"全量功能，约 7.9MB，包含完整的",paraId:13,tocIndex:4},{value:"增强功能",paraId:14,tocIndex:4},{value:"，推荐使用该版本 ",paraId:13,tocIndex:4},{value:"'https://unpkg.com/canvaskit-wasm@0.34.1/bin/full'",paraId:13,tocIndex:4},{value:"开发版本，约 9.1MB ",paraId:13,tocIndex:4},{value:"'https://unpkg.com/canvaskit-wasm@0.34.1/bin/profiling'",paraId:13,tocIndex:4},{value:"CanvasKit 相较于我们熟悉的 Canvas 2D API，在文本尤其是段落方面提供了多行布局、装饰、省略等功能。唯一的问题是需要在运行时加载字体文件。",paraId:15,tocIndex:5},{value:"对于 CJK(Chinese, Japanese, and Korean) 字符，如果使用了不支持它们的字体，在渲染时会出现以下效果，下图来自 ",paraId:16,tocIndex:5},{value:"Flutter 的一个 ISSUE",paraId:16,tocIndex:5},{value:"：",paraId:16,tocIndex:5},{value:"因此 Android 默认使用 ",paraId:17,tocIndex:5},{value:"NotoSansCJK",paraId:17,tocIndex:5},{value:" 字体：",paraId:17,tocIndex:5},{value:'<family lang="zh-Hans">\n    <font weight="400" style="normal" index="2">NotoSansCJK-Regular.ttc</font>\n</family>\n<family lang="zh-Hant zh-Bopo">\n    <font weight="400" style="normal" index="3">NotoSansCJK-Regular.ttc</font>\n</family>\n<family lang=" ja  ja-Latn">\n    <font weight="400" style="normal" index="0">NotoSansCJK-Regular.ttc</font>\n</family>\n<family lang="ko ko-Latn  ">\n    <font weight="400" style="normal" index="1">NotoSansCJK-Regular.ttc</font>\n</family>\n',paraId:18,tocIndex:5},{value:"但",paraId:19,tocIndex:5},{value:"完整的 NotoSansCJK",paraId:19,tocIndex:5},{value:" 体积非常大，在我们的实际开发中，如果只需要简体中文，可以仅加载它的子集（约 36MB）：",paraId:19,tocIndex:5},{value:"const canvaskitRenderer = new CanvaskitRenderer({\n    wasmDir: '/',\n    fonts: [\n        {\n            name: 'sans-serif',\n            url: '/NotoSansCJKsc-VF.ttf',\n        },\n    ],\n});\n",paraId:20,tocIndex:5},{value:"该渲染器内置了以下插件：",paraId:21,tocIndex:6},{value:"g-plugin-canvaskit-renderer",paraId:22,tocIndex:6},{value:" 使用 CanvasKit 渲染 2D 图形",paraId:23,tocIndex:6},{value:"g-plugin-canvas-picker",paraId:24,tocIndex:6},{value:" 基于数学方法和 ",paraId:23,tocIndex:6},{value:"CanvasRenderingContext2D",paraId:23,tocIndex:6},{value:" 拾取图形",paraId:23,tocIndex:6},{value:"g-plugin-dom-interaction",paraId:25,tocIndex:6},{value:" 基于 DOM API 绑定事件",paraId:23,tocIndex:6},{value:"CanvasKit（完整版本）相较于我们熟悉的 Canvas 2D API，提供了以下增强功能：",paraId:26,tocIndex:7},{value:"Skottie",paraId:27,tocIndex:7},{value:" Lottie 动画播放器",paraId:27,tocIndex:7},{value:"粒子特效",paraId:27,tocIndex:7},{value:"段落排版",paraId:27,tocIndex:7},{value:"Lottie",paraId:28,tocIndex:8},{value:" 动画通过 After Effects 的 ",paraId:28,tocIndex:8},{value:"Bodymovin",paraId:28,tocIndex:8},{value:" 插件创建，导出成 JSON 格式。CanvasKit 提供了 ",paraId:28,tocIndex:8},{value:"Skottie",paraId:28,tocIndex:8},{value:" 这个 Lottie 动画播放器。",paraId:28,tocIndex:8},{value:"在该",paraId:29,tocIndex:8},{value:"示例",paraId:30,tocIndex:8},{value:"中我们展示了如何播放一个乐高动画：",paraId:29,tocIndex:8},{value:"首先创建渲染器并通过 ",paraId:31,tocIndex:8},{value:"getPlugin",paraId:32,tocIndex:8},{value:" 获取 ",paraId:31,tocIndex:8},{value:"g-plugin-canvaskit-renderer",paraId:33,tocIndex:8},{value:" 插件：",paraId:31,tocIndex:8},{value:"import { Renderer } from '@antv/g-canvaskit';\n\n// 创建渲染器\nconst canvaskitRenderer = new Renderer({\n    wasmDir: '/',\n});\n// 获取渲染插件\nconst plugin = canvaskitRenderer.getPlugin('canvaskit-renderer');\n",paraId:34,tocIndex:8},{value:"然后等待画布初始化完成，并加载 Lottie 动画描述文件，完成后调用 ",paraId:35,tocIndex:8},{value:"playAnimation",paraId:36,tocIndex:8},{value:" 立刻开始播放：",paraId:35,tocIndex:8},{value:"(async () => {\n    const cdn = 'https://storage.googleapis.com/skia-cdn/misc/';\n\n    const [_, jsonstr] = await Promise.all([\n        // 等待画布初始化完成\n        canvas.ready,\n        // 加载 Lottie 动画描述文件\n        fetch(cdn + 'lego_loader.json').then((response) => response.text()),\n    ]);\n\n    const animation = plugin.playAnimation(\n        'sk_legos',\n        jsonstr,\n        [-50, 0, 350, 300],\n    );\n})();\n",paraId:37,tocIndex:8},{value:"如果想移除动画，可以调用：",paraId:38,tocIndex:8},{value:"animation.delete();\n",paraId:39,tocIndex:8},{value:"例如烟火、火焰等粒子特效需要生成大量“粒子”并应用动画，通常在 GPU 中通过 Shader 编程实现，例如用以改变每个粒子位置的插值计算，应当放在 GPU 而非在 CPU 中完成。",paraId:40,tocIndex:9},{value:"CanvasKit 提供了基于 Skia 的编程语言 ",paraId:41,tocIndex:9},{value:"SkSL(Skia’s shading language)",paraId:41,tocIndex:9},{value:" 实现，语法上十分接近 GLSL，在 Shader 中用以控制粒子的生成以及动画，对于没接触过 Shader 编程的开发者存在一定门槛。",paraId:41,tocIndex:9},{value:"在该",paraId:42,tocIndex:9},{value:"示例",paraId:43,tocIndex:9},{value:"中，我们实现了一些粒子特效：",paraId:42,tocIndex:9},{value:"首先创建渲染器并通过 ",paraId:44,tocIndex:9},{value:"getPlugin",paraId:45,tocIndex:9},{value:" 获取 ",paraId:44,tocIndex:9},{value:"g-plugin-canvaskit-renderer",paraId:46,tocIndex:9},{value:" 插件：",paraId:44,tocIndex:9},{value:"import { Renderer } from '@antv/g-canvaskit';\n\n// 创建渲染器\nconst canvaskitRenderer = new Renderer({\n    wasmDir: '/',\n});\n// 获取渲染插件\nconst plugin = canvaskitRenderer.getPlugin('canvaskit-renderer');\n",paraId:47,tocIndex:9},{value:"然后调用插件的 ",paraId:48,tocIndex:9},{value:"createParticles",paraId:49,tocIndex:9},{value:" 创建粒子效果，在每一帧的回调函数中对画布进行变换以调整粒子的位置，最后通过 ",paraId:48,tocIndex:9},{value:"start",paraId:50,tocIndex:9},{value:" 开始生成粒子：",paraId:48,tocIndex:9},{value:"const textParticles = plugin.createParticles(JSON.stringify(text), (canvas) => {\n    canvas.translate(250, 250);\n});\ntextParticles.start(Date.now() / 1000.0, true);\n",paraId:51,tocIndex:9},{value:"最后我们来看关键的粒子效果定义：",paraId:52,tocIndex:9},{value:"MaxCount 粒子数目",paraId:53,tocIndex:9},{value:"Drawable 粒子的类型，通常使用 ",paraId:53,tocIndex:9},{value:"'SkCircleDrawable'",paraId:53,tocIndex:9},{value:" 即可，可以修改大小",paraId:53,tocIndex:9},{value:"Code SkSL 代码，用以控制粒子的生命周期，例如每一帧中位置和颜色应该如何改变",paraId:53,tocIndex:9},{value:"Bindings",paraId:53,tocIndex:9},{value:"const text = {\n    MaxCount: 2000,\n    Drawable: {\n        Type: 'SkCircleDrawable',\n        Radius: 1,\n    },\n    Code: [\n        'void effectSpawn(inout Effect effect) {',\n        '  effect.rate = 1000;',\n        '}',\n        '',\n        'void spawn(inout Particle p) {',\n        '  p.lifetime = mix(1, 3, rand(p.seed));',\n        '  float a = radians(mix(250, 290, rand(p.seed)));',\n        '  float s = mix(10, 30, rand(p.seed));',\n        '  p.vel.x = cos(a) * s;',\n        '  p.vel.y = sin(a) * s;',\n        '  p.pos += text(rand(p.seed)).xy;',\n        '}',\n        '',\n        'void update(inout Particle p) {',\n        '  float4 startColor = float4(1, 0.196, 0.078, 1);',\n        '  float4 endColor   = float4(1, 0.784, 0.078, 1);',\n        '  p.color = mix(startColor, endColor, p.age);',\n        '}',\n        '',\n    ],\n    Bindings: [\n        {\n            Type: 'SkTextBinding',\n            Name: 'text',\n            Text: 'AntV',\n            FontSize: 96,\n        },\n    ],\n};\n",paraId:54,tocIndex:9},{value:"相较于 Canvas2D API 中的 ",paraId:55,tocIndex:10},{value:"fillText",paraId:55,tocIndex:10},{value:"，CanvasKit 提供了沿指定路径绘制文本的能力。",paraId:55,tocIndex:10},{value:"在该",paraId:56,tocIndex:10},{value:"示例",paraId:57,tocIndex:10},{value:"中，我们可以沿 ",paraId:56,tocIndex:10},{value:"Path",paraId:58,tocIndex:10},{value:" 绘制文本：",paraId:56,tocIndex:10},{value:"我们可以使用 ",paraId:59,tocIndex:10},{value:"alongPath",paraId:60,tocIndex:10},{value:" 属性：",paraId:59,tocIndex:10},{value:"const alongPath = new Path({\n    style: {\n        d: 'M 0,40 C 5.5555555555555545...',\n    },\n});\n\nconst text = new Text({\n    style: {\n        fontFamily: 'sans-serif',\n        fontSize: 22,\n        fill: '#1890FF',\n        text: 'abcdefghijklmn这是测试文字',\n        alongPath,\n    },\n});\n",paraId:61,tocIndex:10},{value:"一般的字体是无法支持 Emoji 的：",paraId:62,tocIndex:11},{value:"const emoji = new Text({\n    style: {\n        fontFamily: 'sans-serif',\n        fontSize: 30,\n        fill: 'black',\n        text: 'Emoji 🍕🍔🍟🥝🍱🕶🎩👩‍👩‍👦👩‍👩‍👧‍👧👩‍👩‍👦👩‍👩‍👧‍👧👩‍👩‍👦👩‍👩‍👧‍👧👩‍👩‍👦👩‍👩‍👧‍👧👩‍👩‍👦👩‍👩‍👧‍👧👩‍👩‍👦👩‍👩‍👧‍👧👩‍👩‍👦👩‍👩‍👧‍👧',\n    },\n});\n",paraId:63,tocIndex:11},{value:"例如 ",paraId:64,tocIndex:11},{value:"NotoSansCJKsc-VF",paraId:64,tocIndex:11},{value:" 会展示如下效果：",paraId:64,tocIndex:11},{value:"在该",paraId:65,tocIndex:11},{value:"示例",paraId:66,tocIndex:11},{value:"中，我们加载支持 Emoji 的字体例如 ",paraId:65,tocIndex:11},{value:"NotoColorEmoji",paraId:65,tocIndex:11},{value:"，它也在 Android 和 Chrome 中使用：",paraId:65,tocIndex:11},{value:"const canvaskitRenderer = new CanvaskitRenderer({\n    wasmDir: '/',\n    fonts: [\n        {\n            name: 'Roboto',\n            url: '/NotoSansCJKsc-VF.ttf',\n        },\n        {\n            name: 'Noto Color Emoji',\n            url: '/NotoColorEmoji.ttf',\n        },\n    ],\n});\n",paraId:67,tocIndex:11},{value:"此时就可以正常展示了，在 ",paraId:68,tocIndex:11},{value:"fontFamily",paraId:68,tocIndex:11},{value:" 中指定两种字体：",paraId:68,tocIndex:11},{value:"const emoji = new Text({\n    style: {\n        fontFamily: 'Roboto, Noto Color Emoji',\n    },\n});\n",paraId:69,tocIndex:11},{value:"CanvasKit 提供了增强的",paraId:70,tocIndex:12},{value:"段落绘制能力",paraId:70,tocIndex:12},{value:"。",paraId:70,tocIndex:12},{value:"在 CSS 中可以使用 ",paraId:71,tocIndex:13},{value:"text-decoration",paraId:71,tocIndex:13},{value:" 属性设置文本的修饰线外观。",paraId:71,tocIndex:13},{value:"在该",paraId:72,tocIndex:13},{value:"示例",paraId:73,tocIndex:13},{value:"中，我们使用下划线：",paraId:72,tocIndex:13},{value:"const decoratedText = new Text({\n    style: {\n        fontFamily: 'sans-serif',\n        fontSize: 22,\n        fill: '#1890FF',\n        text: 'abcdefghijklmnopqrstuvwxyz这是测试文本',\n        wordWrap: true,\n        wordWrapWidth: 100,\n        decorationLine: 'underline',\n        decorationColor: 'red',\n        decorationStyle: 'wavy',\n        decorationThickness: 1.5,\n    },\n});\n",paraId:74,tocIndex:13},{value:"支持以下属性：",paraId:75,tocIndex:13},{value:"decorationLine，对应 CSS ",paraId:76,tocIndex:13},{value:"text-decoration-line",paraId:76,tocIndex:13},{value:" 属性。支持 ",paraId:76,tocIndex:13},{value:"'none'",paraId:76,tocIndex:13},{value:" ",paraId:76,tocIndex:13},{value:"'underline'",paraId:76,tocIndex:13},{value:" ",paraId:76,tocIndex:13},{value:"'overline'",paraId:76,tocIndex:13},{value:" ",paraId:76,tocIndex:13},{value:"'line-through'",paraId:76,tocIndex:13},{value:"decorationColor，对应 CSS ",paraId:76,tocIndex:13},{value:"text-decoration-color",paraId:76,tocIndex:13},{value:" 属性",paraId:76,tocIndex:13},{value:"decorationThickness，对应 CSS ",paraId:76,tocIndex:13},{value:"text-decoration-thickness",paraId:76,tocIndex:13},{value:" 属性，目前仅支持 ",paraId:76,tocIndex:13},{value:"number",paraId:76,tocIndex:13},{value:" 类型",paraId:76,tocIndex:13},{value:"decorationStyle，对应 CSS ",paraId:76,tocIndex:13},{value:"text-decoration-style",paraId:76,tocIndex:13},{value:" 属性。支持 ",paraId:76,tocIndex:13},{value:"'solid'",paraId:76,tocIndex:13},{value:" ",paraId:76,tocIndex:13},{value:"'double'",paraId:76,tocIndex:13},{value:" ",paraId:76,tocIndex:13},{value:"'dotted'",paraId:76,tocIndex:13},{value:" ",paraId:76,tocIndex:13},{value:"'dashed'",paraId:76,tocIndex:13},{value:" ",paraId:76,tocIndex:13},{value:"'wavy'",paraId:76,tocIndex:13},{value:"在该",paraId:77,tocIndex:14},{value:"示例",paraId:78,tocIndex:14},{value:"中，使用 ",paraId:77,tocIndex:14},{value:"maxLines",paraId:77,tocIndex:14},{value:" 和 ",paraId:77,tocIndex:14},{value:"ellipsis",paraId:77,tocIndex:14},{value:" 可以实现超出后截断并添加省略号的效果：",paraId:77,tocIndex:14},{value:"const text = new Text({\n    style: {\n        fontFamily: 'Roboto',\n        fontSize: 22,\n        fill: '#1890FF',\n        text: 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz',\n        wordWrap: true,\n        wordWrapWidth: 100,\n        maxLines: 3,\n        ellipsis: '...',\n    },\n});\n",paraId:79,tocIndex:14},{value:"需要注意的是使用某些字体（例如 Noto）会出现下面奇怪的效果：",paraId:80,tocIndex:14},{value:"原因是 Skia 会在省略号之后添加一个空白字符，而某些字体文件中缺失该字符就会展示 “tofu”，解决方案如下：",paraId:81,tocIndex:14},{value:"https://github.com/flutter/flutter/issues/76473",paraId:82,tocIndex:14},{value:"https://github.com/flutter/flutter/issues/90135#issuecomment-984916656",paraId:82,tocIndex:14},{value:"使用 ",paraId:83,tocIndex:15},{value:"direction",paraId:83,tocIndex:15},{value:" 可以指定文本方向从左向右或者从右向左，支持 ",paraId:83,tocIndex:15},{value:"'ltr'",paraId:83,tocIndex:15},{value:" 和 ",paraId:83,tocIndex:15},{value:"'rtl'",paraId:83,tocIndex:15},{value:"，默认为 ",paraId:83,tocIndex:15},{value:"'ltr'",paraId:83,tocIndex:15},{value:"。下图为 ",paraId:83,tocIndex:15},{value:"'rtl'",paraId:83,tocIndex:15},{value:" 的效果：",paraId:83,tocIndex:15},{value:"使用 ",paraId:84,tocIndex:16},{value:"foregroundColor",paraId:84,tocIndex:16},{value:" 和 ",paraId:84,tocIndex:16},{value:"backgroundColor",paraId:84,tocIndex:16},{value:" 可以指定文本的前景和背景色：",paraId:84,tocIndex:16},{value:"在 CSS 中可以使用 ",paraId:85,tocIndex:17},{value:"text-shadow",paraId:85,tocIndex:17},{value:" 属性为文本添加多个阴影。",paraId:85,tocIndex:17},{value:"我们支持通过 ",paraId:86,tocIndex:17},{value:"shadows",paraId:86,tocIndex:17},{value:" 属性指定一组阴影，其中每一个阴影支持如下配置：",paraId:86,tocIndex:17},{value:"color 阴影颜色",paraId:87,tocIndex:17},{value:"blurRadius 默认为 0。值越大，模糊半径越大，阴影也就越淡",paraId:87,tocIndex:17},{value:"offset 指定阴影相对文字的偏移量",paraId:87,tocIndex:17},{value:"在该",paraId:88,tocIndex:17},{value:"示例",paraId:89,tocIndex:17},{value:"中，我们指定了两个阴影：",paraId:88,tocIndex:17},{value:"const shadowedText = new Text({\n    style: {\n        shadows: [\n            {\n                color: 'black',\n                blurRadius: 15,\n            },\n            {\n                color: 'red',\n                blurRadius: 5,\n                offset: [10, 10],\n            },\n        ],\n    },\n});\n",paraId:90,tocIndex:17},{value:"Strut（意为“支柱”）可以设置相对于 baseline 的最小行高。类似 CSS 中的 ",paraId:91,tocIndex:18},{value:"line-height",paraId:91,tocIndex:18},{value:" 属性。",paraId:91,tocIndex:18},{value:"在 SkParagraph 中可以通过 StrutStyle 进行配置，Flutter 中也有同名文档：",paraId:92,tocIndex:18},{value:"https://api.flutter.dev/flutter/painting/StrutStyle-class.html",paraId:92,tocIndex:18},{value:"我们会透传以下属性：",paraId:93,tocIndex:18},{value:"strutEnabled 是否启用",paraId:94,tocIndex:18},{value:"fontFamilies 字体，可以与 TextStyle 保持一致",paraId:94,tocIndex:18},{value:"fontSize 字号",paraId:94,tocIndex:18},{value:"heightMultiplier 行高高度系数",paraId:94,tocIndex:18},{value:"leading 行与行之间的空隙",paraId:94,tocIndex:18},{value:"halfLeading",paraId:94,tocIndex:18},{value:"forceStrutHeight",paraId:94,tocIndex:18},{value:"在该",paraId:95,tocIndex:18},{value:"示例",paraId:96,tocIndex:18},{value:"中我们以此控制行高和行间距：",paraId:95,tocIndex:18},{value:"decoratedText.style.strutStyle = {\n    strutEnabled: false,\n    fontFamilies: ['sans-serif'],\n    fontSize: 22,\n    heightMultiplier: 1,\n    leading: 0,\n    halfLeading: false,\n    forceStrutHeight: false,\n};\n",paraId:97,tocIndex:18},{value:"可参考 CSS 中的 ",paraId:98,tocIndex:19},{value:"font-feature-settings",paraId:98,tocIndex:19},{value:" 属性，控制 OpenType 字体中的高级印刷功能。",paraId:98,tocIndex:19},{value:"我们提供 ",paraId:99,tocIndex:19},{value:"fontFeatures",paraId:99,tocIndex:19},{value:" 属性控制，它接受一个特性数组。在该",paraId:99,tocIndex:19},{value:"示例",paraId:100,tocIndex:19},{value:"中，我们使用 Roboto 字体并开启了 small-cap 特性（注意首字母 D）：",paraId:99,tocIndex:19},{value:"const fontFeaturesText = new Text({\n    style: {\n        fontFamily: 'Roboto',\n        fontSize: 22,\n        fill: '#1890FF',\n        text: 'Difficult waffles 0O 3.14',\n        fontFeatures: [\n            {\n                name: 'smcp',\n                value: 1,\n            },\n            {\n                name: 'zero',\n                value: 1,\n            },\n        ],\n    },\n});\n",paraId:101,tocIndex:19},{value:"Skia 本身是不包含 Harfbuzz 的： ",paraId:102,tocIndex:20},{value:"https://skia.org/user/tips/",paraId:102,tocIndex:20},{value:"但 CanvasKit 默认会将它打包进来：",paraId:103,tocIndex:20},{value:"https://skia.googlesource.com/skia/+/main/modules/canvaskit/CHANGELOG.md#0_4_0_2019_02_25",paraId:104,tocIndex:20},{value:"https://skia.googlesource.com/skia.git/+/4bd08c52c07d1f2ae313a54b45e5937b80fe2fa1",paraId:105,tocIndex:20},{value:"Text shaping with ShapedText object and SkCanvas.drawText. At compile time, one can choose between using Harfbuzz/ICU (default) or a primitive one (“primitive_shaper”) which just does line breaking. Using Harfbuzz/ICU substantially increases code size (4.3 MB to 6.4 MB).",paraId:106,tocIndex:20},{value:"CanvasKit 通过 ",paraId:107,tocIndex:21},{value:"WebGL2RenderingContext",paraId:107,tocIndex:21},{value:" 进行绘制，在每一帧都会进行全量重绘。",paraId:107,tocIndex:21}]},18860:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(38564);const d=[{value:"在",paraId:0},{value:"渲染器简介",paraId:1},{value:"中，我们了解到渲染器由一个渲染上下文和一组插件组成，通过插件可以在运行时动态扩展渲染器的能力。",paraId:0},{value:"当已有的渲染器不能满足当前渲染环境时，可以按照以下步骤完成自定义：",paraId:2},{value:"继承 ",paraId:3},{value:"AbstractRenderer",paraId:3},{value:" 实现一个 ",paraId:3},{value:"Renderer",paraId:3},{value:"，可以选取已有的插件进行注册",paraId:3},{value:"实现一个自定义上下文注册插件",paraId:3},{value:"自定义渲染环境上下文服务",paraId:3},{value:"下面我们将以 ",paraId:4},{value:"g-canvas",paraId:5},{value:" 为例，展示如何完成以上步骤。",paraId:4},{value:"继承了 ",paraId:6,tocIndex:0},{value:"AbstractRenderer",paraId:6,tocIndex:0},{value:" 之后，在构造函数中可以选取一系列已有的插件，使用 ",paraId:6,tocIndex:0},{value:"registerPlugin()",paraId:7,tocIndex:0},{value:" 进行注册，例如使用 Canvas2D API 定义路径的 ",paraId:6,tocIndex:0},{value:"g-plugin-canvas-path-generator",paraId:8,tocIndex:0},{value:"，使用 Canvas2D API 进行拾取的 ",paraId:6,tocIndex:0},{value:"g-plugin-canvas-picker",paraId:9,tocIndex:0},{value:"。",paraId:6,tocIndex:0},{value:"https://github.com/antvis/G/blob/next/packages/g-svg/src/index.ts",paraId:10,tocIndex:0},{value:"import type { RendererConfig } from '@antv/g';\nimport { AbstractRenderer } from '@antv/g';\nimport * as CanvasPathGenerator from '@antv/g-plugin-canvas-path-generator';\nimport * as CanvasPicker from '@antv/g-plugin-canvas-picker';\nimport * as CanvasRenderer from '@antv/g-plugin-canvas-renderer';\nimport * as DomInteraction from '@antv/g-plugin-dom-interaction';\nimport * as HTMLRenderer from '@antv/g-plugin-html-renderer';\nimport * as ImageLoader from '@antv/g-plugin-image-loader';\nimport { ContextRegisterPlugin } from './ContextRegisterPlugin';\n\nexport class Renderer extends AbstractRenderer {\n  constructor(config?: Partial<RendererConfig>) {\n    super(config);\n\n    // register Canvas2DContext\n    this.registerPlugin(new ContextRegisterPlugin());\n\n    // register other built-in plugins\n    this.registerPlugin(new ImageLoader.Plugin());\n    this.registerPlugin(new CanvasPathGenerator.Plugin());\n    this.registerPlugin(new CanvasRenderer.Plugin());\n    this.registerPlugin(new DomInteraction.Plugin());\n    this.registerPlugin(new CanvasPicker.Plugin());\n    this.registerPlugin(new HTMLRenderer.Plugin());\n  }\n}\n",paraId:11,tocIndex:0},{value:"除了这些现成的内置插件，我们需要额外开发一个。",paraId:12,tocIndex:0},{value:"关于如何实现一个插件可以参考 ",paraId:13,tocIndex:1},{value:"插件基本结构",paraId:14,tocIndex:1},{value:"，该插件只做一件事，那就是注册渲染上下文服务。",paraId:13,tocIndex:1},{value:"import { AbstractRendererPlugin, Module } from '@antv/g';\nimport { Canvas2DContextService } from './Canvas2DContextService';\n\nconst containerModule = Module((register) => {\n  /**\n   * implements ContextService\n   */\n  register(Canvas2DContextService);\n});\n\nexport class ContextRegisterPlugin extends AbstractRendererPlugin {\n  name = 'canvas-context-register';\n  init(): void {\n    this.container.load(containerModule, true);\n  }\n  destroy(): void {\n    this.container.unload(containerModule);\n  }\n}\n",paraId:15,tocIndex:1},{value:"渲染上下文服务向上屏蔽了底层渲染 API 的细节，这样在使用该服务时不会感知到 Canvas2D、SVG 或者 WebGL。",paraId:16,tocIndex:1},{value:"一个渲染上下文服务需要通过 ",paraId:17,tocIndex:2},{value:"ContextService",paraId:17,tocIndex:2},{value:" token 注册，并实现 ",paraId:17,tocIndex:2},{value:"ContextService",paraId:17,tocIndex:2},{value:" 接口：",paraId:17,tocIndex:2},{value:"import { ContextService, inject, singleton } from '@antv/g';\n\n@singleton({ token: ContextService })\nexport class Canvas2DContextService\n  implements ContextService<CanvasRenderingContext2D> {}\n",paraId:18,tocIndex:2},{value:"ContextService",paraId:19,tocIndex:2},{value:" 接口定义如下：",paraId:19,tocIndex:2},{value:"export interface ContextService<Context> {\n  init: () => Promise<void>;\n  destroy: () => void;\n  getContext: () => Context | null;\n  getDomElement: () => CanvasLike | null;\n  getDPR: () => number;\n  getBoundingClientRect: () => DOMRect | undefined;\n  resize: (width: number, height: number) => void;\n  applyCursorStyle: (cursor: string) => void;\n  toDataURL: (options: Partial<DataURLOptions>) => Promise<string>;\n}\n",paraId:20,tocIndex:2},{value:"下面我们详细介绍每一个方法的含义。",paraId:21,tocIndex:2},{value:"不同的底层渲染 API 有不同的初始化方式，例如 Canvas2D / WebGL / WebGPU 虽然都可以通过 DOM API 从 ",paraId:22,tocIndex:3},{value:"<canvas>",paraId:22,tocIndex:3},{value:" 元素中获取上下文，但 WebGPU 为异步方式，因此我们将该方法设计成异步：",paraId:22,tocIndex:3},{value:"@inject(CanvasConfig)\nprivate canvasConfig: CanvasConfig;\n\nasync init() {\n  const { container, canvas, devicePixelRatio } = this.canvasConfig;\n  this.context = this.$canvas.getContext('2d');\n}\n",paraId:23,tocIndex:3},{value:"在该方法中，我们可以通过注入的方式获取用户创建 ",paraId:24,tocIndex:3},{value:"Canvas",paraId:25,tocIndex:3},{value:" 时传入的参数，例如 ",paraId:24,tocIndex:3},{value:"devicePixelRatio",paraId:26,tocIndex:3},{value:"。",paraId:24,tocIndex:3},{value:"关于调用时机，除了首次初始化画布时会调用，在后续运行时切换渲染器时也会调用。",paraId:27,tocIndex:3},{value:"在该方法中，我们可以做一些上下文销毁工作。",paraId:28,tocIndex:4},{value:"关于调用时机，除了首次初始化画布时会调用，在后续运行时切换渲染器时也会调用，其中旧的渲染器上下文会先销毁。",paraId:29,tocIndex:4},{value:"在运行过程中，有时初始化的",paraId:30,tocIndex:5},{value:"画布尺寸",paraId:31,tocIndex:5},{value:"会发生改变，此时 ",paraId:30,tocIndex:5},{value:"canvas.resize()",paraId:30,tocIndex:5},{value:" 最终会调用到该方法。",paraId:30,tocIndex:5},{value:"返回自定义渲染上下文，不同的渲染器返回不同的对象，例如：",paraId:32,tocIndex:6},{value:"g-canvas",paraId:33,tocIndex:6},{value:" 返回 ",paraId:34,tocIndex:6},{value:"CanvasRenderingContext2D",paraId:34,tocIndex:6},{value:"g-svg",paraId:35,tocIndex:6},{value:" 返回 ",paraId:34,tocIndex:6},{value:"SVGElement",paraId:34,tocIndex:6},{value:"g-webgl",paraId:36,tocIndex:6},{value:" 返回一个复杂对象 ",paraId:34,tocIndex:6},{value:"WebGLRenderingContext",paraId:34,tocIndex:6},{value:"interface WebGLRenderingContext {\n  engine: RenderingEngine;\n  camera: Camera;\n  view: IView;\n}\n",paraId:37,tocIndex:6},{value:"返回上下文所属的 DOM 元素。例如 ",paraId:38,tocIndex:7},{value:"g-canvas/webgl",paraId:38,tocIndex:7},{value:" 会返回 ",paraId:38,tocIndex:7},{value:"<canvas>",paraId:38,tocIndex:7},{value:"，而 ",paraId:38,tocIndex:7},{value:"g-svg",paraId:38,tocIndex:7},{value:" 会返回 ",paraId:38,tocIndex:7},{value:"<svg>",paraId:38,tocIndex:7},{value:"。",paraId:38,tocIndex:7},{value:"返回 devicePixelRatio。",paraId:39,tocIndex:8},{value:"在大部分渲染环境中都可以通过 DOM API 同名方法获取。",paraId:40,tocIndex:9},{value:"设置鼠标样式。在大部分渲染环境中都可以通过 DOM API 设置。",paraId:41,tocIndex:10},{value:"在实现",paraId:42,tocIndex:11},{value:"导出图片",paraId:43,tocIndex:11},{value:"这样的需求时，需要依靠渲染上下文的能力。",paraId:42,tocIndex:11},{value:"不同的渲染环境实现起来难度自然也不同，例如 ",paraId:44,tocIndex:11},{value:"g-canvas",paraId:45,tocIndex:11},{value:" 中可以使用原生 ",paraId:44,tocIndex:11},{value:"toDataURL",paraId:44,tocIndex:11},{value:" 方法",paraId:44,tocIndex:11},{value:"https://github.com/antvis/G/blob/next/packages/g-svg/src/Canvas2DContextService.ts#L107-L110",paraId:46,tocIndex:11},{value:"async toDataURL(options: Partial<DataURLOptions> = {}) {\n  const { type, encoderOptions } = options;\n  return (this.context.canvas as HTMLCanvasElement).toDataURL(type, encoderOptions);\n}\n",paraId:47,tocIndex:11},{value:"但 ",paraId:48,tocIndex:11},{value:"g-svg",paraId:49,tocIndex:11},{value:" 实现起来就要麻烦很多，需要借助 ",paraId:48,tocIndex:11},{value:"XMLSerializer",paraId:48,tocIndex:11},{value:" 的序列化能力：",paraId:48,tocIndex:11},{value:"https://github.com/antvis/G/blob/next/packages/g-svg/src/SVGContextService.ts#L74-L90",paraId:50,tocIndex:11},{value:"async toDataURL(options: Partial<DataURLOptions> = {}) {\n  const cloneNode = this.$namespace.cloneNode(true);\n  const svgDocType = document.implementation.createDocumentType(\n    'svg',\n    '-//W3C//DTD SVG 1.1//EN',\n    'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd',\n  );\n  const svgDoc = document.implementation.createDocument(\n    'http://www.w3.org/2000/svg',\n    'svg',\n    svgDocType,\n  );\n  svgDoc.replaceChild(cloneNode, svgDoc.documentElement);\n  return `data:image/svg+xml;charset=utf8,${encodeURIComponent(\n    new XMLSerializer().serializeToString(svgDoc),\n  )}`;\n}\n",paraId:51,tocIndex:11},{value:"在 ",paraId:52,tocIndex:11},{value:"g-webgl",paraId:53,tocIndex:11},{value:" 中情况就更复杂了，甚至需要使用异步方式。",paraId:52,tocIndex:11},{value:"https://github.com/antvis/G/blob/next/packages/g-plugin-device-renderer/src/RenderGraphPlugin.ts#L428-L438",paraId:54,tocIndex:11}]},77979:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(15297);const d=[{value:"渲染器使用底层渲染 API 绘制各类图形，目前我们提供了以下渲染器，分别是：",paraId:0},{value:"基于 Canvas2D 的 ",paraId:1},{value:"g-canvas",paraId:2},{value:"基于 Canvaskit / Skia 的 ",paraId:1},{value:"g-canvaskit",paraId:3},{value:"基于 SVG 的 ",paraId:1},{value:"g-svg",paraId:4},{value:"基于 WebGL 2/1 的 ",paraId:1},{value:"g-webgl",paraId:5},{value:"基于 WebGPU 的 ",paraId:1},{value:"g-webgpu",paraId:6},{value:"渲染器由一个渲染上下文和一组",paraId:7},{value:"插件",paraId:8},{value:"组成，通过插件可以在运行时动态扩展渲染器的能力。",paraId:7},{value:"以 ",paraId:9},{value:"g-canvas",paraId:9},{value:" 渲染器为例，基础使用方式如下：",paraId:9},{value:"import { Canvas } from '@antv/g';\nimport { Renderer } from '@antv/g-canvas';\n\nconst canvasRenderer = new Renderer();\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer: canvasRenderer,\n});\n",paraId:10},{value:"在创建渲染器时，可以传入一系列初始化配置影响实际渲染行为。",paraId:11,tocIndex:0},{value:"是否开启自动渲染，默认开启。所谓“自动渲染”是指无需手动调用画布的渲染方法，只需将图形添加到画布中，这也和浏览器行为一致。",paraId:12,tocIndex:1},{value:"有些场景需要手动控制渲染时机时可关闭：",paraId:13,tocIndex:1},{value:"const webglRenderer = new WebGLRenderer({\n    // 关闭自动渲染\n    enableAutoRendering: false,\n});\n",paraId:14,tocIndex:1},{value:"是否开启脏检查，默认开启。开启后只有图形发生变化才会触发画布重绘。",paraId:15,tocIndex:2},{value:"是否开启视锥剔除，默认关闭。开启后只有视口范围内的图形才会被绘制。",paraId:16,tocIndex:3},{value:"通过 ",paraId:17,tocIndex:4},{value:"setConfig",paraId:17,tocIndex:4},{value:" 可以修改初始化配置，例如再次开启自动渲染：",paraId:17,tocIndex:4},{value:"renderer.setConfig({ enableAutoRendering: true });\n",paraId:18,tocIndex:4},{value:"我们提供了一系列操作插件的方法。",paraId:19,tocIndex:5},{value:"渲染器可以在运行时动态添加插件，扩展自身能力，例如 ",paraId:20,tocIndex:6},{value:"g-webgl",paraId:20,tocIndex:6},{value:" 可以通过 ",paraId:20,tocIndex:6},{value:"g-pluin-3d",paraId:21,tocIndex:6},{value:" 进行 3D 场景的渲染：",paraId:20,tocIndex:6},{value:"import { Plugin } from '@antv/g-plugin-3d';\n// 注册 3D 插件\nwebglRenderer.registerPlugin(new Plugin());\n",paraId:22,tocIndex:6},{value:"移除插件：",paraId:23,tocIndex:7},{value:"renderer.unregisterPlugin(plugin);\n",paraId:24,tocIndex:7},{value:"根据名称获取插件。每个插件都有自己的名称，我们约定 ",paraId:25,tocIndex:8},{value:"g-plugin-name",paraId:25,tocIndex:8},{value:" 的名称为 ",paraId:25,tocIndex:8},{value:"name",paraId:25,tocIndex:8},{value:"：",paraId:25,tocIndex:8},{value:"import { Plugin } from '@antv/g-plugin-testonly';\n\nconst plugin = new Plugin();\nplugin.name; // 'testonly'\n",paraId:26,tocIndex:8},{value:"因此在渲染器中可以通过插件名获取：",paraId:27,tocIndex:8},{value:"renderer.register(plugin);\n\nrenderer.getPlugin('testonly'); // plugin\n",paraId:28,tocIndex:8},{value:"返回当前渲染器的插件列表：",paraId:29,tocIndex:9},{value:"renderer.getPlugins(); // [Plugin1, Plugin2]\n",paraId:30,tocIndex:9}]},22744:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(66160);const d=[{value:"使用 ",paraId:0},{value:"SVG",paraId:0},{value:" 绘制 2D 图形。会在容器中创建一个 ",paraId:0},{value:"<svg>",paraId:0},{value:" 元素。",paraId:0},{value:"SVG 在文本渲染上直接依赖浏览器的能力，因而有独特的优势。另外通过 ",paraId:1},{value:"<foreignObject>",paraId:1},{value:" 也可以嵌入 HTML 片段。",paraId:1},{value:"和 ",paraId:2,tocIndex:0},{value:"@antv/g",paraId:2,tocIndex:0},{value:" 一样，也有以下两种使用方式。",paraId:2,tocIndex:0},{value:"安装 ",paraId:3,tocIndex:1},{value:"@antv/g-svg",paraId:3,tocIndex:1},{value:" 后可以从中获取渲染器：",paraId:3,tocIndex:1},{value:"import { Canvas } from '@antv/g';\nimport { Renderer } from '@antv/g-svg';\n\nconst svgRenderer = new Renderer();\n\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer: svgRenderer,\n});\n",paraId:4,tocIndex:1},{value:'<script\n  src="https://unpkg.com/@antv/g-svg/dist/index.umd.min.js"\n  type="application/javascript">\n',paraId:5,tocIndex:2},{value:"从 ",paraId:6,tocIndex:2},{value:"G.SVG",paraId:6,tocIndex:2},{value:" 命名空间下可以获取渲染器：",paraId:6,tocIndex:2},{value:"const svgRenderer = new window.G.SVG.Renderer();\n",paraId:7,tocIndex:2},{value:"在创建渲染器时，可以传入一些初始化配置项，例如：",paraId:8,tocIndex:3},{value:"import { Renderer } from '@antv/g-svg';\nconst renderer = new Renderer({\n    outputSVGElementId: false,\n});\n",paraId:9,tocIndex:3},{value:"该渲染器在生成 SVGElement 时会添加 ",paraId:10,tocIndex:4},{value:"id",paraId:10,tocIndex:4},{value:" 属性，用于交互时拾取判定反查元素。但在服务端渲染这样的场景下，不存在交互也就无需生成，此时可通过该配置项关闭。",paraId:10,tocIndex:4},{value:'\x3c!-- 默认开启 --\x3e\n<g id="g_svg_g_450" fill="none"></g>\n\n\x3c!--关闭后 --\x3e\n<g fill="none"></g>\n',paraId:11,tocIndex:4},{value:"该渲染器内置了以下插件：",paraId:12,tocIndex:5},{value:"g-plugin-svg-renderer",paraId:13,tocIndex:5},{value:" 使用 SVG 元素绘制图形，例如 ",paraId:14,tocIndex:5},{value:"<circle>",paraId:14,tocIndex:5},{value:" ",paraId:14,tocIndex:5},{value:"<rect>",paraId:14,tocIndex:5},{value:" 等",paraId:14,tocIndex:5},{value:"g-plugin-svg-picker",paraId:15,tocIndex:5},{value:" 基于 ",paraId:14,tocIndex:5},{value:"elementFromPoint",paraId:14,tocIndex:5},{value:" DOM API 拾取图形",paraId:14,tocIndex:5},{value:"g-plugin-dom-interaction",paraId:16,tocIndex:5},{value:" 基于 DOM API 绑定事件",paraId:14,tocIndex:5},{value:"除了内置插件，还有以下可选插件。",paraId:17,tocIndex:6},{value:"使用 ",paraId:18,tocIndex:7},{value:"rough.js",paraId:18,tocIndex:7},{value:" 的 SVG 版本进行手绘风格的渲染。",paraId:18,tocIndex:7},{value:"我们提供了 ",paraId:19,tocIndex:7},{value:"g-plugin-rough-svg-renderer",paraId:20,tocIndex:7},{value:" 插件，注册后会替换掉 ",paraId:19,tocIndex:7},{value:"g-plugin-svg-renderer",paraId:21,tocIndex:7},{value:" 对于部分 2D 图形的渲染能力。",paraId:19,tocIndex:7},{value:"示例",paraId:22,tocIndex:7},{value:"效果如下：",paraId:23,tocIndex:7},{value:"该渲染器依赖 SVG DOM API 的渲染能力，并不局限在浏览器端，因此也可以使用 ",paraId:24,tocIndex:8},{value:"JSDOM",paraId:24,tocIndex:8},{value:" 进行服务端渲染。",paraId:24,tocIndex:8},{value:"在我们的",paraId:25,tocIndex:8},{value:"集成测试",paraId:25,tocIndex:8},{value:"中，会在 Node 端配合 ",paraId:25,tocIndex:8},{value:"JSDOM",paraId:25,tocIndex:8},{value:" 与 ",paraId:25,tocIndex:8},{value:"node-canvas",paraId:25,tocIndex:8},{value:" 渲染结果图片，与基准图片进行比对。其他服务端渲染场景也可以按照以下步骤进行：",paraId:25,tocIndex:8},{value:"使用 ",paraId:26,tocIndex:8},{value:"unregisterPlugin",paraId:27,tocIndex:8},{value:" 卸载掉 ",paraId:26,tocIndex:8},{value:"g-svg",paraId:28,tocIndex:8},{value:" 中内置的与 DOM API 相关的插件，例如负责事件绑定的 ",paraId:26,tocIndex:8},{value:"g-plugin-dom-interaction",paraId:29,tocIndex:8},{value:"使用 JSDOM 创建一个画布容器",paraId:26,tocIndex:8},{value:"使用上一步的容器创建画布，同时传入 JSDOM 创建的 ",paraId:26,tocIndex:8},{value:"document",paraId:26,tocIndex:8},{value:"，代替浏览器环境中的 ",paraId:26,tocIndex:8},{value:"window.document",paraId:26,tocIndex:8},{value:"，",paraId:26,tocIndex:8},{value:"raf",paraId:26,tocIndex:8},{value:" 同理。",paraId:26,tocIndex:8},{value:"正常使用 ",paraId:26,tocIndex:8},{value:"g-svg",paraId:30,tocIndex:8},{value:" 渲染器，通过 G 的 API 创建场景",paraId:26,tocIndex:8},{value:"使用 ",paraId:26,tocIndex:8},{value:"xmlserializer",paraId:26,tocIndex:8},{value:" 将 JSDOM 序列化成字符串，保存成 SVG 图片",paraId:26,tocIndex:8},{value:"https://github.com/antvis/g/blob/next/integration/__node__tests__/svg/circle.spec.js",paraId:31,tocIndex:8},{value:"const fs = require('fs');\nconst { JSDOM } = require('jsdom');\nconst xmlserializer = require('xmlserializer');\nconst { Circle, Canvas } = require('@antv/g');\nconst { Renderer } = require('@antv/g-svg');\n\n// create a renderer, unregister plugin relative to DOM\nconst renderer = new Renderer();\nconst domInteractionPlugin = renderer.getPlugin('dom-interaction');\nrenderer.unregisterPlugin(domInteractionPlugin);\n\n// create JSDOM\nconst dom = new JSDOM(`\n<div id=\"container\">\n</div>\n`);\n\nconst SIZE = 200;\nconst canvas = new Canvas({\n    container: 'container',\n    width: SIZE,\n    height: SIZE,\n    renderer,\n    document: dom.window.document, // use document created by JSDOM\n    requestAnimationFrame: dom.window.requestAnimationFrame,\n    cancelAnimationFrame: dom.window.cancelAnimationFrame,\n});\n\n// use G API constructing scene graph\nconst circle1 = new Circle({\n    style: {\n        cx: 10,\n        cy: 10,\n        r: 10,\n        fill: 'red',\n    },\n});\ncanvas.appendChild(circle1);\n\n// serialize JSDOM to SVG string\nxmlserializer.serializeToString(\n    dom.window.document.getElementById('container').children[0],\n);\n",paraId:32,tocIndex:8}]},35827:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(72032);const d=[{value:"使用 ",paraId:0},{value:"WebGLRenderingContext",paraId:0},{value:" 或者 ",paraId:0},{value:"WebGL2RenderingContext",paraId:0},{value:" 渲染。相比 ",paraId:0},{value:"Canvas 渲染器",paraId:1},{value:"和 ",paraId:0},{value:"SVG 渲染器",paraId:2},{value:" 拥有更强大的渲染能力，在大规模数量图形以及 3D 场景下有明显的优势。",paraId:0},{value:"和 ",paraId:3,tocIndex:0},{value:"@antv/g",paraId:3,tocIndex:0},{value:" 一样，也有以下两种使用方式。",paraId:3,tocIndex:0},{value:"安装 ",paraId:4,tocIndex:1},{value:"@antv/g-webgl",paraId:4,tocIndex:1},{value:" 后可以从中获取渲染器：",paraId:4,tocIndex:1},{value:"import { Canvas } from '@antv/g';\nimport { Renderer } from '@antv/g-webgl';\n\nconst webglRenderer = new Renderer();\n\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer: webglRenderer,\n});\n",paraId:5,tocIndex:1},{value:'<script\n  src="https://unpkg.com/@antv/g-webgl/dist/index.umd.min.js"\n  type="application/javascript">\n',paraId:6,tocIndex:2},{value:"从 ",paraId:7,tocIndex:2},{value:"G.WebGL",paraId:7,tocIndex:2},{value:" 命名空间下可以获取渲染器：",paraId:7,tocIndex:2},{value:"const webglRenderer = new window.G.WebGL.Renderer();\n",paraId:8,tocIndex:2},{value:"选择渲染环境。默认值为 ",paraId:9,tocIndex:4},{value:"['webgl2', 'webgl1']",paraId:9,tocIndex:4},{value:" 并自动按该优先级自动降级。",paraId:9,tocIndex:4},{value:"例如在某些特殊环境下，仅选择在 WebGL1 环境下运行：",paraId:10,tocIndex:4},{value:"const webglRenderer = new WebGLRenderer({\n    targets: ['webgl1'],\n});\n",paraId:11,tocIndex:4},{value:"如果浏览器检测到与 ",paraId:12,tocIndex:5},{value:"WebGLRenderingContext",paraId:12,tocIndex:5},{value:" 对象关联的图形缓冲区已丢失，则会触发 WebGL API 中的 ",paraId:12,tocIndex:5},{value:"webglcontextlost",paraId:12,tocIndex:5},{value:" 事件，此时 ",paraId:12,tocIndex:5},{value:"onContextLost",paraId:12,tocIndex:5},{value:" 回调函数会被触发：",paraId:12,tocIndex:5},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/webglcontextlost_event",paraId:13,tocIndex:5},{value:"const webglRenderer = new WebGLRenderer({\n    onContextLost: (e: Event) => {},\n});\n",paraId:14,tocIndex:5},{value:"当 ",paraId:15,tocIndex:6},{value:"WebGLRenderingContext",paraId:15,tocIndex:6},{value:" 恢复时，会触发 ",paraId:15,tocIndex:6},{value:"webglcontextrestored",paraId:15,tocIndex:6},{value:" 事件，此时 ",paraId:15,tocIndex:6},{value:"onContextRestored",paraId:15,tocIndex:6},{value:" 回调函数会被触发：",paraId:15,tocIndex:6},{value:"https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/webglcontextrestored_event",paraId:16,tocIndex:6},{value:"const webglRenderer = new WebGLRenderer({\n    onContextRestored: (e: Event) => {},\n});\n",paraId:17,tocIndex:6},{value:"当 ",paraId:18,tocIndex:7},{value:"WebGLRenderingContext",paraId:18,tocIndex:7},{value:" 创建失败时，会触发 ",paraId:18,tocIndex:7},{value:"webglcontextcreationerror",paraId:18,tocIndex:7},{value:" 事件，此时 ",paraId:18,tocIndex:7},{value:"onContextCreationError",paraId:18,tocIndex:7},{value:" 回调函数会被触发：",paraId:18,tocIndex:7},{value:"https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/webglcontextcreationerror_event",paraId:19,tocIndex:7},{value:"const webglRenderer = new WebGLRenderer({\n    onContextCreationError: (e: Event) => {},\n});\n",paraId:20,tocIndex:7},{value:"该渲染器内置了以下插件：",paraId:21,tocIndex:8},{value:"g-plugin-device-renderer",paraId:22,tocIndex:8},{value:" 基于 GPUDevice 提供渲染能力",paraId:23,tocIndex:8},{value:"g-plugin-webgl-device",paraId:24,tocIndex:8},{value:" 基于 ",paraId:23,tocIndex:8},{value:"WebGLRenderingContext",paraId:23,tocIndex:8},{value:" 和 ",paraId:23,tocIndex:8},{value:"WebGL2RenderingContext",paraId:23,tocIndex:8},{value:" 实现 GPUDevice 能力",paraId:23,tocIndex:8},{value:"g-plugin-dom-interaction",paraId:25,tocIndex:8},{value:" 基于 DOM API 绑定事件",paraId:23,tocIndex:8},{value:"除了内置插件，还可以选择以下插件。",paraId:26,tocIndex:9},{value:"g-plugin-3d",paraId:27,tocIndex:10},{value:" 提供 3D 渲染能力，包括 ",paraId:28,tocIndex:10},{value:"Mesh",paraId:29,tocIndex:10},{value:" ",paraId:28,tocIndex:10},{value:"Material",paraId:30,tocIndex:10},{value:" ",paraId:28,tocIndex:10},{value:"Geometry",paraId:31,tocIndex:10},{value:" 等常见对象。",paraId:28,tocIndex:10},{value:"g-plugin-control",paraId:32,tocIndex:11},{value:" 为 3D 场景提供相机交互，内部使用 Hammer.js 响应鼠标移动、滚轮事件。根据不同的 ",paraId:33,tocIndex:11},{value:"相机类型",paraId:34,tocIndex:11},{value:"，提供不同的交互效果。",paraId:33,tocIndex:11},{value:"filter",paraId:35,tocIndex:12},{value:"clipPath",paraId:35,tocIndex:12},{value:"lineDash 应用 lineJoin，例如开启 ",paraId:35,tocIndex:12},{value:"lineJoin: 'round'",paraId:35,tocIndex:12},{value:" 后每个小线段都应该有圆角效果",paraId:35,tocIndex:12}]},85561:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(35376);const d=[{value:"基于 ",paraId:0},{value:"WebGPU",paraId:0},{value:" 提供渲染和计算能力。",paraId:0},{value:"特别是利用 GPU 进行并行计算的能力，是 WebGL 所不具备的，我们提供了 ",paraId:1},{value:"g-plugin-gpgpu",paraId:2},{value:" 帮助简化这一过程。",paraId:1},{value:"以下前置条件需要满足。",paraId:3,tocIndex:0},{value:"在使用时需要判断当前环境是否支持 WebGPU，下面特性检测代码来自：",paraId:4,tocIndex:1},{value:"https://web.dev/gpu/#feature-detection",paraId:4,tocIndex:1},{value:"：",paraId:4,tocIndex:1},{value:"if ('gpu' in navigator) {\n    // WebGPU is supported! 🎉\n}\n",paraId:5,tocIndex:1},{value:"目前在 Chrome 最新版本（101）中可以通过 Open Trial 开启。",paraId:6,tocIndex:1},{value:"在运行时我们使用 ",paraId:7,tocIndex:2},{value:"wgpu naga",paraId:7,tocIndex:2},{value:" 进行 Shader 转译（GLSL 300 -> WGSL），因此需要运行环境支持 WASM。",paraId:7,tocIndex:2},{value:"和 ",paraId:8,tocIndex:3},{value:"@antv/g",paraId:8,tocIndex:3},{value:" 一样，也有以下两种使用方式。",paraId:8,tocIndex:3},{value:"安装 ",paraId:9,tocIndex:4},{value:"@antv/g-webgpu",paraId:9,tocIndex:4},{value:" 后可以从中获取渲染器：",paraId:9,tocIndex:4},{value:"import { Canvas } from '@antv/g';\nimport { Renderer } from '@antv/g-webgpu';\n\nconst webgpuRenderer = new Renderer({\n    shaderCompilerPath: '/glsl_wgsl_compiler_bg.wasm',\n});\n\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer: webgpuRenderer,\n});\n",paraId:10,tocIndex:4},{value:'<script\n  src="https://unpkg.com/@antv/g-webgpu/dist/index.umd.min.js"\n  type="application/javascript">\n',paraId:11,tocIndex:5},{value:"从 ",paraId:12,tocIndex:5},{value:"G.WebGPU",paraId:12,tocIndex:5},{value:" 命名空间下可以获取渲染器：",paraId:12,tocIndex:5},{value:"const webgpuRenderer = new window.G.WebGPU.Renderer({\n    shaderCompilerPath: '/glsl_wgsl_compiler_bg.wasm',\n});\n",paraId:13,tocIndex:5},{value:"由于我们的 Shader 使用 GLSL 300 编写，因此需要转译到 WGSL 才能在 WebGPU 中运行。这一步我们使用了 naga，编译成 WASM 后便可以在浏览器运行，因此需要在运行时加载它：",paraId:14,tocIndex:7},{value:"const webgpuRenderer = new WebGPURenderer({\n    shaderCompilerPath: '/glsl_wgsl_compiler_bg.wasm',\n});\n",paraId:15,tocIndex:7},{value:"和 WebGL 一样，WebGPU 应用在运行过程中也有可能出现上下文丢失的情况，此时会触发该回调函数。",paraId:16,tocIndex:8},{value:"https://github.com/gpuweb/gpuweb/blob/main/design/ErrorHandling.md#fatal-errors-requestadapter-requestdevice-and-devicelost",paraId:17,tocIndex:8},{value:"const webgpuRenderer = new WebGPURenderer({\n    shaderCompilerPath: '/glsl_wgsl_compiler_bg.wasm',\n    onContextLost: () => {},\n});\n",paraId:18,tocIndex:8},{value:"该渲染器内置了以下插件：",paraId:19,tocIndex:9},{value:"g-plugin-device-renderer",paraId:20,tocIndex:9},{value:" 基于 GPUDevice 提供渲染能力",paraId:21,tocIndex:9},{value:"g-plugin-webgpu-device",paraId:22,tocIndex:9},{value:" 基于 WebGPU 实现 GPUDevice 能力",paraId:21,tocIndex:9},{value:"g-plugin-dom-interaction",paraId:23,tocIndex:9},{value:" 基于 DOM API 绑定事件",paraId:21,tocIndex:9},{value:"除了内置插件，还可以选择以下插件。",paraId:24,tocIndex:10},{value:"g-plugin-gpgpu",paraId:25,tocIndex:11},{value:" 提供 GPGPU 能力。得益于 WebGPU 对于 Compute Shader 的支持度，我们可以实现很多可并行算法。",paraId:26,tocIndex:11},{value:"g-plugin-3d",paraId:27,tocIndex:12},{value:" 提供 3D 渲染能力，包括 ",paraId:28,tocIndex:12},{value:"Mesh",paraId:29,tocIndex:12},{value:" ",paraId:28,tocIndex:12},{value:"Material",paraId:30,tocIndex:12},{value:" ",paraId:28,tocIndex:12},{value:"Geometry",paraId:31,tocIndex:12},{value:" 等常见对象。",paraId:28,tocIndex:12},{value:"g-plugin-control",paraId:32,tocIndex:13},{value:" 为 3D 场景提供相机交互，内部使用 Hammer.js 响应鼠标移动、滚轮事件。根据不同的 ",paraId:33,tocIndex:13},{value:"相机类型",paraId:34,tocIndex:13},{value:"，提供不同的交互效果。",paraId:33,tocIndex:13}]},67358:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(6011);const d=[{value:"我们提供了一些",paraId:0},{value:"基础图形",paraId:1},{value:"，例如 ",paraId:0},{value:"Circle",paraId:2},{value:"、",paraId:0},{value:"Path",paraId:3},{value:" 等等。通过",paraId:0},{value:"场景图",paraId:4},{value:"能力也能构建它们之间的层次关系。但当场景层次嵌套较深又需要复用时，我们便需要一种自定义组件机制，能把这些基础图形封装成高级图形。",paraId:0},{value:"类似的问题在 Web Components 中是通过 ",paraId:5},{value:"Custom Element",paraId:5},{value:" 实现的。在",paraId:5},{value:"官方示例",paraId:5},{value:"中我们能看到一个自定义图形的注册过程按照如下步骤进行：",paraId:5},{value:"在构造函数中创建内部 DOM 结构",paraId:6},{value:"在 ",paraId:6},{value:"connectedCallback()",paraId:6},{value:" 即元素首次插入文档后，设置样式",paraId:6},{value:"在 ",paraId:6},{value:"attributeChangedCallback()",paraId:6},{value:" 中处理属性更新，重新设置样式",paraId:6},{value:"使用 ",paraId:6},{value:"customElements.define()",paraId:6},{value:" 完成自定义图形的注册",paraId:6},{value:"我们沿用了这样的设计。",paraId:7},{value:"在本文中我们将介绍自定义图形的用法，实现一个简单的箭头，其中包含以下步骤：",paraId:8},{value:"设计自定义属性",paraId:9},{value:"定义场景图",paraId:9},{value:"使用自定义图形",paraId:9},{value:"处理属性更新",paraId:9},{value:"过程中会涉及",paraId:10},{value:"场景图",paraId:11},{value:"、",paraId:10},{value:"动画系统",paraId:12},{value:"、",paraId:10},{value:"事件系统",paraId:13},{value:"等。在开始前我们推荐先阅读以上各个系统的文档。",paraId:10},{value:"完整 DEMO",paraId:14},{value:"源码",paraId:15},{value:"一个箭头由躯干部分 + 一或两个端点组成。如下图所示，躯干部分可以是 Line / Polyline / Path，而端点可以是任意基础/高级图形，我们提供的默认端点是 Path。可见箭头就是一个由若干基础图形组合而成的“高级图形”。",paraId:16,tocIndex:0},{value:"首先所有自定义图形都需要继承 CustomElement 基类：",paraId:17,tocIndex:1},{value:"import { CustomElement } from '@antv/g';\n\nexport class Arrow extends CustomElement<ArrowStyleProps> {}\n",paraId:18,tocIndex:1},{value:"然后可以定义自定义图形的属性，这里我们给箭头提供了以下自定义属性：",paraId:19,tocIndex:1},{value:"body 躯干部分只能接受 ",paraId:20,tocIndex:1},{value:"Line",paraId:21,tocIndex:1},{value:" ",paraId:20,tocIndex:1},{value:"Path",paraId:22,tocIndex:1},{value:" ",paraId:20,tocIndex:1},{value:"Polyline",paraId:23,tocIndex:1},{value:"start/endHead 端点部分可以是任何基础图形，传入布尔值时开启/关闭默认内置端点",paraId:20,tocIndex:1},{value:"stroke/lineWidth/opacity 等常规绘图属性",paraId:20,tocIndex:1},{value:"type ArrowHead = boolean | DisplayObject;\ntype ArrowBody = Line | Path | Polyline;\n\nexport interface ArrowStyleProps extends BaseStyleProps {\n    body?: ArrowBody; // 躯干\n    startHead?: ArrowHead; // 起始端点\n    endHead?: ArrowHead; // 结束端点\n    stroke?: string; // 颜色\n    lineWidth?: number; // 线宽\n    opacity?: number; // 透明度\n    strokeOpacity?: number;\n}\n",paraId:24,tocIndex:1},{value:"有了自定义属性，下一步需要通过场景图组合基础图形。",paraId:25,tocIndex:1},{value:"我们需要在构造函数中完成场景图的定义。这里会使用到基础图形的节点操作能力，例如使用 ",paraId:26,tocIndex:2},{value:"appendChild",paraId:27,tocIndex:2},{value:" 添加箭头的躯干和端点部分。",paraId:26,tocIndex:2},{value:"static tag = 'arrow';\n\nconstructor(config: DisplayObjectConfig<ArrowStyleProps>) {\n  // 调用基类构造函数\n  super({\n    ...config,\n    type: Arrow.tag, // 定义自定义图形类型\n  });\n\n  // 获取用户传入的自定义属性\n  // @see /zh/api/builtin-objects/element#attributes\n  const { body, startHead, endHead, ...rest } = this.attributes;\n\n  // 躯干部分必须指定\n  if (!body) {\n    throw new Error(\"Arrow's body is required\");\n  }\n\n  // 添加躯干\n  this.body = body;\n  this.appendChild(this.body);\n\n  // 添加起始/结束端点\n  if (startHead) {\n    this.appendArrowHead(this.getArrowHeadType(startHead), true);\n  }\n  if (endHead) {\n    this.appendArrowHead(this.getArrowHeadType(endHead), false);\n  }\n\n  // 给躯干、端点应用样式\n  this.applyArrowStyle(rest, [this.body, this.startHead, this.endHead]);\n}\n",paraId:28,tocIndex:2},{value:"我们支持内置端点和用户传入的端点，即使是由用户传入，它也只用于描述端点的形状，为了确保箭头和躯干部分朝向一致，我们还需要对端点进行变换。另外，我们使用了 ",paraId:29,tocIndex:3},{value:"zIndex",paraId:30,tocIndex:3},{value:"，由于默认 zIndex 为 0，因此设置成 1 就可以保证端点的展示次序在躯干部分之上。",paraId:29,tocIndex:3},{value:"private appendArrowHead(type: ArrowHeadType, isStart: boolean) {\n  let head: DisplayObject;\n  if (type === 'default') {\n    // 创建一个默认端点\n    head = this.createDefaultArrowHead();\n  } else {\n    // 使用用户传入的端点\n    head = isStart ? this.attributes.startHead : this.attributes.endHead;\n  }\n\n  // 对端点进行变换\n  this.transformArrowHead(head, isStart);\n\n  // 让端点展示在躯干上\n  head.setAttribute('zIndex', 1);\n  // 或者 head.style.zIndex = 1;\n\n  if (isStart) {\n    this.startHead = head;\n  } else {\n    this.endHead = head;\n  }\n\n  // 场景图中添加端点\n  this.appendChild(head);\n}\n",paraId:31,tocIndex:3},{value:"对于内置默认端点，我们使用一个形如 ",paraId:32,tocIndex:3},{value:"<",paraId:32,tocIndex:3},{value:" 的 ",paraId:32,tocIndex:3},{value:"Path",paraId:33,tocIndex:3},{value:"，这里将 anchor 设置为 ",paraId:32,tocIndex:3},{value:"[0.5, 0.5]",paraId:32,tocIndex:3},{value:" 即 Path 的中心点，便于后续对端点进行变换：",paraId:32,tocIndex:3},{value:"private createDefaultArrowHead() {\n  // 沿用箭头的自定义属性\n  const { stroke, lineWidth } = this.attributes;\n  const { sin, cos, PI } = Math;\n  return new Path({\n    style: {\n      path: `M${10 * cos(PI / 6)},${10 * sin(PI / 6)} L0,0 L${10 * cos(PI / 6)},-${10 * sin(PI / 6)\n        }`,\n      stroke,\n      lineWidth,\n      anchor: [0.5, 0.5], // 锚点默认为 [0, 0]\n    },\n  });\n}\n",paraId:34,tocIndex:3},{value:"下一步需要对端点进行变换，确保它出现在正确的位置（躯干的两端）以及拥有正确的朝向。",paraId:35,tocIndex:3},{value:"对于端点的变换可以分成两步，设置位置（躯干的起始还是结束）以及朝向。",paraId:36,tocIndex:4},{value:"根据不同的躯干图形，可以通过不同的方法得到两个端点坐标。需要注意的是，设置端点位置时，一定要使用",paraId:37,tocIndex:4},{value:"局部坐标系下的操作方法",paraId:38,tocIndex:4},{value:"，即 setLocalPosition 或者 translateLocal，原因是我们希望端点在整个箭头而非世界坐标系下定位，这样当整个箭头移动时，其内部的各个组成部分（躯干、端点）会跟着移动，但彼此的相对位置不会改变。",paraId:37,tocIndex:4},{value:"同样的，在设置端点随躯干的旋转角度时，也需要在端点本身的旋转角度基础上，增加躯干切线的角度，因此需要使用 get/setLocalEulerAngles。",paraId:39,tocIndex:4},{value:"private transformArrowHead(head: DisplayObject, isStart: boolean) {\n  let rad = 0;\n  let x1 = 0;\n  let x2 = 0;\n  let y1 = 0;\n  let y2 = 0;\n\n  // 躯干类型\n  const bodyType = this.body && this.body.nodeName;\n  if (bodyType === Shape.LINE) {\n    // 省略计算切线\n  } else if (bodyType === Shape.POLYLINE) {\n    // 省略计算切线\n  } else if (bodyType === Shape.PATH) {\n    // 省略计算切线\n  }\n\n  // 计算弧度\n  const x = x1 - x2;\n  const y = y1 - y2;\n  rad = Math.atan2(y, x);\n\n  // 设置局部坐标系下的位置\n  head.setLocalPosition(x2, y2);\n  // 设置局部坐标系下的旋转角度，弧度转换成角度\n  head.setLocalEulerAngles((rad * 180) / Math.PI + head.getLocalEulerAngles());\n}\n",paraId:40,tocIndex:4},{value:"下面我们来看不同类型的躯干如何计算切线，这部分纯粹是简单的数学运算，和本文的主题关系不大。",paraId:41,tocIndex:4},{value:"对于 Line 和 Polyline 只需要找到两个端点坐标相减即可，对于 Path 我们提供了",paraId:42,tocIndex:5},{value:"计算切线的 API",paraId:43,tocIndex:5},{value:"：",paraId:42,tocIndex:5},{value:"private getTangent(path: Path, isStart: boolean): number[][] {\n  return isStart ? path.getStartTangent() : path.getEndTangent();\n}\n",paraId:44,tocIndex:5},{value:"至此一个简单的箭头就组装完成了。",paraId:45,tocIndex:5},{value:"自定义图形可以使用大部分基础图形的能力，例如节点操作、变换、动画、响应事件等。",paraId:46,tocIndex:6},{value:"使用箭头这样的高级图形和其他基础图形一样，例如我们可以创建一个躯干为 Line 的箭头。随后对它使用变换方法，例如平移。同样也可以使用场景图的节点查询能力，例如 getElementById：",paraId:47,tocIndex:7},{value:"const lineArrow = new Arrow({\n    id: 'lineArrow',\n    style: {\n        body: new Line({\n            style: {\n                x1: 200,\n                y1: 100,\n                x2: 0,\n                y2: 0,\n            },\n        }),\n        startHead: true,\n        stroke: '#1890FF',\n        lineWidth: 10,\n        cursor: 'pointer',\n    },\n});\n\n// 平移\nlineArrow.translate(200, 100);\n\n// 按 id 查询\ncanvas.document.getElementById('lineArrow'); // Arrow lineArrow\n",paraId:48,tocIndex:7},{value:"同样也可以对它",paraId:49,tocIndex:8},{value:"应用动画",paraId:50,tocIndex:8},{value:"，例如对 transform stroke 和 opacity 这三个属性：",paraId:49,tocIndex:8},{value:"lineArrow.animate(\n    [\n        { transform: 'scale(1)', stroke: '#F04864', opacity: 1 },\n        { transform: 'scale(2)', stroke: '#1890FF', opacity: 0.8 },\n    ],\n    {\n        duration: 1500,\n        iterations: Infinity,\n        easing: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)',\n    },\n);\n",paraId:51,tocIndex:8},{value:"完整 DEMO",paraId:52},{value:"自定义图形也可以",paraId:53,tocIndex:9},{value:"响应事件",paraId:54,tocIndex:9},{value:"，例如当鼠标移入移出时更改颜色：",paraId:53,tocIndex:9},{value:"lineArrow.addEventListener('mouseenter', () => {\n    lineArrow.style.stroke = '#2FC25B';\n});\nlineArrow.addEventListener('mouseleave', () => {\n    lineArrow.style.stroke = '#1890FF';\n});\n",paraId:55,tocIndex:9},{value:"自定义属性有可能发生更新，例如在创建后改变箭头端点的样式，因此需要监听属性值的变化。参考 Web Components 标准，我们提供了以下生命周期方法供子类实现，这里我们着重关注 attributeChangedCallback。",paraId:56,tocIndex:10},{value:"export interface CustomElement<CustomElementStyleProps> {\n  /**\n   * 加入画布时触发\n   */\n  connectedCallback?(): void;\n\n  /**\n   * 从画布移除时触发\n   */\n  disconnectedCallback?(): void;\n\n  /**\n   * 属性发生修改时触发\n   */\n  attributeChangedCallback?<Key extends keyof CustomElementStyleProps>(\n    name: Key,\n    oldValue: CustomElementStyleProps[Key],\n    newValue: CustomElementStyleProps[Key],\n  ): void;\n}\n",paraId:57,tocIndex:10},{value:"在我们的 ",paraId:58,tocIndex:10},{value:"DEMO",paraId:59,tocIndex:10},{value:" 中，可以随时切换端点和躯干图形。例如切换起始端点为一个图片：",paraId:58,tocIndex:10},{value:"const image = new Image({\n    style: {\n        width: 50,\n        height: 50,\n        anchor: [0.5, 0.5],\n        src: 'https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*N4ZMS7gHsUIAAAAAAAAAAABkARQnAQ',\n    },\n});\nimage.rotateLocal(90);\n// 修改起始端点\nlineArrow.style.startHead = image;\n",paraId:60,tocIndex:10},{value:"此时我们可以监听 startHead 属性的更新，当该属性发生修改时，首先需要移除已存在的起始端点，然后再重新添加：",paraId:61,tocIndex:10},{value:"attributeChangedCallback<Key extends keyof ArrowStyleProps>(\n  name: Key,\n  oldValue: ArrowStyleProps[Key],\n  newValue: ArrowStyleProps[Key],\n) {\n  if (name === 'startHead' || name === 'endHead') {\n    const isStart = name === 'startHead';\n    // 移除已有的端点\n    this.destroyArrowHead(isStart);\n\n    if (newValue) {\n      const { body, startHead, endHead, ...rest } = this.attributes;\n      // 重新添加端点\n      this.appendArrowHead(this.getArrowHeadType(newValue), isStart);\n      this.applyArrowStyle(rest, [isStart ? this.startHead : this.endHead]);\n    }\n  }\n}\n",paraId:62,tocIndex:10},{value:"其中移除端点使用到了 removeChild，这同样是场景图提供的节点操作方法：",paraId:63,tocIndex:10},{value:"private destroyArrowHead(isStart: boolean) {\n  if (isStart && this.startHead) {\n    this.removeChild(this.startHead);\n    this.startHead = undefined;\n  }\n  if (!isStart && this.endHead) {\n    this.removeChild(this.endHead);\n    this.endHead = undefined;\n  }\n}\n",paraId:64,tocIndex:10},{value:"一旦挂载到画布后，自定义组件就视作一个整体，内部的图形不能再通过场景图查询能力（例如 getElementById）获得。因此可以暴露方法给使用者，例如获取箭头的躯干、端点部分。",paraId:65,tocIndex:11},{value:"getBody() {\n  return this.body;\n}\n\ngetStartHead() {\n  return this.startHead;\n}\n\ngetEndHead() {\n  return this.endHead;\n}\n",paraId:66,tocIndex:11}]},97398:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(69979);const d=[{value:"在之前的",paraId:0},{value:"入门教程",paraId:1},{value:"中，我们已经掌握了如何为图形添加事件监听器。在本教程中我们将深入了解监听器被触发时，事件对象上一些有用的属性和方法，同时理解事件传播路径，最终实现一个简单的事件委托效果。",paraId:0},{value:"最终示例：",paraId:2},{value:"官网示例",paraId:3},{value:"CodeSandbox 示例",paraId:4},{value:"这次我们的场景十分简单，类似 DOM 中的 ul/li：",paraId:5,tocIndex:0},{value:"Group(ul)\n    - Rect(li)\n    - Rect(li)\n",paraId:6,tocIndex:0},{value:"我们希望给 ul 下每个 li 增加点击事件监听，最直接的做法当然是：",paraId:7,tocIndex:0},{value:"li1.addEventListener('click', () => {});\nli2.addEventListener('click', () => {});\n",paraId:8,tocIndex:0},{value:"这没有任何问题，但每次给 ul 添加新的 li 时，都需要添加这样的一个监听器，有没有“一劳永逸”的方法呢？",paraId:9,tocIndex:0},{value:"在引入事件委托之前，我们先来看看事件传播机制。由于我们完全兼容 DOM Event API，不妨借用 MDN 上的教程来说明。在下图中，当我们点击 ",paraId:10,tocIndex:0},{value:"<video>",paraId:10,tocIndex:0},{value:" 元素时，会依次触发捕获（capturing）和冒泡（bubbling）两个阶段，前者从根节点一路进行到目标节点，触发路径上每个节点的 onclick 事件监听器（如有），后者则相反。",paraId:10,tocIndex:0},{value:"https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events",paraId:11,tocIndex:0},{value:"在我们的示例场景中，点击每一个 li 时同样也会经历上述传播阶段，因此只需要在父节点 ul 上监听即可，事件自然会冒泡上来，这就是事件委托：",paraId:12,tocIndex:0},{value:"ul.addEventListener('click', (ev) => {\n    ev.target; // li1 li2...\n});\n",paraId:13,tocIndex:0},{value:"事件对象上有很多有用的属性，我们先来看看上一节中提到的事件传播路径，通过",paraId:14,tocIndex:1},{value:"composedPath()",paraId:15,tocIndex:1},{value:"方法可以获取它。当我们点击 li1 时，此时路径会返回如下结果：",paraId:14,tocIndex:1},{value:"ev.composedPath(); // [Rect(li1), Group(ul), Group(root), Document, Canvas];\n",paraId:16,tocIndex:1},{value:"该结果是一个数组，依次展示了从事件触发的目标节点到根节点的路径，我们从后往前看：",paraId:17,tocIndex:1},{value:"Canvas",paraId:18,tocIndex:1},{value:" 即画布对象，可以对应 ",paraId:19,tocIndex:1},{value:"window",paraId:19,tocIndex:1},{value:"Document",paraId:20,tocIndex:1},{value:" 文档，可以对应 ",paraId:19,tocIndex:1},{value:"window.document",paraId:19,tocIndex:1},{value:"Group(root)",paraId:21,tocIndex:1},{value:" 文档根节点，可以对应 ",paraId:19,tocIndex:1},{value:"window.document.documentElement",paraId:19,tocIndex:1},{value:"除了事件传播路径，事件对象上其他的常用属性有：",paraId:22,tocIndex:1},{value:"target",paraId:23,tocIndex:1},{value:" 返回当前触发事件的图形",paraId:24,tocIndex:1},{value:"currentTarget",paraId:25,tocIndex:1},{value:" 总是指向事件绑定的图形",paraId:24,tocIndex:1},{value:"各个坐标系下的",paraId:24,tocIndex:1},{value:"事件坐标",paraId:26,tocIndex:1},{value:"还有一些常见的需求可以在绑定事件时做到，例如绑定一个“一次性”的监听器：",paraId:27,tocIndex:2},{value:"circle.addEventListener('click', () => {}, { once: true });\n",paraId:28,tocIndex:2},{value:"再比如注册一个仅在事件捕获阶段执行的监听器：",paraId:29,tocIndex:2},{value:"circle.addEventListener('click', () => {}, { capture: true });\n// 或者\ncircle.addEventListener('click', () => {}, true);\n",paraId:30,tocIndex:2},{value:"更多用法可以参考 ",paraId:31,tocIndex:2},{value:"addEventListener()",paraId:32,tocIndex:2},{value:" 的文档。",paraId:31,tocIndex:2}]},90386:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(75749);const d=[{value:"一些图表库提供了保存内容到图片的功能，下图来自 ",paraId:0},{value:"Highcharts",paraId:0},{value:"：",paraId:0},{value:"为此我们提供了 ",paraId:1},{value:"g-image-exporter",paraId:1},{value:"，它支持选定画布区域，导出指定格式的 dataURL 或保存成图片等功能，",paraId:1},{value:"示例",paraId:2},{value:"。其中部分功能依赖 DOM API，对于非浏览器运行环境，请参考 ",paraId:1},{value:"画布的特殊运行平台适配",paraId:3},{value:"。例如下载功能需要通过 ",paraId:1},{value:"document.createElement('a')",paraId:1},{value:" 实现，非浏览器环境需要自行传入 ",paraId:1},{value:"document",paraId:1},{value:" 对象。",paraId:1},{value:"创建时可以指定以下配置项，其中 ",paraId:4,tocIndex:0},{value:"canvas",paraId:4,tocIndex:0},{value:" 为必填项，将画布传入：",paraId:4,tocIndex:0},{value:"import { ImageExporter } from '@antv/g-image-exporter';\n\nconst exporter = new ImageExporter({\n    canvas, // 传入画布\n    defaultFilename: 'my-default-filename',\n});\n",paraId:5,tocIndex:0},{value:"在调用 ",paraId:6,tocIndex:1},{value:"downloadImage",paraId:7,tocIndex:1},{value:" 保存并下载图片时，如果没有指定文件名，将使用该配置项的值作为默认文件名。",paraId:6,tocIndex:1},{value:"该方法用以将指定区域的画布内容绘制到额外的 HTMLCanvasElement 中，随后可以根据需要进一步加工，例如添加背景色、水印等。",paraId:8,tocIndex:3},{value:"完整方法签名如下，该方法为",paraId:9,tocIndex:3},{value:"异步",paraId:9,tocIndex:3},{value:"：",paraId:9,tocIndex:3},{value:"toCanvas(options: Partial<CanvasOptions> = {}): Promise<HTMLCanvasElement>;\n\ninterface CanvasOptions {\n  clippingRegion: Rectangle;\n  beforeDrawImage: (context: CanvasRenderingContext2D) => void;\n  afterDrawImage: (context: CanvasRenderingContext2D) => void;\n}\n",paraId:10,tocIndex:3},{value:"各配置项含义如下：",paraId:11,tocIndex:3},{value:"clippingRegion 画布裁剪区域，用矩形表示",paraId:12,tocIndex:3},{value:"beforeDrawImage 在绘制画布内容前调用，适合绘制背景颜色",paraId:12,tocIndex:3},{value:"afterDrawImage 在绘制画布内容后调用，适合绘制水印",paraId:12,tocIndex:3},{value:"ignoreElements 在导出 HTML 内容时，如何判断容器内一个 HTMLElement 是否被忽略",paraId:12,tocIndex:3},{value:"在该",paraId:13,tocIndex:3},{value:"示例",paraId:14,tocIndex:3},{value:"中，我们添加了背景色和水印，通过传入的 ",paraId:13,tocIndex:3},{value:"CanvasRenderingContext2D",paraId:13,tocIndex:3},{value:" 可以调用 Canvas2D API 进行绘制：",paraId:13,tocIndex:3},{value:"import { Rectangle } from '@antv/g';\n\nconst canvas = await exporter.toCanvas({\n    // 忽略 stats.js lil-gui 等在容器内添加的 DOM 元素\n    ignoreElements: (element) => {\n        return [gui.domElement, stats.dom].indexOf(element) > -1;\n    },\n    // 指定导出画布区域\n    clippingRegion: new Rectangle(\n        clippingRegionX,\n        clippingRegionY,\n        clippingRegionWidth,\n        clippingRegionHeight,\n    ),\n    beforeDrawImage: (context) => {\n        // 绘制背景色\n        context.fillStyle = backgroundColor;\n        context.fillRect(0, 0, clippingRegionWidth, clippingRegionHeight);\n    },\n    afterDrawImage: (context) => {\n        // 绘制水印\n        context.font = '24px Times New Roman';\n        context.fillStyle = '#FFC82C';\n        context.fillText('AntV', 20, 20);\n    },\n});\n",paraId:15,tocIndex:3},{value:"注意裁剪区域使用的是 ",paraId:16,tocIndex:3},{value:"Rectangle",paraId:16,tocIndex:3},{value:" 而非 ",paraId:16,tocIndex:3},{value:"Rect",paraId:17,tocIndex:3},{value:" 图形。它的构造函数中包含 ",paraId:16,tocIndex:3},{value:"x/y/width/height",paraId:16,tocIndex:3},{value:" 四个参数。它相对于",paraId:16,tocIndex:3},{value:"视口坐标系",paraId:18,tocIndex:3},{value:"下，即对于一个 400 x 400 的画布，裁剪的最大宽高就是 400。",paraId:16,tocIndex:3},{value:"在导出 ",paraId:19,tocIndex:3},{value:"HTML",paraId:20,tocIndex:3},{value:" 时，默认会导出容器内的全部 HTMLElement，但有时有些元素并不是我们想导出的，此时可以使用 ",paraId:19,tocIndex:3},{value:"ignoreElements: (element: Element): boolean;",paraId:19,tocIndex:3},{value:" 方法进行过滤。例如该",paraId:19,tocIndex:3},{value:"示例",paraId:21,tocIndex:3},{value:"中容器内还有 stats.js 和 lil-gui 添加的 DOM 元素，我们并不希望导出，此时可以：",paraId:19,tocIndex:3},{value:"ignoreElements: (element) => {\n    return [gui.domElement, stats.dom].indexOf(element) > -1;\n},\n",paraId:22,tocIndex:3},{value:"有时我们想导出矢量图。不同于 ",paraId:23,tocIndex:4},{value:"toCanvas",paraId:24,tocIndex:4},{value:" 对于所有渲染器都支持，只有 ",paraId:23,tocIndex:4},{value:"g-svg",paraId:25,tocIndex:4},{value:" 渲染器支持生成 SVG 类型的 dataURL，如果选择了其他渲染器，将返回 ",paraId:23,tocIndex:4},{value:"Promise<undefined>",paraId:23,tocIndex:4},{value:"。",paraId:23,tocIndex:4},{value:"方法签名如下：",paraId:26,tocIndex:4},{value:"toSVGDataURL(): Promise<string>;\n",paraId:27,tocIndex:4},{value:"内部使用 ",paraId:28,tocIndex:4},{value:"XMLSerializer",paraId:28,tocIndex:4},{value:" 实现，将 SVGElement 序列化成 XML 字符串。",paraId:28,tocIndex:4},{value:"触发浏览器下载行为，可以将 ",paraId:29,tocIndex:5},{value:"导出的 dataURL",paraId:30,tocIndex:5},{value:" 传入并指定保存的文件名。",paraId:29,tocIndex:5},{value:"完整方法签名如下：",paraId:31,tocIndex:5},{value:"downloadImage(options: DownloadImageOptions): void;\n\ninterface DownloadImageOptions {\n  dataURL: string;\n  name?: string;\n}\n",paraId:32,tocIndex:5},{value:"在该",paraId:33,tocIndex:5},{value:"示例",paraId:34,tocIndex:5},{value:"中，点击按钮立即开始下载图片，如果选择了 ",paraId:33,tocIndex:5},{value:"image/png",paraId:33,tocIndex:5},{value:" 格式，最终保存成 ",paraId:33,tocIndex:5},{value:"my-file.png",paraId:33,tocIndex:5},{value:" 文件：",paraId:33,tocIndex:5},{value:"const canvas = await exporter.toCanvas();\nconst dataURL = canvas.toDataURL();\n\n// 触发下载\nexporter.downloadImage({\n    dataURL,\n    name: 'my-file',\n});\n",paraId:35,tocIndex:5},{value:"下载行为是通过使用 ",paraId:36,tocIndex:5},{value:"document",paraId:36,tocIndex:5},{value:"创建 HTMLAnchorElement 并触发它的默认点击行为实现的。",paraId:36,tocIndex:5},{value:"通过 ",paraId:37,tocIndex:6},{value:"toCanvas",paraId:38,tocIndex:6},{value:" 我们得到了包含画布内容的 HTMLCanvasElement，使用其原生方法 ",paraId:37,tocIndex:6},{value:"toDataURL",paraId:37,tocIndex:6},{value:" 就可以得到 dataURL：",paraId:37,tocIndex:6},{value:"const canvas = await exporter.toCanvas();\nconst dataURL = canvas.toDataURL(); // data:...\n",paraId:39,tocIndex:6},{value:"在 ",paraId:40,tocIndex:6},{value:"toDataURL",paraId:40,tocIndex:6},{value:" 方法中可以指定图片格式，默认为 ",paraId:40,tocIndex:6},{value:"image/png",paraId:40,tocIndex:6},{value:"，以及图片质量，详见",paraId:40,tocIndex:6},{value:"参数",paraId:40,tocIndex:6},{value:"。",paraId:40,tocIndex:6},{value:"HTMLCanvasElement 同样提供了 ",paraId:41,tocIndex:7},{value:"getImageData",paraId:41,tocIndex:7},{value:" 方法用于获取指定区域的像素数据：",paraId:41,tocIndex:7},{value:"const canvas = await exporter.toCanvas();\nconst imageData = canvas.getContext('2d').getImageData(50, 50, 100, 100); // ImageData { width: 100, height: 100, data: Uint8ClampedArray[40000] }\n",paraId:42,tocIndex:7},{value:"如果我们还想在前端根据图片生成 PDF，可以参考：",paraId:43,tocIndex:8},{value:"https://github.com/parallax/jsPDF",paraId:43,tocIndex:8},{value:"导出图片的物理尺寸已经包含了 resolution，即对于指定了宽高 400 x 400 的画布，如果当前环境的 ",paraId:44,tocIndex:10},{value:"devicePixelRatio",paraId:44,tocIndex:10},{value:" 为 2，将生成 800 x 800 的图片。",paraId:44,tocIndex:10},{value:"可以，如果画布中包含 ",paraId:45,tocIndex:11},{value:"HTML",paraId:46,tocIndex:11},{value:"，目前不同的渲染器实现如下：",paraId:45,tocIndex:11},{value:"导出 SVG，其中天然包含 ",paraId:47,tocIndex:11},{value:"foreignObject",paraId:47,tocIndex:11},{value:"导出其他图片格式，内部使用 ",paraId:47,tocIndex:11},{value:"html2canvas",paraId:47,tocIndex:11},{value:" 实现",paraId:47,tocIndex:11},{value:"在该",paraId:48,tocIndex:11},{value:"示例",paraId:49,tocIndex:11},{value:"中，左上角 Tooltip 就是一个 HTML。",paraId:48,tocIndex:11},{value:"HTMLCanvasElement 的原生方法 ",paraId:50,tocIndex:12},{value:"toDataURL",paraId:50,tocIndex:12},{value:" 的确是一个同步方法。",paraId:50,tocIndex:12},{value:"但由于 WebGL / Canvaskit 使用双缓冲机制，拥有绘制 Buffer 和展示 Buffer。好处是相比每一帧都拷贝绘制 Buffer 的内容到展示 Buffer，直接交换效率更高。因此在创建 WebGL 上下文时我们关闭了 ",paraId:51,tocIndex:12},{value:"preserveDrawingBuffer",paraId:51,tocIndex:12},{value:"，但需要确保调用 toDataURL 时渲染没有被清除（调用 ",paraId:51,tocIndex:12},{value:"gl.clear()",paraId:51,tocIndex:12},{value:"），这会导致该行为变成异步，等待下一次渲染 tick 时才能获取内容。",paraId:51,tocIndex:12},{value:"另外在导出 ",paraId:52,tocIndex:12},{value:"HTML",paraId:53,tocIndex:12},{value:" 内容时，使用 ",paraId:52,tocIndex:12},{value:"html2canvas",paraId:52,tocIndex:12},{value:" 提供的导出方法同样也是一个异步操作。",paraId:52,tocIndex:12},{value:"我们提供的导出方法都只针对画布视口范围，即使是裁剪也是相对",paraId:54,tocIndex:13},{value:"视口坐标系",paraId:55,tocIndex:13},{value:"下。因此如果想导出视口之外的图形，可以使用",paraId:54,tocIndex:13},{value:"相机 API",paraId:56,tocIndex:13},{value:" 在不改变场景结构的前提下改变视口范围，例如通过 ",paraId:54,tocIndex:13},{value:"setZoom",paraId:54,tocIndex:13},{value:" 进行缩放，让视口内容纳更多图形。",paraId:54,tocIndex:13},{value:"HTMLCanvasElement 的原生方法 ",paraId:57,tocIndex:14},{value:"toDataURL",paraId:57,tocIndex:14},{value:" 有可能在某些古早浏览器上不支持，此时可以使用 polyfill： ",paraId:57,tocIndex:14},{value:"https://stackoverflow.com/a/47148969",paraId:57,tocIndex:14},{value:"在该",paraId:58,tocIndex:15},{value:"示例",paraId:59,tocIndex:15},{value:"中，导出的 SVG 中包含如下 ",paraId:58,tocIndex:15},{value:"<style>",paraId:58,tocIndex:15},{value:" 内容，使用 CSS Animations 保存了部分动画效果：",paraId:58,tocIndex:15},{value:"#g-svg-xx {\n  animation: u0 linear 2250ms infinite;\n}\n@keyframes u0{1.32%{transform:scale(0,1)}\n",paraId:60,tocIndex:15},{value:"但需要注意的是，不是所有支持动画的属性都可以转换成 CSS Animations 表示，例如",paraId:61,tocIndex:15},{value:"形变动画",paraId:62,tocIndex:15},{value:"中使用到的 path 属性。另外在 ",paraId:61,tocIndex:15},{value:"EffectTiming",paraId:63,tocIndex:15},{value:" 中，有些配置项 CSS Animations 还不支持，因此也无法体现在导出的文件中：",paraId:61,tocIndex:15},{value:"自定义的缓动函数",paraId:64,tocIndex:15},{value:"endDelay",paraId:65,tocIndex:15},{value:"iterationStart",paraId:66,tocIndex:15},{value:"最后，在使用该功能时，需要确保导出前所有动画效果处于暂停状态。只有这样才能保证在导出的这一刻，图形都处于初始状态，否则 SVG 中将保存中间时刻的状态：",paraId:67,tocIndex:15},{value:"animation.pause();\nconst svgDataURL = await exporter.toSVGDataURL();\n",paraId:68,tocIndex:15}]},46209:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(59025);const d=[{value:"浏览器在不断迭代新功能的过程中，体积会越来越大。尽管我们想实现一个“小浏览器”，但在体积敏感的场景下，用户仍希望使用最小功能集。这就要求我们对现有功能进行合理拆分，力图实现最小核心 + 渐进式增强的模式。",paraId:0},{value:"下图展示了 ",paraId:1},{value:"@antv/g",paraId:1},{value:" 的 bundle 组成情况。",paraId:1},{value:"完整版 ",paraId:2},{value:"@antv/g",paraId:2},{value:" 由以下几部分组成：",paraId:2},{value:"@antv/g-lite",paraId:3},{value:" 包含 ",paraId:3},{value:"画布",paraId:4},{value:"，",paraId:3},{value:"基础图形",paraId:5},{value:"，",paraId:3},{value:"事件系统",paraId:6},{value:"，",paraId:3},{value:"插件系统",paraId:7},{value:" 等核心功能",paraId:3},{value:"@antv/g-camera-api",paraId:3},{value:" 提供完整相机动作和动画功能",paraId:3},{value:"@antv/g-web-animations-api",paraId:3},{value:" 提供兼容 ",paraId:3},{value:"Web Animations API",paraId:3},{value:" 的动画系统",paraId:3},{value:"@antv/g-css-typed-om-api",paraId:3},{value:" 提供 ",paraId:3},{value:"CSS Typed OM API",paraId:8},{value:"@antv/g-css-layout-api",paraId:3},{value:" 提供 ",paraId:3},{value:"CSS Layout API",paraId:9},{value:"@antv/g-dom-mutation-observer-api",paraId:3},{value:" 提供 DOM Mutation Observer API",paraId:3},{value:"精简版使用方式和完整版在核心功能使用上完全一致，例如创建画布、基础图形、使用渲染器等：",paraId:10,tocIndex:0},{value:"import { Canvas, Circle } from '@antv/g-lite';\nimport { Renderer } from '@antv/g-canvas';\n",paraId:11,tocIndex:0},{value:"此时调用元素的动画方法将无任何效果：",paraId:12,tocIndex:0},{value:"circle.animate([], {});\n",paraId:13,tocIndex:0},{value:"需要手动引入 ",paraId:14,tocIndex:0},{value:"@antv/g-web-animations-api",paraId:14,tocIndex:0},{value:" 后方可生效：",paraId:14,tocIndex:0},{value:"import { Canvas, Circle } from '@antv/g-lite';\nimport '@antv/g-web-animations-api';\n",paraId:15,tocIndex:0},{value:"其他渐进式功能可使用类似方式按需引入。",paraId:16,tocIndex:0},{value:"下面详细介绍下拆分后各部分的功能。",paraId:17,tocIndex:1},{value:"包含 ",paraId:18,tocIndex:2},{value:"画布",paraId:19,tocIndex:2},{value:"，",paraId:18,tocIndex:2},{value:"基础图形",paraId:20,tocIndex:2},{value:"，",paraId:18,tocIndex:2},{value:"事件系统",paraId:21,tocIndex:2},{value:"，",paraId:18,tocIndex:2},{value:"插件系统",paraId:22,tocIndex:2},{value:" 等核心功能。",paraId:18,tocIndex:2},{value:"以上功能的使用方式没有变化，",paraId:23,tocIndex:2},{value:"示例",paraId:24,tocIndex:2},{value:"：",paraId:23,tocIndex:2},{value:"import { Canvas, Circle } from '@antv/g-lite';\nimport { Renderer } from '@antv/g-canvas';\n\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer: new Renderer(),\n});\n\nconst circle = new Circle({\n    style: { r: 100 },\n});\n",paraId:25,tocIndex:2},{value:"@antv/g-lite",paraId:26,tocIndex:3},{value:" 中包含了一个简单的相机实现，但无法使用",paraId:26,tocIndex:3},{value:"相机动作",paraId:27,tocIndex:3},{value:"和",paraId:26,tocIndex:3},{value:"相机动画",paraId:28,tocIndex:3},{value:"：",paraId:26,tocIndex:3},{value:"camera.pan(); // throw new Error('Method not implemented.');\ncamera.createLandmark(); // throw new Error('Method not implemented.');\n",paraId:29,tocIndex:3},{value:"引入后方可正常使用。",paraId:30,tocIndex:3},{value:"为基础图形提供兼容 ",paraId:31,tocIndex:4},{value:"Web Animations API",paraId:31,tocIndex:4},{value:" 的",paraId:31,tocIndex:4},{value:"动画能力",paraId:32,tocIndex:4},{value:"。缺少该功能仍可以调用 ",paraId:31,tocIndex:4},{value:"object.animate()",paraId:31,tocIndex:4},{value:" 方法，但无任何效果。",paraId:31,tocIndex:4},{value:"CSS Typed OM API",paraId:33,tocIndex:5},{value:" 允许使用 JS 操作解析后的属性值，它也是 CSS Houdini 的基础。以 ",paraId:33,tocIndex:5},{value:"width: '50%'",paraId:33,tocIndex:5},{value:" 为例，字符串形式的属性值会被解析成 ",paraId:33,tocIndex:5},{value:"CSS.percent(50)",paraId:33,tocIndex:5},{value:"，方便进行下一步的计算。",paraId:33,tocIndex:5},{value:"我们提供了",paraId:34,tocIndex:5},{value:"类似能力",paraId:35,tocIndex:5},{value:"。",paraId:34,tocIndex:5},{value:"参考 ",paraId:36,tocIndex:6},{value:"CSS Layout API",paraId:36,tocIndex:6},{value:" 提供",paraId:36,tocIndex:6},{value:"布局能力",paraId:37,tocIndex:6},{value:"。",paraId:36,tocIndex:6},{value:"在 DOM API 中，当我们想感知 DOM 树节点的修改，例如新节点加入、属性值变更，可以使用 ",paraId:38,tocIndex:7},{value:"MutationObserver",paraId:38,tocIndex:7},{value:"。",paraId:38,tocIndex:7},{value:"在 G 中我们同样实现了这个 ",paraId:39,tocIndex:7},{value:"API",paraId:40,tocIndex:7},{value:"，用来监听场景图中的变化。",paraId:39,tocIndex:7},{value:"在基础图形上提供兼容旧版本的方法，大部分在新版中都有兼容 DOM API 的实现。因此不推荐使用这些方法，后续随时可能移除：",paraId:41,tocIndex:8},{value:"getCount 获取子节点数目，新版使用 ",paraId:42,tocIndex:8},{value:"childElementCount",paraId:43,tocIndex:8},{value:"getParent 获取父节点，新版使用 ",paraId:42,tocIndex:8},{value:"parentElement",paraId:44,tocIndex:8},{value:"getChildren 获取子节点列表，新版使用 ",paraId:42,tocIndex:8},{value:"children",paraId:45,tocIndex:8},{value:"getFirst 获取第一个子节点，新版使用 ",paraId:42,tocIndex:8},{value:"firstElementChild",paraId:46,tocIndex:8},{value:"getLast 获取最后一个子节点，新版使用 ",paraId:42,tocIndex:8},{value:"lastElementChild",paraId:47,tocIndex:8},{value:"getChildByIndex 按索引获取子节点，新版使用 ",paraId:42,tocIndex:8},{value:"this.children[index]",paraId:42,tocIndex:8},{value:"add 添加子节点，新版使用 ",paraId:42,tocIndex:8},{value:"appendChild",paraId:48,tocIndex:8},{value:"setClip 设置裁剪图形，新版使用 ",paraId:42,tocIndex:8},{value:"clipPath",paraId:49,tocIndex:8},{value:"getClip 获取裁剪图形，同上",paraId:42,tocIndex:8},{value:"set 在初始化配置上存储键值对",paraId:42,tocIndex:8},{value:"get 在初始化配置上读取值",paraId:42,tocIndex:8},{value:"show 展示图形，新版使用 ",paraId:42,tocIndex:8},{value:"visibility",paraId:50,tocIndex:8},{value:"hide 隐藏图形，同上",paraId:42,tocIndex:8},{value:"moveTo 在世界坐标系下移动图形，新版使用 ",paraId:42,tocIndex:8},{value:"setPosition",paraId:51,tocIndex:8},{value:"move 同上",paraId:42,tocIndex:8},{value:"setZIndex 设置渲染次序，新版使用 ",paraId:42,tocIndex:8},{value:"zIndex",paraId:52,tocIndex:8}]},36790:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(22867);const d=[{value:"任何一个渲染引擎都会在性能优化上下足功夫，任何优化手段都需要结合场景与具体 API 应用。在我们的可视化场景（2D 图表、大规模图场景）中，高效绘制大量简单图形是一个核心诉求。下面我们结合 Canvas2D / SVG / WebGL 和 WebGPU 这些渲染 API 介绍目前在 G 中使用的优化手段。",paraId:0},{value:"首先我们需要引入一个核心概念 draw call，以下介绍的优化方法大多围绕它展开。",paraId:1},{value:"为啥 draw call 多了就会影响性能呢？在 CPU 和 GPU 进行异步协作的过程中，会向 ",paraId:2,tocIndex:0},{value:"command buffer",paraId:2,tocIndex:0},{value:" 中提交需要 GPU 执行的命令，例如设置状态、绘制或者拷贝资源。CPU 准备这些命令的速度与 GPU 执行的速度存在不小差异，这就造成了性能瓶颈。",paraId:2,tocIndex:0},{value:"下图来自 ",paraId:3,tocIndex:0},{value:"https://toncijukic.medium.com/draw-calls-in-a-nutshell-597330a85381，分别展示了每一帧中",paraId:3,tocIndex:0},{value:" CPU 和 GPU 的时间线，可以看出 GPU 总是在执行上一帧 CPU 提交的命令，与此同时 CPU 在准备下一帧的命令。当这些绘制命令数量不多时，两者协作没问题，但如果数量很多，GPU 在做完这一帧的渲染任务后就不得不等待，也就无法在 16ms 内完成了，这造成了卡顿的体感。",paraId:3,tocIndex:0},{value:"因此我们需要想办法减少 CPU 提交的绘制命令数量，即能少画就少画，能不画就不画。下面我们会介绍不同渲染 API 下常用的优化手段，它们各有适合的场景。",paraId:4,tocIndex:1},{value:"图场景中一种常见的交互是通过鼠标滚轮进行放大查看，此时场景中仅有一部分可见，大部分都在视口范围之外。如果我们能将视口之外的图形“剔除”掉，就能减少绘制命令的数量。",paraId:5,tocIndex:2},{value:"决定场景中一个图形是否需要绘制的标准是什么呢？在下图中，灰色区域代表画布视口，如果对象“处于”视口内，我们就画（绿色图形），反之则剔除（红色图形）。",paraId:6,tocIndex:2},{value:"在判断一个图形是否在视口内时，我们通常会使用一种称作“包围盒”的结构。图形可以千变万化，但总可以找到一个包裹住它的最小基础几何结构，这个结构可以是“包围盒”，也可以是“包围球”，总之是为何后续与视口求交方便。在 G 中我们选择轴对齐包围盒。推广到 3D 场景中，视口也变成了视锥，下图来自 ",paraId:7,tocIndex:2},{value:"Unreal - Visibility and Occlusion Culling",paraId:7,tocIndex:2},{value:"：",paraId:7,tocIndex:2},{value:"在每一帧都在 CPU 端进行这样的求交运算开销不小，特别当场景中图形数量较多时。另外在 3D 场景中视锥与包围盒（立方体）各个面的求交开销更大，因此我们也采用了一系列优化方法：",paraId:8,tocIndex:2},{value:"在 3D 场景进行视锥剔除时，我们尽量使用了如下",paraId:9,tocIndex:2},{value:"加速检测方法",paraId:9,tocIndex:2},{value:"：",paraId:9,tocIndex:2},{value:"基础相交测试 the basic intersection test",paraId:10,tocIndex:2},{value:"平面一致性测试 the plane-coherency test",paraId:10,tocIndex:2},{value:"八分测试 the octant test",paraId:10,tocIndex:2},{value:"标记 masking",paraId:10,tocIndex:2},{value:"平移旋转一致性测试 TR coherency test",paraId:10,tocIndex:2},{value:"更多可以参考：",paraId:11,tocIndex:2},{value:"Optimized View Frustum Culling Algorithms for Bounding Boxes",paraId:12,tocIndex:2},{value:"Efficient View Frustum Culling",paraId:12,tocIndex:2},{value:"视锥体剔除 AABB 和 OBB 包围盒的优化方法",paraId:12,tocIndex:2},{value:"在 2D 场景中我们使用了空间索引（R-tree）进行区域查询的加速。首次为场景对象构建索引需要消耗一定时间，后续当图形发生变换时，也需要随时更新。",paraId:13,tocIndex:2},{value:"最后，由于剔除发生在 CPU 侧，与具体渲染 API 无关，因此这是一种相对通用的优化手段。",paraId:14,tocIndex:2},{value:"在 WebGL / WebGPU 这样的渲染 API 中，还提供了其他剔除手段：",paraId:15,tocIndex:3},{value:"背面剔除，",paraId:16,tocIndex:3},{value:"gl.cullFace",paraId:16,tocIndex:3},{value:"遮挡剔除，",paraId:16,tocIndex:3},{value:"gl.createQuery",paraId:16,tocIndex:3},{value:"。至少需要 WebGL2，G 中暂未使用",paraId:16,tocIndex:3},{value:"另一种常见的交互是通过鼠标高亮某个图形。此时场景中仅有一小部分发生了改变，擦除画布中的全部图形再重绘就显得没有必要了。类比 React diff 算法能够找出真正变化的最小部分，“脏矩形”渲染能尽可能复用上一帧的渲染结果，仅绘制变更部分，特别适合 Canvas2D API。",paraId:17,tocIndex:4},{value:"下图展示了这个思路：",paraId:18,tocIndex:4},{value:"当鼠标悬停在圆上时，我们知道了对应的“脏矩形”，也就是这个圆的包围盒",paraId:19,tocIndex:4},{value:"找到场景中与这个包围盒区域相交的其他图形，这里找到了另一个矩形",paraId:19,tocIndex:4},{value:"使用 ",paraId:19,tocIndex:4},{value:"clearRect",paraId:19,tocIndex:4},{value:" 清除这个“脏矩形”，代替清空整个画布",paraId:19,tocIndex:4},{value:"按照 z-index 依次绘制一个矩形和圆形",paraId:19,tocIndex:4},{value:"在以上求交与区域查询的过程中，我们可以复用剔除方案中的优化手段，例如加速结构。",paraId:20,tocIndex:4},{value:"显然当动态变化的对象数目太多时，该优化手段就失去了意义，试想经过一番计算合并后的“脏矩形”几乎等于整个画布，那还不如直接清空重绘所有对象。因此例如 Pixi.js 这样的 2D 游戏渲染引擎就",paraId:21,tocIndex:4},{value:"不考虑内置",paraId:21,tocIndex:4},{value:"。",paraId:21,tocIndex:4},{value:"但在可视化这类相对静态的场景下就显得有意义了，例如在触发拾取后只更新图表的局部，其余部分保持不变。",paraId:22,tocIndex:4},{value:"我们将该渲染器特性做成了开关，可以随时",paraId:23,tocIndex:4},{value:"根据具体情况关闭",paraId:24,tocIndex:4},{value:"。",paraId:23,tocIndex:4},{value:"以上两种方法当然有不适合的场景，例如希望总览一个大规模图场景的全貌时，无法应用剔除（所有节点/边都在视口内）。拖拽移动整个场景时，“脏矩形”渲染效果也不佳（整个场景都变“脏”了）。",paraId:25,tocIndex:5},{value:"除了使用一些上层的 LOD 手段，例如缩放等级较高时，隐藏掉边和文本（因为也看不清），以此减少绘制命令数量之外，",paraId:26,tocIndex:5},{value:"draw call batching",paraId:26,tocIndex:5},{value:" 是非常合适的。",paraId:26,tocIndex:5},{value:"不同于 Canvas2D / Skia 提供的抽象层次较高的绘制 API，WebGL / WebGPU 提供了更低层次的 API，可以让我们将一批“同类”图形合并成一次绘制命令。在渲染引擎中，常用于渲染类似森林中大量树木这种场景。图场景同样十分契合，场景中包含大量同类但简单的图形（节点、边）。",paraId:27,tocIndex:5},{value:"结合我们的",paraId:28,tocIndex:5},{value:"这个教程",paraId:29,tocIndex:5},{value:"，配合 Chrome Spector.js 插件能看出，一次 draw call 完成了 8k 个节点的绘制，这是性能提升的关键：",paraId:28,tocIndex:5},{value:"通常创建出的 instance 仅具有原图形的部分能力。例如 Babylon.js 只允许每个 instance 在部分变换属性上",paraId:30,tocIndex:5},{value:"有差异",paraId:30,tocIndex:5},{value:"。在 G 中并不需要用户显式声明 instance，按照常规图形创建即可，内部会进行自动合并。",paraId:30,tocIndex:5},{value:"值得一提的是我们使用 SDF 绘制部分 2D 图形例如 Circle、Ellipse、Rect。一方面能减少顶点数目（通常三角化一个圆需要 30+ 三角形，SDF 固定 2 个），另一方面也增加了不同图形合并的可能性。",paraId:31,tocIndex:5},{value:"⚠️ 仅 ",paraId:32,tocIndex:6},{value:"g-webgl",paraId:32,tocIndex:6},{value:" 下生效。",paraId:32,tocIndex:6},{value:"当主线程需要处理较重的交互时，我们可以将 Canvas 的渲染工作交给 Worker 完成，主线程仅负责同步结果。目前很多渲染引擎已经支持，例如 ",paraId:33,tocIndex:6},{value:"Babylon.js",paraId:33,tocIndex:6},{value:"。",paraId:33,tocIndex:6},{value:"为了支持该特性，引擎本身并不需要做很多改造，只要能够保证 ",paraId:34,tocIndex:6},{value:"g-webgl",paraId:34,tocIndex:6},{value:" 能在 Worker 中运行即可。",paraId:34,tocIndex:6},{value:"由于运行在 Worker 环境，用户需要手动处理一些 DOM 相关的事件。",paraId:35,tocIndex:7},{value:"https://unrealartoptimization.github.io/book/pipelines/",paraId:36,tocIndex:8}]},56271:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(69651);const d=[{value:"react 通过 ",paraId:0},{value:"react-reconciler",paraId:0},{value:" 提供了自定义 render 的能力，",paraId:0},{value:"react-g",paraId:0},{value:" 便是一个 react 到 g 的 render。",paraId:0},{value:"react-g",paraId:1},{value:" 目前处于实验状态，欢迎试用和反馈。",paraId:1},{value:"npm i @antv/react-g\n",paraId:2,tocIndex:0},{value:"react-g 提供以下内置组件，可以直接引入使用，属性和原生的 g 对象是一致的:",paraId:3,tocIndex:1},{value:"Container: ",paraId:4,tocIndex:1},{value:"Canvas",paraId:4,tocIndex:1},{value:" and ",paraId:4,tocIndex:1},{value:"Group",paraId:4,tocIndex:1},{value:".",paraId:4,tocIndex:1},{value:"Shape: ",paraId:4,tocIndex:1},{value:"Text",paraId:4,tocIndex:1},{value:", ",paraId:4,tocIndex:1},{value:"Circle",paraId:4,tocIndex:1},{value:", ",paraId:4,tocIndex:1},{value:"Ellipse",paraId:4,tocIndex:1},{value:", ",paraId:4,tocIndex:1},{value:"Image",paraId:4,tocIndex:1},{value:", ",paraId:4,tocIndex:1},{value:"Line",paraId:4,tocIndex:1},{value:", ",paraId:4,tocIndex:1},{value:"Marker",paraId:4,tocIndex:1},{value:", ",paraId:4,tocIndex:1},{value:"Path",paraId:4,tocIndex:1},{value:", ",paraId:4,tocIndex:1},{value:"Polygon",paraId:4,tocIndex:1},{value:" and ",paraId:4,tocIndex:1},{value:"Polyline",paraId:4,tocIndex:1},{value:".",paraId:4,tocIndex:1},{value:"import { Renderer as CanvasRenderer } from '@antv/g-canvas';\nimport { Canvas, Circle } from '@antv/react-g';\nimport { useState } from 'react';\n\nconst renderer = new CanvasRenderer();\n\nconst App = () => {\n    const [size, setSize] = useState(50);\n    return (\n        <Canvas width={600} height={400} renderer={renderer}>\n            <Circle\n                x={100}\n                y={200}\n                r={size}\n                fill=\"#1890FF\"\n                stroke=\"#F04864\"\n                lineWidth={4}\n                onClick={() => {\n                    setSize(100);\n                }}\n            />\n        </Canvas>\n    );\n};\n\nexport default App;\n",paraId:5,tocIndex:2},{value:"import { Renderer as CanvasRenderer } from '@antv/g-canvas';\nimport { Canvas, Circle } from '@antv/react-g';\nimport { useRef, useState } from 'react';\n\nconst renderer = new CanvasRenderer();\n\nconst App = () => {\n    const circleRef = useRef();\n    const [size, setSize] = useState(50);\n    return (\n        <Canvas width={600} height={400} renderer={renderer}>\n            <Circle\n                ref={circleRef}\n                x={100}\n                y={200}\n                r={size}\n                fill=\"#1890FF\"\n                stroke=\"#F04864\"\n                lineWidth={4}\n                onClick={() => {\n                    setSize(100);\n                }}\n            />\n        </Canvas>\n    );\n};\n\nexport default App;\n",paraId:6,tocIndex:3},{value:"render",paraId:7},{value:"将 react-g 组件渲染到任意的 g 实例（Canvas/Group/Shape）中",paraId:8,tocIndex:4},{value:"意味着可以将 react-g 组件渲染到 g2,g6 等其他库中",paraId:8,tocIndex:4},{value:"import { Canvas as GCanvas } from '@antv/g';\nimport { Renderer as CanvasRenderer } from '@antv/g-canvas';\nimport { Circle, render } from '@antv/react-g';\nimport { useState } from 'react';\n\nconst renderer = new CanvasRenderer();\n\nconst CircleComponent = () => {\n    const [size, setSize] = useState(50);\n    return (\n        <Circle\n            x={100}\n            y={200}\n            r={size}\n            fill=\"#1890FF\"\n            stroke=\"#F04864\"\n            lineWidth={4}\n            onMouseenter={() => {\n                setSize(100);\n            }}\n            onMouseleave={() => {\n                setSize(50);\n            }}\n        />\n    );\n};\n\nconst canvas = new GCanvas({\n    container: 'container', // DOM 节点id\n    width: 600,\n    height: 500,\n    renderer,\n});\n\n// canvas can also be group/shape\nrender(<CircleComponent />, canvas);\n",paraId:9,tocIndex:4}]},9260:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(37698);const d=[{value:"在该系列教程中，我们将逐步实现一个简单的可视化场景，展示节点和边，并让它们具备拖拽、拾取等基本交互能力。",paraId:0},{value:"在本节中，我们将学习如何使用",paraId:1},{value:"场景图",paraId:2},{value:"描述场景。",paraId:1},{value:"我们的场景十分简单，包含两个节点，用 ",paraId:3},{value:"Circle",paraId:4},{value:" 实现，连接它们的一条边用 ",paraId:3},{value:"Line",paraId:5},{value:" 实现，其中每个节点上的文本使用 ",paraId:3},{value:"Text",paraId:6},{value:" 实现。",paraId:3},{value:"完整 CodeSandbox 例子",paraId:7},{value:"首先我们从 ",paraId:8,tocIndex:0},{value:"@antv/g",paraId:8,tocIndex:0},{value:" 中引入基础图形 ",paraId:8,tocIndex:0},{value:"Circle",paraId:9,tocIndex:0},{value:"，我们的节点用它来实现：",paraId:8,tocIndex:0},{value:"import { Circle } from '@antv/g';\n",paraId:10,tocIndex:0},{value:"然后我们需要定义该图形的一系列属性：",paraId:11,tocIndex:0},{value:"// 节点1\nconst node1 = new Circle({\n    style: {\n        r: 100, // 半径\n        fill: '#1890FF', // 填充色\n        stroke: '#F04864', // 描边颜色\n        lineWidth: 4, // 描边宽度\n    },\n});\n",paraId:12,tocIndex:0},{value:"同样我们可以创建第二个节点。",paraId:13,tocIndex:0},{value:"我们想在节点上展示描述性文本，同样我们从 ",paraId:14,tocIndex:1},{value:"@antv/g",paraId:14,tocIndex:1},{value:" 中引入基础图形 ",paraId:14,tocIndex:1},{value:"Text",paraId:15,tocIndex:1},{value:"：",paraId:14,tocIndex:1},{value:"import { Text } from '@antv/g';\n\nconst text1 = new Text({\n    style: {\n        text: 'Node1', // 文本内容\n        fontFamily: 'Avenir', // 字体\n        fontSize: 22, // 字号\n        fill: '#fff', // 文本颜色\n        textAlign: 'center', // 水平居中\n        textBaseline: 'middle', // 垂直居中\n    },\n});\n",paraId:16,tocIndex:1},{value:"文本应该是节点的子节点，在场景图中，这种父子关系通过 ",paraId:17,tocIndex:1},{value:"appendChild",paraId:17,tocIndex:1},{value:" 构建：",paraId:17,tocIndex:1},{value:"node1.appendChild(text1);\n",paraId:18,tocIndex:1},{value:"我们只需要设置节点的位置，它的所有子节点（文本）也会跟着移动：",paraId:19,tocIndex:1},{value:"node1.setPosition(200, 200);\n",paraId:20,tocIndex:1},{value:"我们从 ",paraId:21,tocIndex:2},{value:"@antv/g",paraId:21,tocIndex:2},{value:" 中引入基础图形 ",paraId:21,tocIndex:2},{value:"Line",paraId:22,tocIndex:2},{value:"，将两个端点连接起来：",paraId:21,tocIndex:2},{value:"import { Line } from '@antv/g';\n\nconst edge = new Line({\n    style: {\n        x1: 200,\n        y1: 200,\n        x2: 400,\n        y2: 200,\n        stroke: '#1890FF',\n        lineWidth: 2,\n    },\n});\n",paraId:23,tocIndex:2},{value:"至此我们的场景就定义完毕了，在下一节中我们将使用渲染器将场景渲染出来。",paraId:24,tocIndex:2}]},97534:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(47622);const d=[{value:"在该系列教程中，我们将逐步实现一个简单的可视化场景，展示节点和边，并让它们具备拖拽、拾取等基本交互能力。",paraId:0},{value:"在上一节我们定义了一个简单的场景，在本节中，我们将学习如何使用",paraId:1},{value:"渲染器",paraId:2},{value:"完成渲染。",paraId:1},{value:"本节示例",paraId:3},{value:"完整 CodeSandbox 例子",paraId:4},{value:"首先我们需要引入一个或多个渲染器，如果引入了多个，还可以在",paraId:5,tocIndex:0},{value:"运行时切换",paraId:6,tocIndex:0},{value:"。本例中我们只选择了一个 Canvas2D 渲染器：",paraId:5,tocIndex:0},{value:"import { Renderer } from '@antv/g-canvas';\n\nconst renderer = new Renderer();\n",paraId:7,tocIndex:0},{value:"然后我们需要创建画布，使用上面引入的渲染器：",paraId:8,tocIndex:1},{value:"const canvas = new Canvas({\n    container: 'container', // DOM 节点id\n    width: 600, // 画布宽度\n    height: 500, // 画布高度\n    renderer,\n});\n",paraId:9,tocIndex:1},{value:"有了画布，我们可以把场景图中的两个节点和一条边加入画布，当然这一切要等待画布就绪之后。我们有两种方式获知画布何时就绪，一是监听 ",paraId:10,tocIndex:2},{value:"就绪事件",paraId:11,tocIndex:2},{value:"，二是",paraId:10,tocIndex:2},{value:"等待就绪的 Promise 返回",paraId:12,tocIndex:2},{value:"：",paraId:10,tocIndex:2},{value:"canvas.addEventListener(CanvasEvent.READY, () => {\n    canvas.appendChild(node1);\n    canvas.appendChild(node2);\n    canvas.appendChild(edge);\n});\n\n// 或者\nawait canvas.ready;\ncanvas.appendChild(node1);\ncanvas.appendChild(node2);\ncanvas.appendChild(edge);\n",paraId:13,tocIndex:2},{value:"此时就能看到渲染效果了，不过有些奇怪，边出现在了节点之上，甚至挡住了文本：",paraId:14,tocIndex:2},{value:"这个问题是由我们加入画布的各个图形顺序导致，我们最后才将“边”加入画布，根据画家算法，它是最后绘制的，因此出现在了最顶层。",paraId:15,tocIndex:2},{value:"最简单的解决办法就是修改顺序，先绘制边，再绘制节点：",paraId:16,tocIndex:2},{value:"canvas.appendChild(edge);\ncanvas.appendChild(node1);\ncanvas.appendChild(node2);\n",paraId:17,tocIndex:2},{value:"此时效果就正常了： ",paraId:18,tocIndex:2},{value:"或者，我们也可以通过 ",paraId:19,tocIndex:2},{value:"zIndex",paraId:19,tocIndex:2},{value:" 手动调整。",paraId:19,tocIndex:2},{value:"类似 CSS 中的 ",paraId:20,tocIndex:3},{value:"zIndex",paraId:20,tocIndex:3},{value:"，我们可以手动设置两个节点的绘制顺序，让它们比边高（默认为 0）即可：",paraId:20,tocIndex:3},{value:"node1.style.zIndex = 1;\nnode2.style.zIndex = 1;\n",paraId:21,tocIndex:3},{value:"基础图形已经绘制出来了，下面让我们增加一些交互吧。",paraId:22,tocIndex:3}]},59261:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(75076);const d=[{value:"在该系列教程中，我们将逐步实现一个简单的可视化场景，展示节点和边，并让它们具备拖拽、拾取等基本交互能力。",paraId:0},{value:"在本节中，我们将学习如何让图形响应事件 ",paraId:1},{value:"本节示例",paraId:2},{value:"。其中会涉及以下 API：",paraId:1},{value:"使用 ",paraId:3},{value:"addEventListener",paraId:4},{value:" 为图形添加事件监听器：",paraId:3},{value:"使用 ",paraId:3},{value:"style",paraId:5},{value:" 修改图形样式属性",paraId:3},{value:"使用 ",paraId:3},{value:"translateLocal",paraId:6},{value:" 改变节点位置",paraId:3},{value:"完整 CodeSandbox 例子",paraId:7},{value:"我们想让节点 1 响应激活事件：当鼠标移入时将节点变成红色，同时改变鼠标样式，移出后恢复。",paraId:8,tocIndex:0},{value:"和 DOM API 一样，我们通过 ",paraId:9,tocIndex:0},{value:"addEventListener",paraId:10,tocIndex:0},{value:" 给图形增加事件监听器，监听 mouseenter 和 mouseleave 事件：",paraId:9,tocIndex:0},{value:"node1.addEventListener('mouseenter', () => {\n    // 修改图形样式属性\n    node1.style.fill = 'red';\n});\nnode1.addEventListener('mouseleave', () => {\n    // 修改图形样式属性\n    node1.style.fill = '#1890FF';\n});\n",paraId:11,tocIndex:0},{value:"然后我们可以给节点添加 ",paraId:12,tocIndex:0},{value:"cursor",paraId:12,tocIndex:0},{value:" 属性来设置",paraId:12,tocIndex:0},{value:"鼠标悬停样式",paraId:13,tocIndex:0},{value:"，这里使用“手指”形状 ",paraId:12,tocIndex:0},{value:"pointer",paraId:12,tocIndex:0},{value:"：",paraId:12,tocIndex:0},{value:"const node1 = new Circle({\n    style: {\n        //... 省略其他属性\n        cursor: 'pointer',\n    },\n});\n",paraId:14,tocIndex:0},{value:"我们的",paraId:15,tocIndex:0},{value:"事件系统",paraId:16,tocIndex:0},{value:"完全兼容 DOM Event API，这意味着可以使用前端熟悉的 API 实现事件监听器的绑定/解绑、触发自定义事件、事件委托等等功能。除了这些方法名更好记外，在下一节中我们还将看到它的另一大优势。",paraId:15,tocIndex:0},{value:"拖拽是一个常见的交互动作，我们想实现对于节点 1 的拖拽功能，同时改变边的端点位置：",paraId:17,tocIndex:1},{value:"我们当然可以通过组合对基础事件（pointerup、pointermove、pointerdown）的监听来实现拖拽。但这里我们用一种更简单的方法，由于我们的",paraId:18,tocIndex:2},{value:"事件系统",paraId:19,tocIndex:2},{value:"完全兼容 DOM Event API，因此可以直接使用 Web 端现成的拖拽库，例如 ",paraId:18,tocIndex:2},{value:"interact.js",paraId:18,tocIndex:2},{value:" 来完成绝大部分“脏活累活”。而我们只需要做两件事：",paraId:18,tocIndex:2},{value:"传给 interact.js 一个假的上下文 ",paraId:20,tocIndex:2},{value:"canvas.document",paraId:20,tocIndex:2},{value:" 和节点 1，让它以为操作的是真实的 DOM",paraId:20,tocIndex:2},{value:"在 interact.js 的 ",paraId:20,tocIndex:2},{value:"onmove",paraId:20,tocIndex:2},{value:" 回调函数中改变节点和边端点的位置",paraId:20,tocIndex:2},{value:"import interact from 'interactjs';\n\n// 使用 interact.js 实现拖拽\ninteract(node1, {\n    // 直接传入节点1\n    context: canvas.document, // 传入上下文\n}).draggable({\n    onmove: function (event) {\n        // interact.js 告诉我们的偏移量\n        const { dx, dy } = event;\n        // 改变节点1位置\n        node1.translateLocal(dx, dy);\n        // 获取节点1位置\n        const [nx, ny] = node1.getLocalPosition();\n        // 改变边的端点位置\n        edge.style.x1 = nx;\n        edge.style.y1 = ny;\n    },\n});\n",paraId:21,tocIndex:2},{value:"你可能注意到了，在拖拽时鼠标样式自动变成了 ",paraId:22,tocIndex:2},{value:"move",paraId:22,tocIndex:2},{value:" 的形状，这完全是 interact.js 的功劳。之所以能这么做，是因为 ",paraId:22,tocIndex:2},{value:"interact.js",paraId:22,tocIndex:2},{value:" 并不假设自身一定运行在真实的 DOM 环境。换言之，我们可以将 G 的图形伪装成 DOM 来“欺骗”它们。同样的道理，我们也可以直接使用 ",paraId:22,tocIndex:2},{value:"hammer.js",paraId:23,tocIndex:2},{value:" 这样的手势库。",paraId:22,tocIndex:2},{value:"回到 ",paraId:24,tocIndex:3},{value:"onmove",paraId:24,tocIndex:3},{value:" 回调函数中，我们需要改变节点的位置，而偏移量 interact.js 已经告诉我们了：",paraId:24,tocIndex:3},{value:"node1.translateLocal(dx, dy);\n",paraId:25,tocIndex:3},{value:"类似 ",paraId:26,tocIndex:3},{value:"translateLocal",paraId:26,tocIndex:3},{value:" 这样的",paraId:26,tocIndex:3},{value:"变换操作",paraId:27,tocIndex:3},{value:"还有很多，除了平移，还可以进行旋转和缩放。",paraId:26,tocIndex:3},{value:"改变边的端点也很简单，通过修改它的样式属性 ",paraId:28,tocIndex:3},{value:"x1/y1",paraId:28,tocIndex:3},{value:" 就可以完成，可以查看 ",paraId:28,tocIndex:3},{value:"Line",paraId:29,tocIndex:3},{value:" 进一步了解：",paraId:28,tocIndex:3},{value:"edge.style.x1 = nx;\nedge.style.y1 = ny;\n",paraId:30,tocIndex:3},{value:"至此这个简单的场景就完成了，跟随我们的后续教程继续了解场景图、相机吧。",paraId:31,tocIndex:3}]},43322:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(76724);const d=[{value:"通过 ",paraId:0},{value:"g-plugin-3d",paraId:1},{value:" 插件的支持，我们可以绘制 3D 图形，当然渲染器必须指定为 ",paraId:0},{value:"g-webgl",paraId:0},{value:"。",paraId:0},{value:"示例",paraId:2},{value:"创建画布和渲染器与之前的教程完全一致，注册 ",paraId:3,tocIndex:0},{value:"g-plugin-3d",paraId:4,tocIndex:0},{value:" 插件",paraId:3,tocIndex:0},{value:"import { Canvas, CanvasEvent } from '@antv/g';\nimport { Renderer } from '@antv/g-webgl';\nimport { Plugin as Plugin3D } from '@antv/g-plugin-3d';\n\n// create a renderer\nconst renderer = new Renderer();\nrenderer.registerPlugin(new Plugin3D());\n\n// create a canvas\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer,\n});\n",paraId:5,tocIndex:0},{value:"在创建 3D 图形时，需要使用 ",paraId:6,tocIndex:1},{value:"材质",paraId:7,tocIndex:1},{value:" 和 ",paraId:6,tocIndex:1},{value:"几何",paraId:8,tocIndex:1},{value:"，它们都需要使用 GPU 底层资源（Buffer 和 Texture），创建时需要获取 GPU ",paraId:6,tocIndex:1},{value:"Device",paraId:9,tocIndex:1},{value:"：",paraId:6,tocIndex:1},{value:"(async () => {\n    // wait for canvas' initialization complete\n    await canvas.ready;\n\n    // use GPU device\n    const plugin = renderer.getPlugin('device-renderer');\n    const device = plugin.getDevice();\n})();\n",paraId:10,tocIndex:1},{value:"不同于各种各样的 2D 图形（Circle、Rect），3D 图形使用 Mesh（三角网格）描述，它的形状由 ",paraId:11,tocIndex:2},{value:"几何",paraId:12,tocIndex:2},{value:" 定义，外观样式由 ",paraId:11,tocIndex:2},{value:"材质",paraId:13,tocIndex:2},{value:" 定义。例如这里我们使用 ",paraId:11,tocIndex:2},{value:"CubeGeometry",paraId:14,tocIndex:2},{value:" 和 ",paraId:11,tocIndex:2},{value:"MeshBasicMaterial",paraId:15,tocIndex:2},{value:"：",paraId:11,tocIndex:2},{value:"import { MeshBasicMaterial, CubeGeometry, Mesh } from '@antv/g-plugin-3d';\n\n// 立方体几何\nconst cubeGeometry = new CubeGeometry(device, {\n    width: 200,\n    height: 200,\n    depth: 200,\n});\n// 基础材质\nconst basicMaterial = new MeshBasicMaterial(device);\n\nconst cube = new Mesh({\n    style: {\n        fill: '#1890FF',\n        opacity: 1,\n        geometry: cubeGeometry,\n        material: basicMaterial,\n    },\n});\n",paraId:16,tocIndex:2},{value:"创建好的 Mesh 和 2D 基础图形一样，可以进行变换。例如我们使用 \b",paraId:17,tocIndex:3},{value:"setPosition",paraId:17,tocIndex:3},{value:" 设置它的全局坐标：",paraId:17,tocIndex:3},{value:"cube.setPosition(300, 250, 0);\ncanvas.appendChild(cube);\n",paraId:18,tocIndex:3}]},64636:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(7805);const d=[{value:"在本教程中，我们将实现一个简单的 Scale-In 动画效果：",paraId:0},{value:"其中会涉及以下 API，如果你熟悉 CSS Animation 或者 ",paraId:1},{value:"Web Animations API",paraId:1},{value:"，使用时会相当轻松：",paraId:1},{value:"使用 ",paraId:2},{value:"animate",paraId:3},{value:" 创建一个 Animation 对象",paraId:2},{value:"使用 ",paraId:2},{value:"onfinish",paraId:4},{value:" 监听动画结束事件",paraId:2},{value:"最终示例：",paraId:5},{value:"官网示例",paraId:6},{value:"CodeSandbox 示例",paraId:7},{value:"在定义动画效果时，关键帧是一种非常好用的描述方式。通过用户定义对象在某几个“关键”时间点上的状态，渲染引擎自动完成插值让对象的这些属性连续变化。",paraId:8,tocIndex:0},{value:"我们很容易写出 Scale-In 效果对应的 CSS Animation，其中：",paraId:9,tocIndex:0},{value:"使用 ",paraId:10,tocIndex:0},{value:"animation",paraId:10,tocIndex:0},{value:" 定义了一组动画控制参数，例如 duration(0.5s), fill(both), easing 缓动函数",paraId:10,tocIndex:0},{value:"使用 ",paraId:10,tocIndex:0},{value:"keyframes",paraId:10,tocIndex:0},{value:" 定义了一组关键帧，这里对 transform 属性进行动画",paraId:10,tocIndex:0},{value:".scale-in-center {\n    animation: scale-in-center 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;\n}\n@keyframes scale-in-center {\n    0% {\n        transform: scale(0);\n    }\n    100% {\n        transform: scale(1);\n    }\n}\n",paraId:11,tocIndex:0},{value:"如果理解了上述 CSS Animation 写法，那么就很容易将它转换成符合 Web Animations API 的代码：",paraId:12,tocIndex:0},{value:"circle.animate()",paraId:13,tocIndex:0},{value:" 将创建一个 ",paraId:13,tocIndex:0},{value:"Animation",paraId:14,tocIndex:0},{value:" 对象，上面有很多有用的属性和控制方法，我们很快就将看到",paraId:13,tocIndex:0},{value:"该方法拥有两个参数，第一个对应 keyframes，第二个则是动画控制参数",paraId:13,tocIndex:0},{value:"// 为 circle 创建一个 animation 对象\nconst scaleInCenter = circle.animate(\n    [\n        {\n            transform: 'scale(0)', // 起始关键帧\n        },\n        {\n            transform: 'scale(1)', // 结束关键帧\n        },\n    ],\n    {\n        duration: 500, // 持续时间\n        easing: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)', // 缓动函数\n        fill: 'both', // 动画处于非运行状态时，该图形的展示效果\n    },\n);\n",paraId:15,tocIndex:0},{value:"恭喜你！此时这个 circle 已经可以运动起来了。",paraId:16,tocIndex:0},{value:"当我们想获知动画当前的状态，例如是否已经结束，或者想手动控制它的运行状态，例如暂停/恢复时，就需要使用到上一节创建的 Animation 对象。",paraId:17,tocIndex:1},{value:"例如我们想知道动画何时结束，有两种方式实现：",paraId:18,tocIndex:1},{value:"onfinsh",paraId:19,tocIndex:1},{value:" 设置一个回调函数",paraId:20,tocIndex:1},{value:"finished",paraId:21,tocIndex:1},{value:" 该对象是一个 Promise",paraId:20,tocIndex:1},{value:"animation.onfinish = (e) => {\n    console.log('finish!', e.target, e.target.playState);\n};\nanimation.finished.then(() => {\n    console.log('finish promise resolved');\n});\n",paraId:22,tocIndex:1},{value:"当我们想实现一组连续动画时，这个方法很好用。",paraId:23,tocIndex:1},{value:"再比如我们想手动暂停一个运行中的动画，就可以使用 ",paraId:24,tocIndex:1},{value:"pause()",paraId:25,tocIndex:1},{value:"：",paraId:24,tocIndex:1},{value:"animation.pause();\n",paraId:26,tocIndex:1},{value:"除了暂停，",paraId:27,tocIndex:1},{value:"Animation 完整方法",paraId:28,tocIndex:1},{value:"中还包含了恢复、停止、重启、反向播放、设置播放速度（加减速）等。",paraId:27,tocIndex:1},{value:"除了这个简单的 Scale-In 效果，我们还能实现更多复杂效果，例如：",paraId:29,tocIndex:2},{value:"offsetDistance",paraId:30,tocIndex:2},{value:" 属性可以实现",paraId:30,tocIndex:2},{value:"路径动画",paraId:31,tocIndex:2},{value:"lineDashOffset",paraId:30,tocIndex:2},{value:" 属性可以实现",paraId:30,tocIndex:2},{value:"蚂蚁线动画",paraId:32,tocIndex:2},{value:"lineDash",paraId:30,tocIndex:2},{value:" 属性可以实现",paraId:30,tocIndex:2},{value:"笔迹动画",paraId:33,tocIndex:2},{value:"Path 的 ",paraId:30,tocIndex:2},{value:"path",paraId:30,tocIndex:2},{value:" 属性可以实现",paraId:30,tocIndex:2},{value:"形变动画（Morph）",paraId:34,tocIndex:2}]},29115:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(97934);const d=[{value:"Box2D",paraId:0},{value:" 物理引擎提供了一系列针对刚体的仿真计算，例如重力和表面摩擦力。另外，在任意时刻也可以施加外力改变图形的位置和旋转角度，这为我们实现一些基于真实物理规则的布局提供了帮助。",paraId:0},{value:"通过 ",paraId:1},{value:"g-plugin-box2d",paraId:2},{value:" 插件的支持，我们可以给已有的大部分 2D 图形增加物理属性。",paraId:1},{value:"在该",paraId:3},{value:"示例",paraId:4},{value:"中，我们创建了一系列动态物体，让它们进行自由落体，最终停留在“U 形槽”中。",paraId:3},{value:"创建一个渲染器并注册插件：",paraId:5,tocIndex:0},{value:"import { Canvas, CanvasEvent } from '@antv/g';\nimport { Renderer } from '@antv/g-canvas';\nimport { Plugin as PluginBox2D } from '@antv/g-plugin-box2d';\n\nconst renderer = new Renderer();\nconst plugin = new PluginBox2D();\nrenderer.registerPlugin(plugin);\n\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer,\n});\n",paraId:6,tocIndex:0},{value:"此时我们的“物理世界”已经存在默认的重力 ",paraId:7,tocIndex:0},{value:"gravity",paraId:8,tocIndex:0},{value:"，如果要修改它，可以这样做：",paraId:7,tocIndex:0},{value:"const plugin = new PluginBox2D({\n    gravity: [0, 200],\n});\n",paraId:9,tocIndex:0},{value:"我们使用 ",paraId:10,tocIndex:1},{value:"Line",paraId:11,tocIndex:1},{value:" 创建一个平地，需要特别注意 ",paraId:10,tocIndex:1},{value:"rigid",paraId:12,tocIndex:1},{value:" 属性，设置为 ",paraId:10,tocIndex:1},{value:"static",paraId:10,tocIndex:1},{value:" 表明它不受重力等作用力影响：",paraId:10,tocIndex:1},{value:"const ground = new Line({\n    style: {\n        x1: 50,\n        y1: 400,\n        // 省略其他属性\n        rigid: 'static',\n    },\n});\ncanvas.appendChild(ground);\n",paraId:13,tocIndex:1},{value:"接下来我们创建一个受重力影响的“弹力球”，其中：",paraId:14,tocIndex:2},{value:"density",paraId:15,tocIndex:2},{value:" 表示物体密度，单位为千克/立方米",paraId:16,tocIndex:2},{value:"restitution",paraId:17,tocIndex:2},{value:" 表示弹力系数",paraId:16,tocIndex:2},{value:"const circle = new Circle({\n    style: {\n        fill: '#1890FF',\n        r: 50,\n        rigid: 'dynamic',\n        density: 10,\n        restitution: 0.5,\n    },\n});\ncanvas.appendChild(circle);\n",paraId:18,tocIndex:2},{value:"插件会自动完成仿真过程，你可以看到小球自由落体至地面并弹起。",paraId:19,tocIndex:3}]},88094:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(18114);const d=[{value:"相机（Camera）描述了我们观察世界的角度，视点、相机位置都会影响最终的成像。它适用于 2D 和 3D 场景。在创建 Canvas 画布时，我们已经内置了一个默认相机，它使用正交投影，后续可以随时改变它的投影模式以及其他参数。通过控制相机，我们能轻松实现某些过去需要移动整个画布的操作，甚至能实现相机动画。\b",paraId:0},{value:"在之前的教程中，我们已经掌握了如何创建场景、使用渲染器、监听事件。在本教程中，我们将在一个包含数千个图形的复杂场景中，通过相机实现场景的平移和缩放操作，",paraId:1},{value:"g-webgl",paraId:1},{value:" 渲染器将保证交互过程的流畅。",paraId:1},{value:"其中会涉及以下 API：",paraId:2},{value:"使用 ",paraId:3},{value:"getCamera()",paraId:4},{value:" 获取画布相机",paraId:3},{value:"使用 ",paraId:3},{value:"setZoom()",paraId:5},{value:" 设置相机缩放参数",paraId:3},{value:"使用 ",paraId:3},{value:"pan()",paraId:6},{value:" 平移相机",paraId:3},{value:"使用 ",paraId:3},{value:"createLandmark()",paraId:7},{value:" 创建相机动画",paraId:3},{value:"最终示例：",paraId:8},{value:"官网示例",paraId:9},{value:"CodeSandbox 示例",paraId:10},{value:"我们和之前一样创建一个画布，不同的是我们选择 ",paraId:11,tocIndex:0},{value:"g-webgl",paraId:11,tocIndex:0},{value:" 渲染器：",paraId:11,tocIndex:0},{value:"import { Canvas } from '@antv/g';\nimport { Renderer } from '@antv/g-webgl';\n\n// 创建 WebGL 渲染器\nconst webglRenderer = new Renderer();\n\n// 创建画布\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer: webglRenderer,\n});\n",paraId:12,tocIndex:0},{value:"这次我们的场景中包含大量的节点、边以及文本，节点和边的位置信息直接使用预计算的结果，我们通过 fetch 请求这个包含了结果的 JSON 数据：",paraId:13,tocIndex:1},{value:"fetch('https://gw.alipayobjects.com/os/basement_prod/xxxx.json')\n    .then((res) => res.json())\n    .then((data) => {\n        // 使用包含了节点、边位置信息的数据\n    });\n",paraId:14,tocIndex:1},{value:"我们使用 ",paraId:15,tocIndex:1},{value:"Line",paraId:16,tocIndex:1},{value:" 表现边，",paraId:15,tocIndex:1},{value:"Circle",paraId:17,tocIndex:1},{value:" 表现节点，",paraId:15,tocIndex:1},{value:"Text",paraId:18,tocIndex:1},{value:" 表现文本：",paraId:15,tocIndex:1},{value:"// 使用预计算结果渲染边\ndata.edges.forEach(({ startPoint, endPoint }) => {\n    const line = new Line({\n        style: {\n            x1: startPoint.x * 10,\n            y1: startPoint.y * 10,\n            x2: endPoint.x * 10,\n            y2: endPoint.y * 10,\n            stroke: '#1890FF',\n            lineWidth: 3,\n        },\n    });\n\n    canvas.appendChild(line);\n});\n// 省略渲染节点、文本\n",paraId:19,tocIndex:1},{value:"到这里都和之前的教程没有太大不同，接下来我们会给场景增加一些交互。",paraId:20,tocIndex:1},{value:"我们希望给整个场景添加缩放、平移这两个交互，通过相机来实现。",paraId:21,tocIndex:2},{value:"前面提到过，每个画布内置了一个相机，我们可以使用 ",paraId:22,tocIndex:3},{value:"getCamera",paraId:23,tocIndex:3},{value:" 获取画布相机：",paraId:22,tocIndex:3},{value:"const camera = canvas.getCamera();\n",paraId:24,tocIndex:3},{value:"我们希望通过鼠标滚轮实现对于整个场景的缩放，很自然的，我们使用 addEventListener 监听 wheel 事件。在获取到原生滚轮事件对象上携带的 deltaY 信息后，我们调用 ",paraId:25,tocIndex:4},{value:"setZoom()",paraId:26,tocIndex:4},{value:" 设置相机缩放参数，当然通过 ",paraId:25,tocIndex:4},{value:"getZoom()",paraId:27,tocIndex:4},{value:" 可以随时获取这个参数。当这个参数的值大于 1 时代表放大（好比我们拿着一个放大镜观察世界），小于 1 时代表缩小：",paraId:25,tocIndex:4},{value:"// 设置最小和最大缩放比例\nconst minZoom = 0;\nconst maxZoom = Infinity;\ncanvas.addEventListener(\n    'wheel',\n    (e) => {\n        e.preventDefault();\n        let zoom;\n        if (e.deltaY < 0) {\n            zoom = Math.max(\n                minZoom,\n                Math.min(maxZoom, camera.getZoom() / 0.95),\n            );\n        } else {\n            zoom = Math.max(\n                minZoom,\n                Math.min(maxZoom, camera.getZoom() * 0.95),\n            );\n        }\n\n        // 设置相机缩放参数\n        camera.setZoom(zoom);\n    },\n    { passive: false },\n);\n",paraId:28,tocIndex:4},{value:"有了缩放，很自然地我们也想实现利用鼠标拖拽完成场景的平移。在",paraId:29,tocIndex:5},{value:"入门教程",paraId:30,tocIndex:5},{value:"中我们借助 interact.js 实现了节点的拖拽，这里我们使用 hammer.js 帮助我们完成手势操作。",paraId:29,tocIndex:5},{value:"直接将我们的画布传给 hammer.js，并让它监听 pan 事件，得益于对 DOM API 的兼容，我们再次“欺骗”了它。hammer.js 会给事件对象加上 deltaX/Y，即鼠标移动过程中水平和垂直方向上的偏移量：",paraId:31,tocIndex:5},{value:"import Hammer from 'hammerjs';\nconst hammer = new Hammer(canvas);\n// 监听 pan 手势\nhammer.on('pan', (ev) => {\n    // 完成我们的逻辑\n    // ev.deltaX/Y 为水平/垂直方向的偏移量\n});\n",paraId:32,tocIndex:5},{value:"接下来让我们根据偏移量使用 ",paraId:33,tocIndex:5},{value:"pan()",paraId:34,tocIndex:5},{value:" 来平移相机，需要注意的是，当我们向右拖拽鼠标想让场景向右平移时，需要让相机向左移动，这也和我们的生活常识相符：",paraId:33,tocIndex:5},{value:"// 沿水平/垂直方向移动相机\ncamera.pan(-ev.deltaX, -ev.deltaY);\n",paraId:35,tocIndex:5},{value:"最后让我们做一个小小的优化，当放大场景时，我们希望移动的幅度小一点，反之当场景被缩小时，我们希望更快速地进行移动。因此我们可以根据相机当前的缩放参数来实现，使用 ",paraId:36,tocIndex:5},{value:"getZoom()",paraId:37,tocIndex:5},{value:" 获取它：",paraId:36,tocIndex:5},{value:"const zoom = Math.pow(2, camera.getZoom());\ncamera.pan(-ev.deltaX / zoom, -ev.deltaY / zoom);\n",paraId:38,tocIndex:5},{value:"既然平移相机等价于反向操作画布，那前者相比后者的优势是什么呢？",paraId:39,tocIndex:6},{value:"camera.pan(100, 100);\n// 等价于反向移动根节点\ncanvas.document.documentElement.translate(-100, -100);\n",paraId:40,tocIndex:6},{value:"简单来说，当我们改变根节点的位置时，整个画布中的图形都需要重绘。具体到内部实现，每个图形在世界坐标系下的变换矩阵都需要重新计算。把矩阵计算过程放在 Shader 中交给 GPU 完成能带来明显的性能提升，显然只有配合 ",paraId:41,tocIndex:6},{value:"g-webgl",paraId:41,tocIndex:6},{value:" 才能发挥效果。",paraId:41,tocIndex:6},{value:"矩阵计算过程可以分解成相机矩阵和每个图形的模型矩阵。后者是需要考虑父节点，因此当我们改变根节点时，每个图形的模型矩阵都需要在 CPU 端重新计算后传给 GPU，而如果只改变相机矩阵，将极大程度减少 CPU 的运算量：",paraId:42,tocIndex:6},{value:"// MVP 矩阵 = 相机矩阵 * 模型矩阵\nmat4 MVPMatrix = ProjectionViewMatrix * ModelMatrix;\n",paraId:43,tocIndex:6},{value:"除了使用 pan 平移相机，我们还可以进行以下",paraId:44,tocIndex:7},{value:"相机动作",paraId:45,tocIndex:7},{value:"：",paraId:44,tocIndex:7},{value:"dolly()",paraId:46,tocIndex:7},{value:" 沿 n 轴移动相机。正交投影下没有“近大远小”，因此不会对画面产生影响。",paraId:47,tocIndex:7},{value:"rotate()",paraId:48,tocIndex:7},{value:" 按相机方位角旋转，逆时针方向为正。",paraId:47,tocIndex:7},{value:"另外在 3D 场景中，我们还可以使用",paraId:49,tocIndex:7},{value:"透视投影",paraId:50,tocIndex:7},{value:"代替默认的正交投影。",paraId:49,tocIndex:7},{value:"最后，",paraId:51,tocIndex:7},{value:"相机动画",paraId:52,tocIndex:7},{value:"能让我们在不同视角间平滑切换。",paraId:51,tocIndex:7}]},25756:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(11481);const d=[{value:"G 的 API 和 DOM API 尽可能一致，因此 Web 生态中一些面向 DOM API 的库都可以以非常低的成本接入，例如 ",paraId:0},{value:"使用 Hammer.js 手势库",paraId:1},{value:"、",paraId:0},{value:"使用 Interact.js 拖拽库",paraId:2},{value:"。对于它们来说，G 的",paraId:0},{value:"事件 API",paraId:3},{value:" 和 DOM Events API 完全一致：",paraId:0},{value:"import Hammer from 'hammerjs';\n\n// 直接把 G 的 Circle 当成 DOM 元素交给 Hammer.js\nconst hammer = new Hammer(circle);\nhammer.on('press', (e) => {\n    console.log(\"You're pressing me!\");\n    console.log(e.target); // circle\n});\n",paraId:4},{value:"同样的，对于 ",paraId:5},{value:"D3",paraId:5},{value:" 来说，我们完全可以在保留它数据驱动能力的同时，接管它内部默认的 SVG（它也是 DOM API 的一部分）渲染，使用 Canvas 或 WebGL 完成。",paraId:5},{value:"在以下",paraId:6},{value:"示例",paraId:7},{value:"中，我们使用 Fullstack D3 的几个教学例子，在保留绝大部分 D3 风格代码的同时，通过“一行”代码的修改完成渲染 API 的切换，实现 ",paraId:6},{value:"D3 数据处理 + G 渲染",paraId:6},{value:" 的效果。你可以在运行时切换 Canvas、WebGL 和 SVG 的渲染效果：",paraId:6},{value:"还可以直接使用一些风格化渲染插件，例如通过 ",paraId:8},{value:"g-plugin-rough-canvas-renderer",paraId:9},{value:" 对上面的柱形图进行手绘风格改造：",paraId:8},{value:"详见：",paraId:10},{value:"https://observablehq.com/@xiaoiver/d3-rough-barchart",paraId:10},{value:"值得一提的是，最早我是从 ",paraId:11},{value:"Sprite.js",paraId:11},{value:" 中看到这一思路，不过当时它对于 DOM API 的实现完成度还不太高，导致部分 D3 API（例如 join）无法正常使用。",paraId:11},{value:"理论上这也能解决其他基于 SVG 的绘图库的渲染性能问题，当然这种方案也存在一些“限制”。",paraId:12},{value:"示例柱状图来自 ",paraId:13,tocIndex:0},{value:"Fullstack D3",paraId:13,tocIndex:0},{value:"“一行代码”确实有些标题党，毕竟创建 G 画布和渲染器的步骤不能少：",paraId:14,tocIndex:0},{value:"const canvasRenderer = new CanvasRenderer();\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer: canvasRenderer,\n});\n",paraId:15,tocIndex:0},{value:"接下来就是“一行代码”的部分了，现在无需 D3 创建 ",paraId:16,tocIndex:0},{value:"<svg>",paraId:16,tocIndex:0},{value:" 了，我们只需要把 G 场景图的",paraId:16,tocIndex:0},{value:"根节点",paraId:17,tocIndex:0},{value:"交给 D3，",paraId:16,tocIndex:0},{value:"画布",paraId:18,tocIndex:0},{value:"的尺寸在创建时就已经指定好了：",paraId:16,tocIndex:0},{value:"// 改动前：D3 使用 DOM API 创建 `<svg>`\nconst wrapper = d3\n    .select('#wrapper')\n    .append('svg')\n    .attr('width', dimensions.width)\n    .attr('height', dimensions.height);\n\n// 改动后：把 G 场景图的根节点交给 D3\nconst wrapper = d3.select(canvas.document.documentElement);\n",paraId:19,tocIndex:0},{value:"以上就是全部的修改内容了，后续就可以完全使用 D3 语法了。例如创建一个 ",paraId:20,tocIndex:0},{value:"<g>",paraId:20,tocIndex:0},{value:" 并设置样式，G 会让 D3 认为仍然在操作 DOM API：",paraId:20,tocIndex:0},{value:"const bounds = wrapper\n    .append('g')\n    .style(\n        'transform',\n        `translate(${dimensions.margin.left}px, ${dimensions.margin.top}px)`,\n    );\n",paraId:21,tocIndex:0},{value:"或者使用 D3 的",paraId:22,tocIndex:0},{value:"事件机制",paraId:22,tocIndex:0},{value:"增加一些事件交互，例如响应鼠标事件修改柱子颜色：",paraId:22,tocIndex:0},{value:"binGroups\n    .on('mouseenter', function (e) {\n        d3.select(e.target).attr('fill', 'red');\n    })\n    .on('mouseleave', function (e) {\n        d3.select(e.target).attr('fill', 'cornflowerblue');\n    });\n",paraId:23,tocIndex:0},{value:"完整代码",paraId:24},{value:"在使用 D3 以及第三方扩展时，经常需要使用 CSS 选择器，例如 ",paraId:25,tocIndex:1},{value:"d3-annotation",paraId:25,tocIndex:1},{value:" 会使用如下语法：",paraId:25,tocIndex:1},{value:"var group = selection.select('g.annotations');\n",paraId:26,tocIndex:1},{value:"为了能让 ",paraId:27,tocIndex:1},{value:"g.annotations",paraId:27,tocIndex:1},{value:" 这样的 CSS 选择器正常工作，需要使用 ",paraId:27,tocIndex:1},{value:"g-plugin-css-selector",paraId:28,tocIndex:1},{value:" 插件，注册方式如下：",paraId:27,tocIndex:1},{value:"import { Plugin } from '@antv/g-plugin-css-select';\nrenderer.registerPlugin(new Plugin());\n",paraId:29,tocIndex:1},{value:"另外在 D3 项目中经常使用 CSS 样式表，例如该 ",paraId:30,tocIndex:1},{value:"示例",paraId:31,tocIndex:1},{value:" 中使用了 ",paraId:30,tocIndex:1},{value:"d3-annotation",paraId:30,tocIndex:1},{value:"，设置了描边颜色：",paraId:30,tocIndex:1},{value:".annotation path {\n    stroke: var(--accent-color);\n}\n",paraId:32,tocIndex:1},{value:"我们可以使用 G 类似 DOM API 的元素查询方法 ",paraId:33,tocIndex:1},{value:"querySelectorAll",paraId:34,tocIndex:1},{value:"：",paraId:33,tocIndex:1},{value:"const paths = canvas.document.querySelectorAll('.annotation path');\npaths.forEach(() => {});\n",paraId:35,tocIndex:1},{value:"或者继续使用 D3 的选择器语法：",paraId:36,tocIndex:1},{value:"svg.select('.annotation path').style('stroke', 'purple');\n",paraId:37,tocIndex:1},{value:"在说明该方案的限制之前，有必要先了解下背后的原理。我们将从以下方面展开：",paraId:38,tocIndex:2},{value:"什么样的类库可以无缝接入？",paraId:39,tocIndex:2},{value:"G 实现 DOM API 的完成度",paraId:39,tocIndex:2},{value:"其他收益",paraId:39,tocIndex:2},{value:"首先并不是所有基于 DOM API 的类库都能像 ",paraId:40,tocIndex:3},{value:"Hammer.js",paraId:40,tocIndex:3},{value:"、",paraId:40,tocIndex:3},{value:"interact.js",paraId:40,tocIndex:3},{value:"、",paraId:40,tocIndex:3},{value:"D3",paraId:40,tocIndex:3},{value:" 这样“无缝接入” G。或者说，这些适合接入的类库都有一个共同特点，它们并不假定自己处于",paraId:40,tocIndex:3},{value:"真实的浏览器 DOM 环境",paraId:40,tocIndex:3},{value:"中。",paraId:40,tocIndex:3},{value:"我们以 D3 为例，",paraId:41,tocIndex:3},{value:"d3-selection",paraId:41,tocIndex:3},{value:" 在创建 DOM 元素时并不会直接使用 ",paraId:41,tocIndex:3},{value:"window.document",paraId:41,tocIndex:3},{value:"，而是从元素的 ",paraId:41,tocIndex:3},{value:"ownerDocument",paraId:42,tocIndex:3},{value:" 属性上获取，因此只要 G 的图形上也有该同名属性就可以正常运行，而不会调用到浏览器真实的 DOM API：",paraId:41,tocIndex:3},{value:"// @see https://github.com/d3/d3-selection/blob/main/src/creator.js#L6\n// 获取 document\nvar document = this.ownerDocument;\n// 使用 document 创建元素\ndocument.createElement(name);\n",paraId:43,tocIndex:3},{value:"这些类库这么做还有一个好处，那就是适合在 node 端配合 ",paraId:44,tocIndex:3},{value:"jsdom",paraId:44,tocIndex:3},{value:" 运行测试用例（D3 的",paraId:44,tocIndex:3},{value:"做法",paraId:44,tocIndex:3},{value:"）。",paraId:44,tocIndex:3},{value:"因此，如果 ",paraId:45,tocIndex:3},{value:"X6",paraId:45,tocIndex:3},{value:" 未来也想以这种方式接入 G，也需要确保没有类似 ",paraId:45,tocIndex:3},{value:"window.document",paraId:45,tocIndex:3},{value:" 这样的用法。",paraId:45,tocIndex:3},{value:"最后 G 在自身内部实现中，也需要避免“浏览器真实 DOM 环境”这样的假定，例如在",paraId:46,tocIndex:3},{value:"创建画布",paraId:47,tocIndex:3},{value:"时，这样才能运行在 WebWorker 甚至是小程序环境中。",paraId:46,tocIndex:3},{value:"有了适合接入的类库，能否正常运行就要看 G 对于 DOM API 实现的程度了。还是以 D3 为例，在插入元素到文档前会使用 ",paraId:48,tocIndex:4},{value:"compareDocumentPosition",paraId:48,tocIndex:4},{value:" 比较位置，如果 G 没有实现这个 API，运行时就会报错。",paraId:48,tocIndex:4},{value:"可见 G 的核心 API 其实就是轻量版的 ",paraId:49,tocIndex:4},{value:"jsdom",paraId:49,tocIndex:4},{value:"。为什么说是“轻量版”呢，因为很多功能例如 HTML 解析、非内联的 CSS 样式我们都省略了。",paraId:49,tocIndex:4},{value:"目前 G 实现的 DOM API 如下：",paraId:50,tocIndex:4},{value:"Node & Element API",paraId:51,tocIndex:4},{value:"，把 G 的图形“伪装成” 真实的 DOM 元素",paraId:52,tocIndex:4},{value:"Event 系统",paraId:53,tocIndex:4},{value:"，提供完整的事件绑定以及传播流程",paraId:52,tocIndex:4},{value:"Web Animations API 动画系统",paraId:54,tocIndex:4},{value:"，提供命令式的动画能力",paraId:52,tocIndex:4},{value:"CustomElementRegistry",paraId:55,tocIndex:4},{value:"，根据名称创建图形，因此 ",paraId:52,tocIndex:4},{value:"wrapper.append('g')",paraId:52,tocIndex:4},{value:" 这样的 D3 代码实际上创建了 G 的 ",paraId:52,tocIndex:4},{value:"Group",paraId:56,tocIndex:4},{value:"MutationObserver 用于监测元素间结构、属性变化",paraId:52,tocIndex:4},{value:"样式属性计算，因此 D3 中类似 ",paraId:52,tocIndex:4},{value:"el.style('font-size', '1em')",paraId:52,tocIndex:4},{value:" 这样包含相对单位的代码才能运行",paraId:52,tocIndex:4},{value:"D3 的生态是非常庞大的，无缝接入意味着很多能力是开箱即用的。",paraId:57,tocIndex:5},{value:"在该",paraId:58,tocIndex:5},{value:"示例",paraId:59,tocIndex:5},{value:"中，我们使用 ",paraId:58,tocIndex:5},{value:"d3-shape",paraId:58,tocIndex:5},{value:" 和 ",paraId:58,tocIndex:5},{value:"d3-transition",paraId:58,tocIndex:5},{value:" 实现了形变动画：",paraId:58,tocIndex:5},{value:"这不禁让我们思考另一个问题，G 的",paraId:60,tocIndex:5},{value:"动画能力",paraId:61,tocIndex:5},{value:"是否也应该是可插拔的。在上面这个例子中，G 只需要提供渲染能力，对 ",paraId:60,tocIndex:5},{value:"path",paraId:60,tocIndex:5},{value:" 的 ",paraId:60,tocIndex:5},{value:"d",paraId:60,tocIndex:5},{value:" 属性动画完全交给 D3。",paraId:60,tocIndex:5},{value:"我们选择性实现了绝大部分 DOM API，这也意味着放弃了例如 ",paraId:62,tocIndex:7},{value:"innerHTML",paraId:62,tocIndex:7},{value:" 这样的 API：",paraId:62,tocIndex:7},{value:"el.innerHTML = '<div></div>';\n",paraId:63,tocIndex:7},{value:"因此 D3 中的 ",paraId:64,tocIndex:7},{value:"selection.html()",paraId:64,tocIndex:7},{value:" 暂时是无法正常工作的。",paraId:64,tocIndex:7},{value:"如果要实现这个特性，G 需要思考“混合”渲染的问题。目前同一时间只能选择一个渲染器渲染全部图形，而混合渲染要求 HTML 与使用 Canvas / WebGL 渲染的图形共存。考虑到这些混合内容间的渲染次序和交互，并不是一件容易的事。",paraId:65,tocIndex:7},{value:"值得一提的是新版 Google Docs，从官方提供的",paraId:66,tocIndex:7},{value:"示例文档",paraId:66,tocIndex:7},{value:"来看，第一页中包含了两个 SVG 和一个 Canvas。其中主体部分（主要是文字）使用 Canvas / WebGL 绘制，并支持文本选中效果，而图片（右上角、文档内）使用 SVG：",paraId:66,tocIndex:7},{value:"目前 G 也不支持外部样式表，因此 D3 应用中的外部样式表无法生效。",paraId:67,tocIndex:8},{value:"但内联用法是有效的，例如示例中的如下用法：",paraId:68,tocIndex:8},{value:"const barText = binGroups\n    .filter(yAccessor)\n    .append('text')\n    .attr('x', (d) => xScale(d.x0) + (xScale(d.x1) - xScale(d.x0)) / 2)\n    .attr('y', (d) => yScale(yAccessor(d)) - 5)\n    .text(yAccessor)\n    .attr('fill', 'darkgrey')\n    .style('text-anchor', 'middle')\n    .style('font-size', '12px')\n    .style('font-family', 'sans-serif');\n",paraId:69,tocIndex:8},{value:"SVG 中的 ",paraId:70,tocIndex:9},{value:"foreignObject",paraId:70,tocIndex:9},{value:" 允许嵌入 HTML，和 innerHTML 一样，暂时无法支持。",paraId:70,tocIndex:9}]},34986:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(55027);const d=[{value:"⚠️ GPGPU 相关能力需要支持 WebGPU 的浏览器环境（例如 Chrome 94+）。",paraId:0},{value:"在本教程中，我们将尝试使用 GPU 的并行计算能力，实现两个矩阵相乘，相较 CPU 获得 10 倍以上的性能提升。最终效果可以参考这个",paraId:1},{value:"示例",paraId:2},{value:"，矩阵尺寸越大性能提升效果越明显。",paraId:1},{value:"我们很容易写出一个能在 CPU 侧运行的算法，串行计算结果矩阵中每一个元素的值。但仔细想想第二个元素的计算并不依赖第一个元素的计算结果对吗？现在让我们从线程并行的角度来考虑这个问题，我们让每一个线程负责处理一个元素。如果对网格、线程组这些概念还不熟悉，可以参考",paraId:3},{value:"线程、共享内存与同步",paraId:4},{value:"。",paraId:3},{value:"下面我们通过两步完成该计算任务的创建：",paraId:5},{value:"创建画布，使用 WebGPU 渲染器，注册 GPGPU 插件",paraId:6},{value:"获取 Device",paraId:6},{value:"创建 Kernel，编写 Compute Shader",paraId:6},{value:"传入输入数据，获取计算结果",paraId:6},{value:"创建画布，使用渲染器的方式和之前渲染相关的教程并无差别，只是在创建渲染器时，需要确认在支持 WebGPU 的浏览器环境下运行。另外由于不涉及渲染，画布大小我们选择长宽为 1 即可。",paraId:7,tocIndex:0},{value:"import { Canvas, CanvasEvent } from '@antv/g';\nimport { DeviceRenderer, Renderer } from '@antv/g-webgpu';\nimport { Plugin, Kernel } from '@antv/g-plugin-gpgpu';\n\nconst { BufferUsage } = DeviceRenderer;\n\n// 选择目标平台为 WebGPU\nconst renderer = new Renderer();\n// 注册 GPGPU 插件\nrenderer.registerPlugin(new Plugin());\n\n// 创建画布\nconst $wrapper = document.getElementById('container');\nconst canvas = new Canvas({\n    container: $wrapper,\n    width: 1,\n    height: 1,\n    renderer,\n});\n",paraId:8,tocIndex:0},{value:"在创建一个计算任务时，我们需要获取 GPU 设备（Device），用它创建 Buffer 等底层对象。在执行这些操作前，需要确保画布的初始化工作（特别是渲染服务）准备就绪，有两种方式：",paraId:9,tocIndex:1},{value:"监听画布的 ",paraId:10,tocIndex:1},{value:"READY",paraId:11,tocIndex:1},{value:" 事件",paraId:10,tocIndex:1},{value:"等待 ",paraId:10,tocIndex:1},{value:"canvas.ready",paraId:10,tocIndex:1},{value:" 这个 Promise",paraId:10,tocIndex:1},{value:"随后就可以通过渲染器获取 Device：",paraId:12,tocIndex:1},{value:"import { CanvasEvent } from '@antv/g';\n\n// 等待画布准备就绪\ncanvas.addEventListener(CanvasEvent.READY, () => {\n    // 通过渲染器获取 Device\n    const plugin = renderer.getPlugin('device-renderer');\n    const device = plugin.getDevice();\n\n    // 使用 Device 创建 GPU 相关对象，见下节\n});\n\n// 或者\nawait canvas.ready;\nconst plugin = renderer.getPlugin('device-renderer');\nconst device = plugin.getDevice();\n",paraId:13,tocIndex:1},{value:'不同于 CUDA 中的 "single source"（Host 和 Device 代码都用 C++）编写，WebGPU 的 Device 代码需要通过 Compute Shader 使用 ',paraId:14,tocIndex:2},{value:"WGSL",paraId:14,tocIndex:2},{value:" 语言编写。",paraId:14,tocIndex:2},{value:"因此 ",paraId:15,tocIndex:2},{value:"g-plugin-gpgpu",paraId:15,tocIndex:2},{value:" 插件提供了 Kernel 用于描述计算任务，除了传入上一节获取的 ",paraId:15,tocIndex:2},{value:"device",paraId:15,tocIndex:2},{value:"，还需要通过 ",paraId:15,tocIndex:2},{value:"computeShader",paraId:15,tocIndex:2},{value:" 使用字符串描述：",paraId:15,tocIndex:2},{value:"import { Kernel } from '@antv/g-plugin-gpgpu';\n\nconst kernel = new Kernel(device, {\n    computeShader: `...`,\n});\n",paraId:16,tocIndex:2},{value:"回到我们的计算任务：两个矩阵相乘，我们让每一个线程负责最终结果矩阵中一个元素的计算，这样多个线程间就可以完全并行。",paraId:17,tocIndex:2},{value:"首先我们需要使用线性结构（一个数组）描述一个矩阵，前两个元素表示矩阵尺寸（行和列），后面跟着具体每一个元素。我们使用 WGSL 的 ",paraId:18,tocIndex:2},{value:"struct",paraId:18,tocIndex:2},{value:" 定义矩阵这个数据类型（类似 TS 中的 interface），其中的 ",paraId:18,tocIndex:2},{value:"f32",paraId:18,tocIndex:2},{value:" 是 WGSL（强类型语言）中的一种基础数据类型，当我们后续尝试从 Host 侧分配内存时，也要使用与之匹配的类型数组（Float32Array）：",paraId:18,tocIndex:2},{value:"// WGSL\nstruct Matrix {\n  size : vec2<f32>; // 矩阵尺寸（长度为 2 的向量）\n  numbers: array<f32>; // 矩阵元素（长度不固定的数组）\n};\n\n// 如果用 TS 描述\ninterface Matrix {\n  size : [number, number];\n  numbers: number[];\n}\n",paraId:19,tocIndex:2},{value:"然后我们需要定义输入和输出数据结构。我们声明了两个输入矩阵和一个保存计算结果的矩阵，从后往前看通过 ",paraId:20,tocIndex:2},{value:"Matrix",paraId:20,tocIndex:2},{value:" 声明了它们的类型（类似 TS），",paraId:20,tocIndex:2},{value:"<storage, read>",paraId:20,tocIndex:2},{value:" 分别定义了内存的用途和访问模式，其中 ",paraId:20,tocIndex:2},{value:"storage",paraId:20,tocIndex:2},{value:" 描述了内存的用途，而不同的用途又有对应的访问模式（读写）。例如这里三个矩阵都用于存储数据（可以从 Host 侧分配），其中两个输入矩阵为只读，结果矩阵可写：",paraId:20,tocIndex:2},{value:"// 第一个矩阵\n@group(0) @binding(0) var<storage, read> firstMatrix : Matrix;\n// 第二个矩阵\n@group(0) @binding(1) var<storage, read> secondMatrix : Matrix;\n// 结果矩阵\n@group(0) @binding(2) var<storage, read_write> resultMatrix : Matrix;\n",paraId:21,tocIndex:2},{value:"接下来就需要定义具体的算法了，每个线程都会执行相同的 Compute Shader 处理不同的数据（SIMD），这就要求每个线程知道自己的 ID，才能从全局数据中获取自己感兴趣的部分数据。在 WGSL 中通过 main 函数的入参获取，这里我们使用内置变量 ",paraId:22,tocIndex:2},{value:"global_invocation_id",paraId:22,tocIndex:2},{value:"，它的类型是 ",paraId:22,tocIndex:2},{value:"vec3<u32>",paraId:22,tocIndex:2},{value:" ，",paraId:22,tocIndex:2},{value:"xyz",paraId:22,tocIndex:2},{value:" 分量都从 0 开始，三者相乘不能超过 256。",paraId:22,tocIndex:2},{value:"@compute @workgroup_size(${WORKGROUP_SIZE_X}, ${WORKGROUP_SIZE_Y})\nfn main(\n  @builtin(global_invocation_id) global_id : vec3<u32> // 当前线程全局 ID\n) {\n  // 超出结果矩阵的线程直接返回\n  if (global_id.x >= u32(firstMatrix.size.x) || global_id.y >= u32(secondMatrix.size.y)) {\n    return;\n  }\n\n  // 写回结果矩阵尺寸\n  resultMatrix.size = vec2<f32>(firstMatrix.size.x, secondMatrix.size.y);\n\n  let resultCell = vec2<u32>(global_id.x, global_id.y);\n  var result = 0.0;\n  for (var i = 0u; i < u32(firstMatrix.size.y); i = i + 1u) {\n    let a = i + resultCell.x * u32(firstMatrix.size.y);\n    let b = resultCell.y + i * u32(secondMatrix.size.y);\n    result = result + firstMatrix.numbers[a] * secondMatrix.numbers[b];\n  }\n\n  // 结果矩阵中元素位置\n  let index = resultCell.y + resultCell.x * u32(secondMatrix.size.y);\n  // 计算结果写回结果矩阵\n  resultMatrix.numbers[index] = result;\n}\n",paraId:23,tocIndex:2},{value:"定义好了 Kernel，我们需要向它传递输入，结束后获取输出结果。分配内存的工作在 Host 侧执行，通过 Device 创建 Buffer(",paraId:24,tocIndex:3},{value:"createBuffer",paraId:25,tocIndex:3},{value:")，其中 ",paraId:24,tocIndex:3},{value:"usage",paraId:24,tocIndex:3},{value:" 需要与 Compute Shader 中定义的内存用途对应，同时进行内存初始数据的写入。",paraId:24,tocIndex:3},{value:"const firstMatrixBuffer = device.createBuffer({\n    usage: BufferUsage.STORAGE,\n    viewOrSize: firstMatrix, // new Float32Array([2 /* rows */, 4 /* columns */, 1, 2, 3, 4, 5, 6, 7, 8])\n});\nconst secondMatrixBuffer = device.createBuffer({\n    usage: BufferUsage.STORAGE,\n    viewOrSize: secondMatrix,\n});\nconst resultBuffer = device.createBuffer({\n    usage: BufferUsage.STORAGE | BufferUsage.COPY_SRC,\n    viewOrSize: resultMatrix,\n});\n",paraId:26,tocIndex:3},{value:"创建完 Buffer 之后，需要绑定到 Kernel 的指定位置（与 Compute Shader 中的 binding 对应）：",paraId:27,tocIndex:3},{value:"kernel.setBinding(0, firstMatrixBuffer);\nkernel.setBinding(1, secondMatrixBuffer);\nkernel.setBinding(2, resultBuffer);\n",paraId:28,tocIndex:3},{value:"使用 ",paraId:29,tocIndex:3},{value:"dispatch",paraId:29,tocIndex:3},{value:" 可以分配线程网格大小，执行计算管线。在矩阵乘法的例子中，如果线程组的大小为 ",paraId:29,tocIndex:3},{value:"1 * 1",paraId:29,tocIndex:3},{value:"，网格大小就是 ",paraId:29,tocIndex:3},{value:"M * N",paraId:29,tocIndex:3},{value:"：",paraId:29,tocIndex:3},{value:"const x = Math.ceil(firstMatrix[0] / WORKGROUP_SIZE_X);\nconst y = Math.ceil(secondMatrix[1] / WORKGROUP_SIZE_Y);\nkernel.dispatch(x, y);\n",paraId:30,tocIndex:3},{value:"在计算完成后，我们需要读取结果矩阵中的数据，这是一次 GPU 到 CPU 的异步读取操作：",paraId:31,tocIndex:3},{value:"const readback = device.createReadback();\nconst result = await readback.readBuffer(resultBuffer); // Float32Array([...])\n",paraId:32,tocIndex:3},{value:"上述矩阵乘法更多用于演示目的，在图场景中有非常多适合并行的布局和分析算法，我们可以从 CUDA 实现中进行移植，例如：",paraId:33,tocIndex:4},{value:"Fruchterman 布局算法",paraId:34,tocIndex:4},{value:"Pagerank",paraId:35,tocIndex:4},{value:"SSSP 单源最短路径",paraId:36,tocIndex:4},{value:"在图中节点/边数目达到一定规模时会带来非常可观的性能提升效果。以 pagerank 为例，在 1k 节点和 50w 条边的测试数据中，GPU 版本相较 CPU 版本有 100 倍以上的提升（300ms vs 30s）。",paraId:37,tocIndex:4}]},29125:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(57503);const d=[{value:"matter.js",paraId:0},{value:" 物理引擎提供了一系列针对刚体的仿真计算，例如重力和表面摩擦力。另外，在任意时刻也可以施加外力改变图形的位置和旋转角度，这为我们实现一些基于真实物理规则的布局提供了帮助。",paraId:0},{value:"通过 ",paraId:1},{value:"g-plugin-matterjs",paraId:2},{value:" 插件的支持，我们可以给已有的大部分 2D 图形增加物理属性。",paraId:1},{value:"在该",paraId:3},{value:"示例",paraId:4},{value:"中，我们创建了一系列动态物体，让它们进行自由落体，最终停留在“U 形槽”中。",paraId:3},{value:"创建一个渲染器并注册插件：",paraId:5,tocIndex:0},{value:"import { Canvas, CanvasEvent } from '@antv/g';\nimport { Renderer } from '@antv/g-canvas';\nimport { Plugin as PluginMatterjs } from '@antv/g-plugin-matterjs';\n\nconst renderer = new Renderer();\nconst plugin = new PluginMatterjs();\nrenderer.registerPlugin(plugin);\n\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer,\n});\n",paraId:6,tocIndex:0},{value:"在开发时，我们常常希望能把物理引擎中的世界也渲染出来，便于和“现实世界”对照。",paraId:7,tocIndex:1},{value:"matter.js \b 本身支持渲染。开启后配合 ",paraId:8,tocIndex:1},{value:"debugContainer",paraId:9,tocIndex:1},{value:" 可以绘制物理引擎世界中每个对象的 wireframe，便于 debug：",paraId:8,tocIndex:1},{value:"const plugin = new PluginMatterjs({\n    debug: true,\n    debugContainer: document.getElementById('container'),\n    debugCanvasWidth: 600,\n    debugCanvasHeight: 500,\n});\n",paraId:10,tocIndex:1},{value:"例如下图展示了三堵静态墙壁和一些动态物体的 wireframe：",paraId:11,tocIndex:1},{value:"我们使用 ",paraId:12,tocIndex:2},{value:"Line",paraId:13,tocIndex:2},{value:" 创建一个平地，需要特别注意 ",paraId:12,tocIndex:2},{value:"rigid",paraId:14,tocIndex:2},{value:" 属性，设置为 ",paraId:12,tocIndex:2},{value:"static",paraId:12,tocIndex:2},{value:" 表明它不受重力等作用力影响：",paraId:12,tocIndex:2},{value:"const ground = new Line({\n    style: {\n        x1: 50,\n        y1: 400,\n        // 省略其他属性\n        rigid: 'static',\n    },\n});\ncanvas.appendChild(ground);\n",paraId:15,tocIndex:2},{value:"接下来我们创建一个受重力影响的“弹力球”，其中：",paraId:16,tocIndex:3},{value:"density",paraId:17,tocIndex:3},{value:" 表示物体密度，单位为千克/立方米",paraId:18,tocIndex:3},{value:"restitution",paraId:19,tocIndex:3},{value:" 表示弹力系数",paraId:18,tocIndex:3},{value:"const circle = new Circle({\n    style: {\n        fill: '#1890FF',\n        r: 50,\n        rigid: 'dynamic',\n        density: 10,\n        restitution: 0.5,\n    },\n});\ncanvas.appendChild(circle);\n",paraId:20,tocIndex:3},{value:"插件会自动完成仿真过程，你可以看到小球自由落体至地面并弹起。",paraId:21,tocIndex:4},{value:"使用 ",paraId:22,tocIndex:4},{value:"applyForce",paraId:23,tocIndex:4},{value:" 可以向图形施加外力。在该 ",paraId:22,tocIndex:4},{value:"示例",paraId:24,tocIndex:4},{value:" 中，点击按钮可以向 Circle 施加一个 ",paraId:22,tocIndex:4},{value:"[0, 0]",paraId:22,tocIndex:4},{value:" 点处 ",paraId:22,tocIndex:4},{value:"[0, -10]",paraId:22,tocIndex:4},{value:" 的外力，因此受力会向上弹起：",paraId:22,tocIndex:4},{value:"plugin.applyForce(circle, [0, -10], [0, 0]);\n",paraId:25,tocIndex:4}]},59744:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(3259);const d=[{value:"在上一节中我们展示了",paraId:0},{value:"如何接管 D3 的渲染工作",paraId:1},{value:"，我们可以对其他基于 SVG 实现的图表库进行相同的操作。",paraId:0},{value:"Observable Plot",paraId:0},{value:" 就是一个很好的例子。",paraId:0},{value:"该图表库同样支持向 ",paraId:2},{value:"plot()",paraId:2},{value:" 传入 ",paraId:2},{value:"document",paraId:2},{value:" 对象，我们将 G 的 ",paraId:2},{value:"Document",paraId:3},{value:" 对象传入：",paraId:2},{value:"import * as Plot from '@observablehq/plot';\nimport { Canvas } from '@antv/g';\nimport { Renderer } from '@antv/g-canvas';\n\nconst canvasRenderer = new Renderer();\nconst canvas = new Canvas({\n    container: 'container',\n    width: 640,\n    height: 400,\n    renderer: canvasRenderer,\n});\n\nconst chart = Plot.dot(data, {\n    x: 'weight',\n    y: 'height',\n    stroke: 'sex',\n}).plot({\n    // 传入 Document 对象代替 `window.document`\n    document: canvas.document,\n});\n",paraId:4},{value:"值得一提的是我们不需要手动调用 ",paraId:5},{value:"canvas.appendChild()",paraId:5},{value:" 将图表加入画布，Observable Plot 内部完成了这一工作。",paraId:5},{value:"DEMO in CodeSandbox",paraId:6},{value:"下图中上半部分展示了 Observable Plot 原生 SVG 的渲染效果，下半部分展示了使用 ",paraId:7},{value:"g-canvas",paraId:8},{value:" 绘制的效果：",paraId:7},{value:"同样由于接管了渲染层，我们可以使用例如 ",paraId:9},{value:"g-plugin-rough-canvas-renderer",paraId:10},{value:" 这样的插件进行手绘风格改造。",paraId:9},{value:"DEMO in CodeSandbox",paraId:11}]},99707:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(58509);const d=[{value:"插件可以极大程度丰富渲染器的能力，在本教程中我们将使用 ",paraId:0},{value:"g-webgl",paraId:0},{value:" 渲染器，配合 ",paraId:0},{value:"g-plugin-3d",paraId:1},{value:" 插件渲染一个简单的立方体。更多用法可以参考",paraId:0},{value:"插件系统",paraId:2},{value:"。",paraId:0},{value:"其中会涉及以下 API：",paraId:3},{value:"使用 ",paraId:4},{value:"registerPlugin",paraId:5},{value:" 为渲染器注册插件",paraId:4},{value:"使用 ",paraId:4},{value:"getCamera",paraId:6},{value:" 获取画布相机",paraId:4},{value:"使用 ",paraId:4},{value:"setPosition",paraId:7},{value:" 设置相机位置",paraId:4},{value:"最终示例：",paraId:8},{value:"官网示例",paraId:9},{value:"CodeSandbox 示例",paraId:10},{value:"我们使用 ",paraId:11,tocIndex:0},{value:"g-webgl",paraId:11,tocIndex:0},{value:" 渲染器，并为其注册：",paraId:11,tocIndex:0},{value:"g-plugin-3d",paraId:12,tocIndex:0},{value:" 提供 3D 渲染能力",paraId:13,tocIndex:0},{value:"g-plugin-control",paraId:14,tocIndex:0},{value:" 提供交互能力",paraId:13,tocIndex:0},{value:"import { Canvas } from '@antv/g';\nimport { Renderer } from '@antv/g-webgl';\nimport { Plugin as Plugin3D } from '@antv/g-plugin-3d';\nimport { Plugin as PluginControl } from '@antv/g-plugin-control';\n\n// 创建 WebGL 渲染器\nconst webglRenderer = new Renderer();\n\n// 注册 3D 插件\nwebglRenderer.registerPlugin(new Plugin3D());\n// 注册 Control 插件\nwebglRenderer.registerPlugin(new PluginControl());\n\n// 创建画布\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer: webglRenderer,\n});\n",paraId:15,tocIndex:0},{value:"我们创建一个 ",paraId:16,tocIndex:1},{value:"200 * 200 * 200",paraId:16,tocIndex:1},{value:" 的立方体，并通过 ",paraId:16,tocIndex:1},{value:"map",paraId:16,tocIndex:1},{value:" 给它贴个图：",paraId:16,tocIndex:1},{value:"import {\n    MeshBasicMaterial,\n    CubeGeometry,\n    Mesh,\n    Plugin as Plugin3D,\n} from '@antv/g-plugin-3d';\n\nconst cubeGeometry = new CubeGeometry();\nconst basicMaterial = new MeshBasicMaterial({\n    map: 'https://gw.alipayobjects.com/mdn/rms_6ae20b/afts/img/A*_aqoS73Se3sAAAAAAAAAAAAAARQnAQ',\n});\n\nconst cube = new Mesh({\n    style: {\n        fill: '#1890FF',\n        opacity: 1,\n        width: 200,\n        height: 200,\n        depth: 200,\n        geometry: cubeGeometry,\n        material: basicMaterial,\n    },\n});\n\ncanvas.appendChild(cube);\n",paraId:17,tocIndex:1},{value:"然后使用 ",paraId:18,tocIndex:1},{value:"setPosition",paraId:19,tocIndex:1},{value:" 移动它到画布中央：",paraId:18,tocIndex:1},{value:"cube.setPosition(300, 250, 0);\n",paraId:20,tocIndex:1},{value:"现在让我们将相机位置稍稍调整一下，来到立方体的斜上方观察。",paraId:21,tocIndex:2},{value:"使用 ",paraId:22,tocIndex:2},{value:"getCamera",paraId:23,tocIndex:2},{value:" 获取画布相机",paraId:22,tocIndex:2},{value:"使用 ",paraId:22,tocIndex:2},{value:"setPosition",paraId:24,tocIndex:2},{value:" 设置相机位置",paraId:22,tocIndex:2},{value:"const camera = canvas.getCamera();\ncamera.setPosition(300, 0, 500);\n",paraId:25,tocIndex:2},{value:"让立方体旋转和其他基础图形一样，使用 ",paraId:26,tocIndex:3},{value:"rotate",paraId:27,tocIndex:3},{value:" 即可：",paraId:26,tocIndex:3},{value:"canvas.addEventListener(CanvasEvent.AFTER_RENDER, () => {\n    cube.rotate(0, 1, 0); // 绕 Y 轴旋转 1 度\n});\n",paraId:28,tocIndex:3}]},3748:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(79928);const d=[{value:"在大多数场景下，渲染引擎会自动在每一帧重绘，但在部分场景下，我们需要自己决定重绘的时机。",paraId:0},{value:"首先我们需要关闭渲染器的“自动渲染”：",paraId:1},{value:"const webglRenderer = new WebGLRenderer({\n    // 关闭自动渲染\n    enableAutoRendering: false,\n});\n",paraId:2},{value:"然后在合适的实际调用画布的",paraId:3},{value:"重绘方法",paraId:4},{value:"，例如手动在 ",paraId:3},{value:"rAF",paraId:3},{value:" 中调用：",paraId:3},{value:"// create a main loop\nconst tick = () => {\n    // call `render` in each frame\n    canvas.render();\n    requestAnimationFrame(tick);\n};\ntick();\n",paraId:5}]},21518:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(26824);const d=[{value:"场景图",paraId:0},{value:"（SceneGraph）是组织和管理二维/三维虚拟场景的一种数据结构，是一个有向无环图。场景图提供了两大能力：",paraId:0},{value:"描述父子关系",paraId:1},{value:"自动完成基于父子关系的某些复杂级联计算",paraId:1},{value:"在旧版 G 中我们在 ",paraId:2},{value:"Group/Shape",paraId:2},{value:" 上提供了部分相关操作，但存在很多问题，导致上层在使用时存在很多 hack 手段。在新版中，我们参考了 DOM API 和 CSS 选择器，给场景图中的每个节点补全了以下能力，大幅降低学习成本：",paraId:2},{value:"与 DOM API 风格一致的添加/删除节点/属性方法",paraId:3},{value:"与 CSS 选择器类似的节点查询语法",paraId:3},{value:"通过 ",paraId:3},{value:"z-index",paraId:3},{value:" 控制展示次序",paraId:3},{value:"通过 ",paraId:3},{value:"visibility",paraId:3},{value:" 控制可见性",paraId:3},{value:"另外我们参考了 ",paraId:4},{value:"react-three-fiber",paraId:4},{value:"，使用声明式语法定义场景图，便于组件复用。",paraId:4},{value:"试想我们需要构建一个简单的太阳系场景，具有以下层次关系：",paraId:5,tocIndex:0},{value:"太阳系 solarSystem\n   |    |\n   |   太阳 sun\n   |\n 地球轨道 earthOrbit\n   |    |\n   |  地球 earth\n   |\n 月球轨道 moonOrbit\n      |\n     月球 moon\n",paraId:6,tocIndex:0},{value:"在 G 中使用 ",paraId:7,tocIndex:0},{value:"Group",paraId:7,tocIndex:0},{value:" 和 ",paraId:7,tocIndex:0},{value:"Circle",paraId:7,tocIndex:0},{value:" 可以很容易构建出它们的层次关系：",paraId:7,tocIndex:0},{value:"import { Group, Circle } from '@antv/g';\n\nconst solarSystem = new Group({\n    name: 'solarSystem',\n});\nconst earthOrbit = new Group({\n    name: 'earthOrbit',\n});\nconst moonOrbit = new Group({\n    name: 'moonOrbit',\n});\nconst sun = new Circle({\n    name: 'sun',\n    style: {\n        r: 100,\n    },\n});\nconst earth = new Circle({\n    name: 'earth',\n    style: {\n        r: 50,\n    },\n});\nconst moon = new Circle({\n    name: 'moon',\n    style: {\n        r: 25,\n    },\n});\n\nsolarSystem.appendChild(sun);\nsolarSystem.appendChild(earthOrbit);\nearthOrbit.appendChild(earth);\nearthOrbit.appendChild(moonOrbit);\nmoonOrbit.appendChild(moon);\n",paraId:8,tocIndex:0},{value:"⚠️ 此时我们并不需要使用到 ",paraId:9,tocIndex:0},{value:"Canvas",paraId:9,tocIndex:0},{value:"，场景图是一种抽象的数据结构，只有在渲染时才需要与 ",paraId:9,tocIndex:0},{value:"Canvas",paraId:9,tocIndex:0},{value:" 交互。",paraId:9,tocIndex:0},{value:"描述完层次关系，我们通常需要进一步定义场景图中对象的行为。在之前简单的太阳系模型中，我们希望让地球绕着太阳旋转，月亮绕着地球旋转，实时更新它们的位置属性，",paraId:10,tocIndex:0},{value:"DEMO",paraId:11,tocIndex:0},{value:"。但月球的轨迹（下图中红色虚线）计算似乎很复杂。",paraId:10,tocIndex:0},{value:"因此我们需要让月球只需要专心做“绕地球转”这件事，背后涉及父子关系的矩阵计算交给场景图完成。",paraId:12,tocIndex:0},{value:"我们提供了平移、缩放和旋转这三种变换。其中每一种的值又可以分成相对和绝对两种，例如对于平移这种变换，平移到某一个点和基于当前点平移多少距离显然是不同的。和变换的量一样，",paraId:13,tocIndex:1},{value:"坐标系",paraId:13,tocIndex:1},{value:"同样具有相对和绝对的概念，这在之前版本的 G 中并没有解释的很清楚，缺少配套的 API，在使用时有诸多不便。",paraId:13,tocIndex:1},{value:"坐标系可以用来描述场景中物体的位置、旋转和缩放情况，最著名的坐标系是欧式坐标系。在图形学中我们还会使用到重心坐标系。欧式空间可以包含 N 维，在可视化场景中我们只使用二维和三维。",paraId:14,tocIndex:2},{value:"当我们在说“月亮绕着地球转”的时候，实际上已经忽略了地球以外的对象。在月亮的**“局部坐标系”",paraId:15,tocIndex:2},{value:"中，它只是单纯地绕着一个点旋转而已，尽管在整个太阳系这个",paraId:15,tocIndex:2},{value:"“世界坐标系”**下，地球还在绕着太阳旋转，月球最终沿着上面那个复杂轨迹运动。",paraId:15,tocIndex:2},{value:"在二维和三维世界中，都可以使用局部坐标系和世界坐标系的概念，下图来自 ",paraId:16,tocIndex:2},{value:"playcanvas",paraId:16,tocIndex:2},{value:"，左侧为世界坐标系，右侧为局部坐标系： ",paraId:16,tocIndex:2},{value:"世界坐标系被整个场景图内的所有节点共享，因此它有一个固定的原点",paraId:17,tocIndex:2},{value:"(0, 0)",paraId:17,tocIndex:2},{value:"，XYZ 三轴（二维场景中为 XY 轴）的朝向也都是固定的，即使场景中的这个盒子自身发生了旋转，世界坐标系对它来说也不会变化。但对于自身的局部坐标系而言，它的原点首先就不再是 ",paraId:17,tocIndex:2},{value:"(0, 0)",paraId:17,tocIndex:2},{value:" 而是物体自身的位置，坐标轴自然也发生了变化，顾名思义它和物体本身相关联。",paraId:17,tocIndex:2},{value:"试想此时我们让这个盒子“沿 X 轴（红色）平移 10 个单位”，在不同坐标系下含义完全不同。因此当我们想对一个物体进行变换时，首先要指明所处的坐标系。",paraId:18,tocIndex:2},{value:"另外，局部坐标系也被称作",paraId:19,tocIndex:2},{value:"模型坐标系",paraId:19,tocIndex:2},{value:"，在描述模型自身的变换时更方便。在",paraId:19,tocIndex:2},{value:"下图",paraId:19,tocIndex:2},{value:"中放置了两个士兵模型，如果我们想让每一个士兵转一下头，显然在局部坐标系做比较简单，因为“转动”这个变换就是相对于每个模型的头部而言的。 ",paraId:19,tocIndex:2},{value:"对于平移操作，我们提供了局部/世界坐标系下，移动绝对/相对距离的 API：",paraId:20,tocIndex:3},{value:"名称",paraId:21,tocIndex:3},{value:"参数",paraId:21,tocIndex:3},{value:"返回值",paraId:21,tocIndex:3},{value:"备注",paraId:21,tocIndex:3},{value:"translate",paraId:21,tocIndex:3},{value:"[number, number]",paraId:21,tocIndex:3},{value:"无",paraId:21,tocIndex:3},{value:"在 ",paraId:21,tocIndex:3},{value:"世界坐标系",paraId:21,tocIndex:3},{value:" 下，相对当前位置移动",paraId:21,tocIndex:3},{value:"translateLocal",paraId:21,tocIndex:3},{value:"[number, number]",paraId:21,tocIndex:3},{value:"无",paraId:21,tocIndex:3},{value:"在 ",paraId:21,tocIndex:3},{value:"局部坐标系",paraId:21,tocIndex:3},{value:" 下，相对当前位置移动",paraId:21,tocIndex:3},{value:"setPosition",paraId:21,tocIndex:3},{value:"[number, number]",paraId:21,tocIndex:3},{value:"无",paraId:21,tocIndex:3},{value:"设置 ",paraId:21,tocIndex:3},{value:"世界坐标系",paraId:21,tocIndex:3},{value:" 下的位置",paraId:21,tocIndex:3},{value:"setLocalPosition",paraId:21,tocIndex:3},{value:"[number, number]",paraId:21,tocIndex:3},{value:"无",paraId:21,tocIndex:3},{value:"设置 ",paraId:21,tocIndex:3},{value:"局部坐标系",paraId:21,tocIndex:3},{value:" 下的位置",paraId:21,tocIndex:3},{value:"getPosition",paraId:21,tocIndex:3},{value:"无",paraId:21,tocIndex:3},{value:"[number, number]",paraId:21,tocIndex:3},{value:"获取 ",paraId:21,tocIndex:3},{value:"世界坐标系",paraId:21,tocIndex:3},{value:" 下的位置",paraId:21,tocIndex:3},{value:"getLocalPosition",paraId:21,tocIndex:3},{value:"无",paraId:21,tocIndex:3},{value:"[number, number]",paraId:21,tocIndex:3},{value:"获取 ",paraId:21,tocIndex:3},{value:"局部坐标系",paraId:21,tocIndex:3},{value:" 下的位置",paraId:21,tocIndex:3},{value:"和平移不同，我们无法提供 ",paraId:22,tocIndex:4},{value:"setScale",paraId:22,tocIndex:4},{value:" 这样设置世界坐标系下缩放的方法，因此全局坐标系下缩放是只读的，这在 Unity 中称之为 ",paraId:22,tocIndex:4},{value:"lossyScale",paraId:22,tocIndex:4},{value:"。",paraId:22,tocIndex:4},{value:"名称",paraId:23,tocIndex:4},{value:"参数",paraId:23,tocIndex:4},{value:"返回值",paraId:23,tocIndex:4},{value:"备注",paraId:23,tocIndex:4},{value:"scaleLocal",paraId:23,tocIndex:4},{value:"[number, number]",paraId:23,tocIndex:4},{value:"无",paraId:23,tocIndex:4},{value:"在 ",paraId:23,tocIndex:4},{value:"局部坐标系",paraId:23,tocIndex:4},{value:" 下，相对当前缩放比例继续缩放",paraId:23,tocIndex:4},{value:"setLocalScale",paraId:23,tocIndex:4},{value:"[number, number]",paraId:23,tocIndex:4},{value:"无",paraId:23,tocIndex:4},{value:"设置 ",paraId:23,tocIndex:4},{value:"局部坐标系",paraId:23,tocIndex:4},{value:" 下的缩放比例",paraId:23,tocIndex:4},{value:"getScale",paraId:23,tocIndex:4},{value:"无",paraId:23,tocIndex:4},{value:"[number, number]",paraId:23,tocIndex:4},{value:"获取 ",paraId:23,tocIndex:4},{value:"世界坐标系",paraId:23,tocIndex:4},{value:" 下的缩放比例",paraId:23,tocIndex:4},{value:"getLocalScale",paraId:23,tocIndex:4},{value:"无",paraId:23,tocIndex:4},{value:"[number, number]",paraId:23,tocIndex:4},{value:"获取 ",paraId:23,tocIndex:4},{value:"局部坐标系",paraId:23,tocIndex:4},{value:" 下的缩放比例",paraId:23,tocIndex:4},{value:"在 3D 场景中，旋转可以用矩阵、轴角、欧拉角和四元数表示，它们彼此之间可以互相转换。虽然考虑到未来的扩展性，在 G 内部实现中我们使用了四元数。",paraId:24,tocIndex:5},{value:"名称",paraId:25,tocIndex:5},{value:"参数",paraId:25,tocIndex:5},{value:"返回值",paraId:25,tocIndex:5},{value:"备注",paraId:25,tocIndex:5},{value:"rotateLocal",paraId:25,tocIndex:5},{value:"number",paraId:25,tocIndex:5},{value:"无",paraId:25,tocIndex:5},{value:"在 ",paraId:25,tocIndex:5},{value:"局部坐标系",paraId:25,tocIndex:5},{value:" 下，旋转一定的欧拉角，顺时针方向为正，单位为 ",paraId:25,tocIndex:5},{value:"degree",paraId:25,tocIndex:5},{value:"rotate",paraId:25,tocIndex:5},{value:"number",paraId:25,tocIndex:5},{value:"无",paraId:25,tocIndex:5},{value:"在 ",paraId:25,tocIndex:5},{value:"世界坐标系",paraId:25,tocIndex:5},{value:" 下，旋转一定的欧拉角",paraId:25,tocIndex:5},{value:"setEulerAngles",paraId:25,tocIndex:5},{value:"number",paraId:25,tocIndex:5},{value:"无",paraId:25,tocIndex:5},{value:"设置 ",paraId:25,tocIndex:5},{value:"世界坐标系",paraId:25,tocIndex:5},{value:" 下的欧拉角",paraId:25,tocIndex:5},{value:"setLocalEulerAngles",paraId:25,tocIndex:5},{value:"number",paraId:25,tocIndex:5},{value:"无",paraId:25,tocIndex:5},{value:"设置 ",paraId:25,tocIndex:5},{value:"局部坐标系",paraId:25,tocIndex:5},{value:" 下的欧拉角",paraId:25,tocIndex:5},{value:"setLocalRotation",paraId:25,tocIndex:5},{value:"quat",paraId:25,tocIndex:5},{value:"无",paraId:25,tocIndex:5},{value:"设置 ",paraId:25,tocIndex:5},{value:"局部坐标系",paraId:25,tocIndex:5},{value:" 下的四元数",paraId:25,tocIndex:5},{value:"setRotation",paraId:25,tocIndex:5},{value:"quat",paraId:25,tocIndex:5},{value:"无",paraId:25,tocIndex:5},{value:"设置 ",paraId:25,tocIndex:5},{value:"世界坐标系",paraId:25,tocIndex:5},{value:" 下的四元数",paraId:25,tocIndex:5},{value:"getEulerAngles",paraId:25,tocIndex:5},{value:"无",paraId:25,tocIndex:5},{value:"number",paraId:25,tocIndex:5},{value:"获取 ",paraId:25,tocIndex:5},{value:"世界坐标系",paraId:25,tocIndex:5},{value:" 下的欧拉角",paraId:25,tocIndex:5},{value:"getLocalEulerAngles",paraId:25,tocIndex:5},{value:"无",paraId:25,tocIndex:5},{value:"number",paraId:25,tocIndex:5},{value:"获取 ",paraId:25,tocIndex:5},{value:"局部坐标系",paraId:25,tocIndex:5},{value:" 下的欧拉角",paraId:25,tocIndex:5},{value:"getLocalRotation",paraId:25,tocIndex:5},{value:"无",paraId:25,tocIndex:5},{value:"quat",paraId:25,tocIndex:5},{value:"获取 ",paraId:25,tocIndex:5},{value:"局部坐标系",paraId:25,tocIndex:5},{value:" 下的四元数",paraId:25,tocIndex:5},{value:"getRotation",paraId:25,tocIndex:5},{value:"无",paraId:25,tocIndex:5},{value:"quat",paraId:25,tocIndex:5},{value:"获取 ",paraId:25,tocIndex:5},{value:"世界坐标系",paraId:25,tocIndex:5},{value:" 下的四元数",paraId:25,tocIndex:5},{value:"上面的旋转方法都以自身位置为旋转中心，如果我们想让节点绕任意一个点旋转，可以给它创建一个父节点，将父节点移动到某个点后再旋转：",paraId:26,tocIndex:5},{value:"下面我们会完成上述太阳系的例子，让地球绕着太阳旋转，让月亮绕着地球旋转。",paraId:27,tocIndex:5},{value:"首先设置太阳系在世界坐标系下的位置，基于场景图内的父子关系，太阳、地球轨道、地球、月球轨道和月球都被移动到了 ",paraId:28,tocIndex:6},{value:"(300, 250)",paraId:28,tocIndex:6},{value:"，如下图（左）所示：",paraId:28,tocIndex:6},{value:"// 设置太阳系的位置\nsolarSystem.setPosition(300, 250);\n",paraId:29,tocIndex:6},{value:"保持太阳位置不变，我们沿 X 轴移动地球轨道 100，同样地球、月球轨道和月球也都被移动到了世界坐标系下",paraId:30,tocIndex:6},{value:"(400, 250)",paraId:30,tocIndex:6},{value:"，如下图（中）所示：",paraId:30,tocIndex:6},{value:"earthOrbit.translate(100, 0);\n// earthOrbit.getLocalPosition() --\x3e (100, 0)\n// earthOrbit.getPosition() --\x3e (400, 250)\n",paraId:31,tocIndex:6},{value:"然后我们移动月球轨道，如下图（右）所示：",paraId:32,tocIndex:6},{value:"moonOrbit.translate(100, 0);\n",paraId:33,tocIndex:6},{value:"最后在每一帧中，我们分别让太阳系和地球轨道在局部坐标系中沿 Z 轴旋转 1 度（你也可以让地球轨道转的更快点）：",paraId:34,tocIndex:6},{value:"solarSystem.rotateLocal(1);\nearthOrbit.rotateLocal(1);\n",paraId:35,tocIndex:6},{value:"对于每个节点来说，只需要使用上述变换方法，就像月球只需要绕着地球转，场景图在背后会依据父子关系计算出世界坐标系下它的位置。因此我们不建议使用类似 ",paraId:36,tocIndex:6},{value:"get/setMatrix()",paraId:36,tocIndex:6},{value:" 这样手动设置矩阵的方法。",paraId:36,tocIndex:6},{value:"在场景图中，我们需要构建父子关系，快速获取父子节点，有时还需要在子树中查询某一类型的节点列表。为此，我们参考 DOM API 中的 ",paraId:37,tocIndex:7},{value:"Node 接口",paraId:37,tocIndex:7},{value:" 在节点上定义了一系列属性与方法，同时提供了类似 CSS 选择器的节点查询方法，最大程度减少学习成本。",paraId:37,tocIndex:7},{value:"名称",paraId:38,tocIndex:8},{value:"属性/方法",paraId:38,tocIndex:8},{value:"返回值",paraId:38,tocIndex:8},{value:"备注",paraId:38,tocIndex:8},{value:"parentNode",paraId:38,tocIndex:8},{value:"属性",paraId:38,tocIndex:8},{value:"Group / null",paraId:38,tocIndex:8},{value:"父节点（如有）",paraId:38,tocIndex:8},{value:"children",paraId:38,tocIndex:8},{value:"属性",paraId:38,tocIndex:8},{value:"Group[]",paraId:38,tocIndex:8},{value:"子节点列表",paraId:38,tocIndex:8},{value:"firstChild",paraId:38,tocIndex:8},{value:"属性",paraId:38,tocIndex:8},{value:"Group / null",paraId:38,tocIndex:8},{value:"返回子节点列表中第一个节点（如有）",paraId:38,tocIndex:8},{value:"lastChild",paraId:38,tocIndex:8},{value:"属性",paraId:38,tocIndex:8},{value:"Group / null",paraId:38,tocIndex:8},{value:"返回子节点列表中最后一个节点（如有）",paraId:38,tocIndex:8},{value:"nextSibling",paraId:38,tocIndex:8},{value:"属性",paraId:38,tocIndex:8},{value:"Group / null",paraId:38,tocIndex:8},{value:"返回后一个兄弟节点（如有）",paraId:38,tocIndex:8},{value:"previousSibling",paraId:38,tocIndex:8},{value:"属性",paraId:38,tocIndex:8},{value:"Group / null",paraId:38,tocIndex:8},{value:"返回前一个兄弟节点（如有）",paraId:38,tocIndex:8},{value:"contains",paraId:38,tocIndex:8},{value:"方法",paraId:38,tocIndex:8},{value:"boolean",paraId:38,tocIndex:8},{value:"子树中是否包含某个节点（入参）",paraId:38,tocIndex:8},{value:"参考 CSS 选择器，我们提供了以下查询方法，查询范围是当前节点的",paraId:39,tocIndex:9},{value:"整棵子树",paraId:39,tocIndex:9},{value:"，并不仅仅是直接的子节点列表，而是所有子孙节点。",paraId:39,tocIndex:9},{value:"名称",paraId:40,tocIndex:9},{value:"参数",paraId:40,tocIndex:9},{value:"返回值",paraId:40,tocIndex:9},{value:"备注",paraId:40,tocIndex:9},{value:"getElementById",paraId:40,tocIndex:9},{value:"(id: string)",paraId:40,tocIndex:9},{value:"Group / null",paraId:40,tocIndex:9},{value:"通过 ",paraId:40,tocIndex:9},{value:"id",paraId:40,tocIndex:9},{value:" 查询子节点",paraId:40,tocIndex:9},{value:"getElementsByName",paraId:40,tocIndex:9},{value:"(name: string)",paraId:40,tocIndex:9},{value:"Group[]",paraId:40,tocIndex:9},{value:"通过 ",paraId:40,tocIndex:9},{value:"name",paraId:40,tocIndex:9},{value:" 查询子节点列表",paraId:40,tocIndex:9},{value:"getElementsByClassName",paraId:40,tocIndex:9},{value:"(className: string)",paraId:40,tocIndex:9},{value:"Group[]",paraId:40,tocIndex:9},{value:"通过 ",paraId:40,tocIndex:9},{value:"className",paraId:40,tocIndex:9},{value:" 查询子节点列表",paraId:40,tocIndex:9},{value:"getElementsByTagName",paraId:40,tocIndex:9},{value:"(tagName: string)",paraId:40,tocIndex:9},{value:"Group[]",paraId:40,tocIndex:9},{value:"通过 ",paraId:40,tocIndex:9},{value:"tagName",paraId:40,tocIndex:9},{value:" 查询子节点列表",paraId:40,tocIndex:9},{value:"querySelector",paraId:40,tocIndex:9},{value:"(selector: string)",paraId:40,tocIndex:9},{value:"Group / null",paraId:40,tocIndex:9},{value:"查询满足条件的第一个子节点",paraId:40,tocIndex:9},{value:"querySelectorAll",paraId:40,tocIndex:9},{value:"(selector: string)",paraId:40,tocIndex:9},{value:"Group[]",paraId:40,tocIndex:9},{value:"查询满足条件的所有子节点列表",paraId:40,tocIndex:9},{value:"下面我们以上面太阳系的例子，演示如何使用这些查询方法。",paraId:41,tocIndex:9},{value:"solarSystem.getElementsByName('sun');\n// [sun]\n\nsolarSystem.getElementsByTagName('circle');\nsolarSystem.getElementsByTagName(Shape.CIRCLE);\n// [sun, earth, moon]\n\nsolarSystem.querySelector('[name=sun]');\n// sun\n\nsolarSystem.querySelectorAll('[r=25]');\n// [moon]\n",paraId:42,tocIndex:9},{value:"名称",paraId:43,tocIndex:10},{value:"参数",paraId:43,tocIndex:10},{value:"返回值",paraId:43,tocIndex:10},{value:"备注",paraId:43,tocIndex:10},{value:"appendChild",paraId:43,tocIndex:10},{value:"(group: Group)",paraId:43,tocIndex:10},{value:"Group",paraId:43,tocIndex:10},{value:"添加子节点，返回添加的节点",paraId:43,tocIndex:10},{value:"insertBefore",paraId:43,tocIndex:10},{value:"(group: Group, reference?: Group)",paraId:43,tocIndex:10},{value:"Group",paraId:43,tocIndex:10},{value:"添加子节点，在某个子节点之前（如有），返回添加的节点",paraId:43,tocIndex:10},{value:"removeChild",paraId:43,tocIndex:10},{value:"(group: Group)",paraId:43,tocIndex:10},{value:"Group",paraId:43,tocIndex:10},{value:"删除子节点，返回被删除的节点",paraId:43,tocIndex:10},{value:"名称",paraId:44,tocIndex:11},{value:"参数",paraId:44,tocIndex:11},{value:"返回值",paraId:44,tocIndex:11},{value:"备注",paraId:44,tocIndex:11},{value:"getAttribute",paraId:44,tocIndex:11},{value:"(name: string)",paraId:44,tocIndex:11},{value:"null / any",paraId:44,tocIndex:11},{value:"根据属性名获取属性值",paraId:44,tocIndex:11},{value:"setAttribute",paraId:44,tocIndex:11},{value:"(name: string, value: any)",paraId:44,tocIndex:11},{value:"无",paraId:44,tocIndex:11},{value:"设置属性值",paraId:44,tocIndex:11},{value:"⚠️ 兼容旧版 ",paraId:45,tocIndex:11},{value:"attr(name: string, value?: any)",paraId:45,tocIndex:11},{value:"，获取以及设置属性值。",paraId:45,tocIndex:11},{value:"名称",paraId:46,tocIndex:13},{value:"参数",paraId:46,tocIndex:13},{value:"返回值",paraId:46,tocIndex:13},{value:"备注",paraId:46,tocIndex:13},{value:"hide",paraId:46,tocIndex:13},{value:"无",paraId:46,tocIndex:13},{value:"无",paraId:46,tocIndex:13},{value:"隐藏节点",paraId:46,tocIndex:13},{value:"show",paraId:46,tocIndex:13},{value:"无",paraId:46,tocIndex:13},{value:"无",paraId:46,tocIndex:13},{value:"展示节点",paraId:46,tocIndex:13},{value:"另外我们也可以通过 ",paraId:47,tocIndex:13},{value:"visibility",paraId:47,tocIndex:13},{value:" 属性控制：",paraId:47,tocIndex:13},{value:"const group = new Group();\n\ngroup.hide();\n// or group.setAttribute('visibility', false);\n\ngroup.show();\n// or group.setAttribute('visibility', true);\n",paraId:48,tocIndex:13},{value:"类似 CSS，我们可以通过 ",paraId:49,tocIndex:14},{value:"zIndex",paraId:49,tocIndex:14},{value:" 属性控制渲染次序，有两点需要注意：",paraId:49,tocIndex:14},{value:"只会影响渲染顺序，并不会改变场景图中的节点结构",paraId:50,tocIndex:14},{value:"只在当前上下文内生效",paraId:50,tocIndex:14},{value:"名称",paraId:51,tocIndex:14},{value:"参数",paraId:51,tocIndex:14},{value:"返回值",paraId:51,tocIndex:14},{value:"备注",paraId:51,tocIndex:14},{value:"setZIndex",paraId:51,tocIndex:14},{value:"number",paraId:51,tocIndex:14},{value:"无",paraId:51,tocIndex:14},{value:"设置 ",paraId:51,tocIndex:14},{value:"zIndex",paraId:51,tocIndex:14},{value:"toFront",paraId:51,tocIndex:14},{value:"无",paraId:51,tocIndex:14},{value:"无",paraId:51,tocIndex:14},{value:"置顶",paraId:51,tocIndex:14},{value:"toBack",paraId:51,tocIndex:14},{value:"无",paraId:51,tocIndex:14},{value:"无",paraId:51,tocIndex:14},{value:"置底",paraId:51,tocIndex:14},{value:"const group = new Group();\n\ngroup.setZIndex(100);\n// or group.setAttribute('zIndex', 100);\n",paraId:52,tocIndex:14},{value:"场景图的层次结构非常适合使用声明式语法描述，参考 ",paraId:53,tocIndex:15},{value:"react-three-fiber",paraId:53,tocIndex:15},{value:"，我们也可以为 G 实现一个 ",paraId:53,tocIndex:15},{value:"React Renderer",paraId:53,tocIndex:15},{value:"，它具有以下优势：",paraId:53,tocIndex:15},{value:"声明式语法便于描述层次结构",paraId:54,tocIndex:15},{value:"便于组件复用",paraId:54,tocIndex:15},{value:"天生容易和 React 生态结合",paraId:54,tocIndex:15},{value:"使用声明式语法定义场景图结构，省略了大量对于 ",paraId:55,tocIndex:16},{value:"appendChild",paraId:55,tocIndex:16},{value:" 的手动调用",paraId:55,tocIndex:16},{value:"如果需要调用 ",paraId:55,tocIndex:16},{value:"Group",paraId:55,tocIndex:16},{value:" 上的方法，可以使用 ",paraId:55,tocIndex:16},{value:"useRef",paraId:55,tocIndex:16},{value:" 获取引用",paraId:55,tocIndex:16},{value:"提供例如 ",paraId:55,tocIndex:16},{value:"useFrame",paraId:55,tocIndex:16},{value:" 这样的 hook，完成动画",paraId:55,tocIndex:16},{value:'import React, { useRef, useState } from \'react\';\nimport { Group, Circle, useFrame } from \'@antv/react-g-fiber\';\n\nconst SolarSystem = () => {\n    // 创建对于 Group 的引用\n    const solarSystem = useRef();\n    const earthOrbit = useRef();\n\n    // 每一帧调用\n    useFrame(() => {\n        solarSystem.rotateLocal(1);\n        earthOrbit.rotateLocal(1);\n    });\n\n    const [hovered, setHover] = useState(false);\n\n    return;\n    <Group name="solarSystem" ref={solarSystem} position={[300, 250]}>\n        <Circle name="sun" r={100} />\n        <Group name="earthOrbit" ref={earthOrbit} localPosition={[100, 0]}>\n            <Circle name="earth" r={50} />\n            <Group name="moonOrbit" localPosition={[100, 0]}>\n                <Circle\n                    name="moon"\n                    r={25}\n                    fill={hovered ? \'yellow\' : \'red\'}\n                    onPointerOver={(event) => setHover(true)}\n                    onPointerOut={(event) => setHover(false)}\n                />\n            </Group>\n        </Group>\n    </Group>;\n};\n',paraId:56,tocIndex:16},{value:"在渲染组件时才需要指定渲染引擎：",paraId:57,tocIndex:17},{value:"import ReactDOM from 'react-dom';\nimport { Canvas } from '@antv/react-g-fiber';\nimport { SolarSystem } from './SolarSystem';\n\nReactDOM.render(\n    <Canvas width={600} height={500} renderer=\"webgl\">\n        <SolarSystem />\n    </Canvas>,\n    document.getElementById('root'),\n);\n",paraId:58,tocIndex:17},{value:"在实际使用中，如何将场景图中的节点与 HTML 结合是一个问题，尤其当 HTML 变得复杂时，就不仅仅是一个 HUD 问题了：",paraId:59,tocIndex:18},{value:"Canvas/WebGL 可以渲染类似按钮这样的简单组件，但类似输入框、表单这样的复杂组件成本太高",paraId:60,tocIndex:18},{value:"SVG 虽然可以使用 ",paraId:60,tocIndex:18},{value:"foreignObject",paraId:60,tocIndex:18},{value:"，兼顾基础图形和 HTML 的渲染，但存在性能问题",paraId:60,tocIndex:18},{value:"因此我们应该让渲染引擎做它们擅长的事情：让 Canvas/WebGL 高效地绘制基础图形，让 HTML 来渲染复杂组件。两者之间的",paraId:61,tocIndex:18},{value:"联动",paraId:61,tocIndex:18},{value:"才是我们该关心的问题。",paraId:61,tocIndex:18},{value:"参考 ",paraId:62,tocIndex:18},{value:"drei",paraId:62,tocIndex:18},{value:" 我们可以提供一个 HTML 容器节点。在渲染时该节点会被 G 跳过，但它的位置依然会通过场景图计算，只是最终通过修改 CSS 样式生效：",paraId:62,tocIndex:18},{value:"import { Group, Circle, HTML } from '@antv/react-g-fiber';\n\nconst SolarSystem = () => (\n    <Group>\n        <Circle r={100} />\n        <HTML prepend>\n            <h1>hello</h1>\n            <p>world</p>\n        </HTML>\n    </Group>\n);\n",paraId:63,tocIndex:18},{value:"该容器中的内容会添加在 ",paraId:64,tocIndex:18},{value:"<canvas>",paraId:64,tocIndex:18},{value:" 之后。但毕竟是特殊节点，一些会功能受限，例如：",paraId:64,tocIndex:18},{value:"无法通过 ",paraId:65,tocIndex:18},{value:"z-index",paraId:65,tocIndex:18},{value:" 让它夹在两个 ",paraId:65,tocIndex:18},{value:"Circle",paraId:65,tocIndex:18},{value:" 之间",paraId:65,tocIndex:18},{value:"无法在内部嵌套其他基础图形节点",paraId:65,tocIndex:18},{value:"选择兼容 DOM API 与 CSS 选择器，除了降低学习成本，还有一个很大的好处，那就是很容易与一些已有生态结合，例如 D3，因为大家的节点定义都是基于统一的接口。",paraId:66,tocIndex:19},{value:"SpriteJS 就是这么做的，节点描述、处理逻辑仍由 D3 完成，渲染则替换成了自身实现的 Canvas/WebGL： ",paraId:67,tocIndex:19},{value:"https://spritejs.org/demo/#/d3/bar",paraId:67,tocIndex:19},{value:"虽然旧版 G 4.0 中提供的场景图相关功能并不完整，但毕竟上层 G2、G6 也使用了一部分 API，我们会尽可能兼容它们。",paraId:68,tocIndex:20},{value:"由于之前变换方法不全，因此 G6 使用了 ",paraId:69,tocIndex:21},{value:"@antv/matrix-util",paraId:69,tocIndex:21},{value:"，让用户可以通过 ",paraId:69,tocIndex:21},{value:"get/setMatrix",paraId:69,tocIndex:21},{value:" 直接操作变换矩阵：",paraId:69,tocIndex:21},{value:"import { transform } from '@antv/matrix-util';\ntransform(m, [\n    ['t', x, y], // translate with vector (x, y)\n    ['r', Math.PI], // rotate\n    ['s', 2, 2], // scale at x-axis and y-axis\n]);\n",paraId:70,tocIndex:21},{value:"我们建议去除该依赖，直接使用节点的变换方法：",paraId:71,tocIndex:21},{value:"group\n    .translate(x, y)\n    .rotateLocal(180) // rotate in degrees\n    .scaleLocal(2, 2);\n",paraId:72,tocIndex:21},{value:"场景图应该能够脱离渲染引擎存在，这样在描述组件时才不需要考虑具体渲染引擎（",paraId:73,tocIndex:22},{value:"g-canvas/svg/webgl",paraId:73,tocIndex:22},{value:"）。因此不再建议使用 ",paraId:73,tocIndex:22},{value:"canvas.addGroup",paraId:73,tocIndex:22},{value:" 和 ",paraId:73,tocIndex:22},{value:"canvas.addShape",paraId:73,tocIndex:22},{value:" 这样的方法。",paraId:73,tocIndex:22},{value:"// 不建议使用旧版\nimport { Canvas } from 'g-canvas';\nconst canvas = new Canvas();\nconst circle = canvas.addShape('circle', { style: { r: 25 } });\n\n// 建议使用新版\n// 定义组件\nimport { Circle, Canvas } from '@antv/g';\nconst circle = new Circle({ style: { r: 25 } });\n// 渲染组件\nconst canvas = new Canvas({});\ncanvas.appendChild(circle);\n",paraId:74,tocIndex:22},{value:"G6 使用了 ",paraId:75,tocIndex:23},{value:"find",paraId:75,tocIndex:23},{value:" 方法查询符合条件的节点：",paraId:75,tocIndex:23},{value:"group.find((element) => element.get('className') === 'link-point-left');\n",paraId:76,tocIndex:23},{value:"这类简单的查询可以使用 ",paraId:77,tocIndex:23},{value:"getElementsByClassName",paraId:77,tocIndex:23},{value:" 或者 ",paraId:77,tocIndex:23},{value:"queryAllSelector",paraId:77,tocIndex:23},{value:" 代替：",paraId:77,tocIndex:23},{value:"group.getElementsByClassName('link-point-left');\n// or\ngroup.queryAllSelector('.link-point-left');\n",paraId:78,tocIndex:23},{value:"但要注意，和 DOM API 一致，查询范围不仅仅局限在直接的子节点列表，而是一整棵子树。",paraId:79,tocIndex:23},{value:"修复了旧版 ",paraId:80,tocIndex:24},{value:"z-index",paraId:80,tocIndex:24},{value:" 的 bug，API 不变。",paraId:80,tocIndex:24},{value:"World vs Local Space. Why do we need them both?",paraId:81,tocIndex:25},{value:"PlayCanvas Docs - Manipulating Entities",paraId:81,tocIndex:25},{value:"What dose 'lossyScale' actually means?",paraId:81,tocIndex:25}]},25746:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(98921);const d=[{value:"有了",paraId:0},{value:"场景图",paraId:1},{value:"的知识，在本教程中我们来创造一个“太阳系”，月球绕着地球转、地球绕着太阳转。",paraId:0},{value:"其中会涉及以下 API：",paraId:2},{value:"使用 ",paraId:3},{value:"appendChild",paraId:4},{value:" 创建场景中各个节点的父子关系",paraId:3},{value:"使用 ",paraId:3},{value:"translate",paraId:5},{value:" 移动节点",paraId:3},{value:"使用 ",paraId:3},{value:"rotate",paraId:6},{value:" 让节点旋转",paraId:3},{value:"使用 ",paraId:3},{value:"getElementsByName",paraId:7},{value:" 在场景图中查询节点",paraId:3},{value:"使用 ",paraId:3},{value:"addEventListener",paraId:8},{value:" 监听画布事件",paraId:3},{value:"最终示例：",paraId:9},{value:"官网示例",paraId:10},{value:"CodeSandbox 示例",paraId:11},{value:"它具有以下层次关系：",paraId:12,tocIndex:0},{value:"太阳系 solarSystem\n   |    |\n   |   太阳 sun\n   |\n 地球轨道 earthOrbit\n   |    |\n   |  地球 earth\n   |\n 月球轨道 moonOrbit\n      |\n     月球 moon\n",paraId:13,tocIndex:0},{value:"从 ",paraId:14,tocIndex:0},{value:"@antv/g",paraId:14,tocIndex:0},{value:" 核心包中引入基础对象 ",paraId:14,tocIndex:0},{value:"Group",paraId:15,tocIndex:0},{value:" 和 ",paraId:14,tocIndex:0},{value:"Circle",paraId:16,tocIndex:0},{value:"。前者无可渲染实体，仅表示逻辑上的“容器”概念，适合“太阳系”、“地球轨道”、“月球轨道”这样的抽象概念，而后者用来表现太阳、地球和月球。当我们想表示“从属”关系时，就可以使用 ",paraId:14,tocIndex:0},{value:"appendChild",paraId:14,tocIndex:0},{value:"，例如“太阳属于太阳系”：",paraId:14,tocIndex:0},{value:"import { Group, Circle } from '@antv/g';\n\n// 太阳系\nconst solarSystem = new Group({\n    name: 'solarSystem',\n});\n// 地球轨道\nconst earthOrbit = new Group({\n    name: 'earthOrbit',\n});\n// 月球轨道\nconst moonOrbit = new Group({\n    name: 'moonOrbit',\n});\n// 太阳\nconst sun = new Circle({\n    name: 'sun',\n    style: {\n        r: 100,\n    },\n});\n// 地球\nconst earth = new Circle({\n    name: 'earth',\n    style: {\n        r: 50,\n    },\n});\n// 月球\nconst moon = new Circle({\n    name: 'moon',\n    style: {\n        r: 25,\n    },\n});\n\n// 太阳属于太阳系\nsolarSystem.appendChild(sun);\n// 地球轨道也属于太阳系\nsolarSystem.appendChild(earthOrbit);\nearthOrbit.appendChild(earth);\nearthOrbit.appendChild(moonOrbit);\nmoonOrbit.appendChild(moon);\n",paraId:17,tocIndex:0},{value:"后续随时可以通过 ",paraId:18,tocIndex:0},{value:"getElementsByName",paraId:19,tocIndex:0},{value:" 在场景图中查询节点：",paraId:18,tocIndex:0},{value:"canvas.getElementsByName('sun'); // [sun]\n",paraId:20,tocIndex:0},{value:"此时我们使用 ",paraId:21,tocIndex:1},{value:"setPosition",paraId:22,tocIndex:1},{value:" 将整个太阳系移动到画布中央，基于场景图内的父子关系，太阳、地球轨道、地球、月球轨道和月球都被移动到了 ",paraId:21,tocIndex:1},{value:"(300, 250)",paraId:21,tocIndex:1},{value:"，如下图（左）所示：",paraId:21,tocIndex:1},{value:"// 设置太阳系的位置\nsolarSystem.setPosition(300, 250);\n",paraId:23,tocIndex:1},{value:"保持太阳位置不变，我们沿 X 轴移动地球轨道 100，同样地球、月球轨道和月球也都被移动到了世界坐标系下",paraId:24,tocIndex:1},{value:"(400, 250)",paraId:24,tocIndex:1},{value:"，如下图（中）所示：",paraId:24,tocIndex:1},{value:"earthOrbit.translate(100, 0);\n// earthOrbit.getLocalPosition() --\x3e (100, 0)\n// earthOrbit.getPosition() --\x3e (400, 250)\n",paraId:25,tocIndex:1},{value:"然后我们移动月球轨道，如下图（右）所示：",paraId:26,tocIndex:1},{value:"moonOrbit.translate(100, 0);\n",paraId:27,tocIndex:1},{value:"现在我们需要让地球和月球都旋转起来。首先使用 ",paraId:28,tocIndex:2},{value:"addEventListener",paraId:29,tocIndex:2},{value:" 给画布添加一个事件监听器，监听 ",paraId:28,tocIndex:2},{value:"AFTER_RENDER",paraId:30,tocIndex:2},{value:" 事件，该事件会在每一帧渲染完毕后触发。然后我们分别让太阳系和地球轨道在局部坐标系中沿 Z 轴旋转 1 度（你也可以让地球轨道转的更快点）：",paraId:28,tocIndex:2},{value:"import { CanvasEvent } from '@antv/g';\n\n// 当画布每一帧渲染完毕时...\ncanvas.addEventListener(CanvasEvent.AFTER_RENDER, () => {\n    // 太阳系自转\n    solarSystem.rotateLocal(1);\n    // 地球轨道自转\n    earthOrbit.rotateLocal(1);\n});\n",paraId:31,tocIndex:2}]},82776:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(53280);const d=[{value:"通过场景图描述待渲染对象后，我们需要将它们交给渲染器。使用何种渲染器由用户按需引入，并且可以在运行时切换。",paraId:0},{value:"目前我们提供了多种",paraId:1,tocIndex:0},{value:"渲染器",paraId:2,tocIndex:0},{value:"，用户可以像插件一样按需引入，但至少需要一种：",paraId:1,tocIndex:0},{value:"import { Renderer as CanvasRenderer } from '@antv/g-canvas';\nimport { Renderer as WebGLRenderer } from '@antv/g-webgl';\n",paraId:3,tocIndex:0},{value:"这样在创建",paraId:4,tocIndex:0},{value:"画布",paraId:5,tocIndex:0},{value:"时可以选择引入的渲染器之一，例如我们引入了 Canvas 和 WebGL 渲染器，就可以在两者之间选择：",paraId:4,tocIndex:0},{value:"import { Canvas } from '@antv/g';\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    // renderer: new CanvasRenderer(),\n    renderer: new WebGLRenderer(),\n});\n",paraId:6,tocIndex:0},{value:"很多渲染引擎会为用户选择默认渲染器，例如 Pixi.js 会优先使用 WebGL，如果不支持则降级成 Canvas。在 G 中这个选择权交给用户。",paraId:7,tocIndex:0},{value:"如果引入了多个渲染器，可以在运行时切换。目前 G 官网中的所有 DEMO 都可以在 ",paraId:8,tocIndex:1},{value:"renderer",paraId:8,tocIndex:1},{value:" 面板中切换，并不会中断动画效果。再比如 G6 中可以通过节点和边的数目动态判断，是否需要切换到 WebGL 渲染器。",paraId:8,tocIndex:1},{value:"import { Renderer as WebGLRenderer } from '@antv/g-webgl';\nimport { Renderer as SvgRenderer } from '@antv/g-svg';\n\nconst webglRenderer = new WebGLRenderer();\nconst svgRenderer = new SvgRenderer();\n\nif (tooManyShapes) {\n    canvas.setRenderer(webglRenderer);\n} else {\n    canvas.setRenderer(svgRenderer);\n}\n",paraId:9,tocIndex:1}]},47443:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(38177);const d=[{value:"Yoga",paraId:0},{value:" 是 Facebook 提供的跨平台布局引擎，基于 Flex，属性和 CSS Flex 完全一致，因此也可以阅读 ",paraId:0},{value:"MDN flex 布局的基本概念",paraId:0},{value:" 获取更多概念知识。",paraId:0},{value:"通过 ",paraId:1},{value:"g-plugin-yoga",paraId:2},{value:" 插件的支持，我们可以给已有 2D 图形增加 Flex 属性。",paraId:1},{value:"在该",paraId:3},{value:"示例",paraId:4},{value:"中，我们创建了一个常见的自适应布局效果：",paraId:3},{value:"创建一个渲染器并注册插件：",paraId:5,tocIndex:0},{value:"import { Canvas, CanvasEvent } from '@antv/g';\nimport { Renderer } from '@antv/g-canvas';\nimport { Plugin as PluginYoga } from '@antv/g-plugin-yoga';\n\nconst renderer = new Renderer();\nconst plugin = new PluginYoga();\nrenderer.registerPlugin(plugin);\n\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer,\n});\n",paraId:6,tocIndex:0},{value:"我们使用 ",paraId:7,tocIndex:1},{value:"Rect",paraId:8,tocIndex:1},{value:" 创建一个淡蓝色背景容器。",paraId:7,tocIndex:1},{value:"首先通过 ",paraId:9,tocIndex:1},{value:"display: 'flex'",paraId:9,tocIndex:1},{value:" 将它声明为一个 Flex 容器。目前我们仅支持 ",paraId:9,tocIndex:1},{value:"Rect",paraId:10,tocIndex:1},{value:" 和 ",paraId:9,tocIndex:1},{value:"Group",paraId:11,tocIndex:1},{value:" 作为 Flex 容器，详见",paraId:9,tocIndex:1},{value:"声明 Flex 容器",paraId:12,tocIndex:1},{value:"。",paraId:9,tocIndex:1},{value:"然后使用 ",paraId:13,tocIndex:1},{value:"flexDirection",paraId:14,tocIndex:1},{value:" 属性让子元素竖向排列。",paraId:13,tocIndex:1},{value:"最后使用 ",paraId:15,tocIndex:1},{value:"padding",paraId:16,tocIndex:1},{value:" 在四周留白：",paraId:15,tocIndex:1},{value:"const root = new Rect({\n  id: 'root',\n  style: {n\n    fill: '#C6E5FF',\n    width: 500,\n    height: 300,\n    x: 50,\n    y: 50,\n    display: 'flex', // 声明为 Flex 容器\n    flexDirection: 'column',\n    padding: [10, 10, 10, 10],\n  },\n});\ncanvas.appendChild(root);\n",paraId:17,tocIndex:1},{value:"接下来我们往容器中添加第一个元素，一个固定高度的 Header。",paraId:18,tocIndex:2},{value:"注意宽度我们使用了百分比 ",paraId:19,tocIndex:2},{value:"width: '100%'",paraId:19,tocIndex:2},{value:"，即父元素（淡蓝色容器）的宽度。",paraId:19,tocIndex:2},{value:"const topPanel = new Rect({\n    style: {\n        fill: 'white',\n        stroke: 'grey',\n        lineWidth: 1,\n        opacity: 0.8,\n        width: '100%',\n        height: 60,\n        marginBottom: 10,\n    },\n});\n",paraId:20,tocIndex:2},{value:"固定 Header 之后，我们希望下方区域占满容器的剩余空间。",paraId:21,tocIndex:3},{value:"这里我们创建了一个 ",paraId:22,tocIndex:3},{value:"Group",paraId:23,tocIndex:3},{value:"，没有继续使用 ",paraId:22,tocIndex:3},{value:"Rect",paraId:24,tocIndex:3},{value:" 的原因是我们不希望它作为容器本身被渲染出来。",paraId:22,tocIndex:3},{value:"使用 ",paraId:25,tocIndex:3},{value:"flexGrow",paraId:26,tocIndex:3},{value:" 这样它的高度会根据父容器自适应，同时声明自身也是一个 Flex 容器，后续会添加更多子元素。",paraId:25,tocIndex:3},{value:"const bottomPanel = new Group({\n    style: {\n        display: 'flex',\n        width: '100%',\n        flexGrow: 1,\n    },\n});\n",paraId:27,tocIndex:3},{value:"接下来我们继续划分刚创建的下方区域，这次创建一个水平方向的两栏布局。",paraId:28,tocIndex:4},{value:"bottomPanel.appendChild(leftPanel);\nbottomPanel.appendChild(rightPanel);\n",paraId:29,tocIndex:4},{value:"居中也是一个常见的需求，例如顶部 Header 中使用 ",paraId:30,tocIndex:5},{value:"justifyContent",paraId:31,tocIndex:5},{value:" 和 ",paraId:30,tocIndex:5},{value:"alignItems",paraId:32,tocIndex:5},{value:" 实现：",paraId:30,tocIndex:5},{value:"const topPanel = new Rect({\n    style: {\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n    },\n});\ntopPanel.appendChild(\n    new Text({\n        style: {\n            fontFamily: 'PingFang SC',\n            fontSize: 24,\n            fill: '#1890FF',\n            text: '1',\n        },\n    }),\n);\n",paraId:33,tocIndex:5}]},17657:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(11495);const d=[{value:" ",paraId:0},{value:" ",paraId:1},{value:" ",paraId:2},{value:" ",paraId:2},{value:" ",paraId:2},{value:"G 作为 AntV 底层的渲染引擎，致力于为上层产品提供一致、高性能的 2D / 3D 图形渲染能力，适配 Web 端全部底层渲染 API（Canvas2D / SVG / WebGL / WebGPU / CanvasKit）。特别的，针对图场景下适合并行计算的算法提供 GPGPU 支持。",paraId:3},{value:"\n  ",paraId:4},{value:"易用的 API",paraId:5,tocIndex:0},{value:"。其中图形、事件系统兼容 DOM Element & Event API，动画系统兼容 Web Animations API。可以以极低的成本适配 Web 端已有的生态例如 D3、Hammer.js 手势库等。",paraId:5,tocIndex:0},{value:"适配多种渲染环境",paraId:6,tocIndex:0},{value:"。支持 Canvas2D / SVG / WebGL / WebGPU / CanvasKit 以及运行时切换，并支持服务端渲染。",paraId:6,tocIndex:0},{value:"高性能的渲染与计算",paraId:7,tocIndex:0},{value:"。为可并行算法提供基于 WebGPU 的 GPGPU 支持。",paraId:7,tocIndex:0},{value:"webgpu-graph",paraId:8,tocIndex:0},{value:" 使用 GPU 加速的图分析算法库。",paraId:7,tocIndex:0},{value:"可扩展的插件机制以及丰富的插件集：",paraId:9,tocIndex:0},{value:"渲染相关\n",paraId:10,tocIndex:0},{value:"g-plugin-canvas-renderer",paraId:11,tocIndex:0},{value:" 基于 Canvas2D 渲染 2D 图形",paraId:12,tocIndex:0},{value:"g-plugin-canvaskit-renderer",paraId:13,tocIndex:0},{value:" 基于 ",paraId:12,tocIndex:0},{value:"Skia",paraId:12,tocIndex:0},{value:" 渲染 2D 图形",paraId:12,tocIndex:0},{value:"g-plugin-svg-renderer",paraId:14,tocIndex:0},{value:" 基于 SVG 渲染 2D 图形",paraId:12,tocIndex:0},{value:"g-plugin-device-renderer",paraId:15,tocIndex:0},{value:" 基于 GPUDevice 渲染 2D 图形",paraId:12,tocIndex:0},{value:"g-plugin-html-renderer",paraId:16,tocIndex:0},{value:" 渲染 DOM 元素",paraId:12,tocIndex:0},{value:"g-plugin-3d",paraId:17,tocIndex:0},{value:" 基于 g-plugin-device-renderer 扩展 3D 能力",paraId:12,tocIndex:0},{value:"g-plugin-rough-canvas-renderer",paraId:18,tocIndex:0},{value:" 使用 ",paraId:12,tocIndex:0},{value:"rough.js",paraId:12,tocIndex:0},{value:" 和 Canvas2D 进行手绘风格渲染",paraId:12,tocIndex:0},{value:"g-plugin-rough-svg-renderer",paraId:19,tocIndex:0},{value:" 使用 ",paraId:12,tocIndex:0},{value:"rough.js",paraId:12,tocIndex:0},{value:" 和 SVG 进行手绘风格渲染",paraId:12,tocIndex:0},{value:"拾取\n",paraId:10,tocIndex:0},{value:"g-plugin-canvas-picker",paraId:20,tocIndex:0},{value:" 基于 Canvas2D",paraId:21,tocIndex:0},{value:"g-plugin-svg-picker",paraId:22,tocIndex:0},{value:" 基于 SVG",paraId:21,tocIndex:0},{value:"无障碍\n",paraId:10,tocIndex:0},{value:"g-plugin-a11y",paraId:23,tocIndex:0},{value:" 提供文本提取、Screen Reader、键盘导航等无障碍功能",paraId:24,tocIndex:0},{value:"交互\n",paraId:10,tocIndex:0},{value:"g-plugin-dom-interaction",paraId:25,tocIndex:0},{value:" 基于 DOM API 绑定事件",paraId:26,tocIndex:0},{value:"g-plugin-control",paraId:27,tocIndex:0},{value:" 为 3D 场景提供相机交互",paraId:26,tocIndex:0},{value:"g-plugin-dragndrop",paraId:28,tocIndex:0},{value:" 基于 PointerEvents 提供 Drag 'n' Drop",paraId:26,tocIndex:0},{value:"g-plugin-annotation",paraId:29,tocIndex:0},{value:" 提供基础图形的绘制和编辑能力，类似 Fabric.js 和 Konva.js",paraId:26,tocIndex:0},{value:"物理引擎\n",paraId:10,tocIndex:0},{value:"g-plugin-box2d",paraId:30,tocIndex:0},{value:" 基于 Box2D",paraId:31,tocIndex:0},{value:"g-plugin-matterjs",paraId:32,tocIndex:0},{value:" 基于 matter.js",paraId:31,tocIndex:0},{value:"g-plugin-physx",paraId:33,tocIndex:0},{value:" 基于 PhysX",paraId:31,tocIndex:0},{value:"布局引擎\n",paraId:10,tocIndex:0},{value:"g-plugin-yoga",paraId:34,tocIndex:0},{value:" 基于 Yoga 提供 Flex 布局能力",paraId:35,tocIndex:0},{value:"GPGPU\n",paraId:10,tocIndex:0},{value:"g-plugin-gpgpu",paraId:36,tocIndex:0},{value:" 基于 WebGPU 提供 GPGPU 能力",paraId:37,tocIndex:0},{value:"CSS 选择器\n",paraId:10,tocIndex:0},{value:"g-plugin-css-select",paraId:38,tocIndex:0},{value:" 支持使用 CSS 选择器在场景图中检索",paraId:39,tocIndex:0},{value:"完整 ",paraId:40,tocIndex:0},{value:"API Spec",paraId:41,tocIndex:0},{value:"。",paraId:40,tocIndex:0},{value:"目前我们支持 CDN 和 NPM Module 两种使用方式。",paraId:42,tocIndex:1},{value:"首先在 HTML 中引入 G 的核心和渲染器 UMD：",paraId:43,tocIndex:2},{value:'\x3c!-- G 核心 --\x3e\n<script\n    src="https://unpkg.com/@antv/g/dist/index.umd.min.js"\n    type="application/javascript"\n><\/script>\n\x3c!-- G 渲染器，支持 Canvas2D/SVG/WebGL --\x3e\n<script\n    src="https://unpkg.com/@antv/g-canvas/dist/index.umd.min.js"\n    type="application/javascript"\n><\/script>\n\x3c!-- <script src="https://unpkg.com/@antv/g-svg/dist/index.umd.min.js" type="application/javascript"><\/script>\n<script src="https://unpkg.com/@antv/g-webgl/dist/index.umd.min.js" type="application/javascript"><\/script> --\x3e\n',paraId:44,tocIndex:2},{value:"然后就可以在 ",paraId:45,tocIndex:2},{value:"window.G",paraId:45,tocIndex:2},{value:" 的命名空间下使用 ",paraId:45,tocIndex:2},{value:"Canvas",paraId:46,tocIndex:2},{value:"、",paraId:45,tocIndex:2},{value:"Circle",paraId:47,tocIndex:2},{value:" 这样的核心基础对象以及 ",paraId:45,tocIndex:2},{value:"Canvas2D.Renderer",paraId:48,tocIndex:2},{value:" 这样的渲染器：",paraId:45,tocIndex:2},{value:"// 从核心包中引入画布、Circle 等对象\nconst { Circle, Canvas, CanvasEvent } = window.G;\n\n// 创建一个渲染器，这里使用 Canvas2D\nconst canvasRenderer = new window.G.Canvas2D.Renderer();\n\n// 创建画布\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer: canvasRenderer,\n});\n\n// 创建一个 Circle\nconst circle = new Circle({\n    style: {\n        r: 50,\n        fill: '#1890FF',\n        stroke: '#F04864',\n        lineWidth: 4,\n        cursor: 'pointer',\n    },\n});\n\n// 等待画布初始化完成\ncanvas.addEventListener(CanvasEvent.READY, () => {\n    // 向画布中加入 Circle\n    canvas.appendChild(circle);\n});\n",paraId:49,tocIndex:2},{value:"完整 CodeSandbox 例子",paraId:50,tocIndex:2},{value:"首先安装核心包和渲染器：",paraId:51,tocIndex:3},{value:"# 核心包\n$ npm install @antv/g --save\n\n# Canvas2D 渲染器\n$ npm install @antv/g-canvas --save\n# SVG 渲染器\n$ npm install @antv/g-svg --save\n# WebGL 渲染器\n$ npm install @antv/g-webgl --save\n",paraId:52,tocIndex:3},{value:"然后就可以在核心包中使用 ",paraId:53,tocIndex:3},{value:"Canvas",paraId:54,tocIndex:3},{value:"、",paraId:53,tocIndex:3},{value:"Circle",paraId:55,tocIndex:3},{value:" 这样的核心基础对象以及 ",paraId:53,tocIndex:3},{value:"Renderer",paraId:56,tocIndex:3},{value:" 这样的渲染器：",paraId:53,tocIndex:3},{value:"import { Canvas, CanvasEvent, Circle } from '@antv/g';\nimport { Renderer } from '@antv/g-canvas';\n\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer: new Renderer(),\n});\n\nconst circle = new Circle({\n    style: {\n        r: 50,\n        fill: '#1890FF',\n        stroke: '#F04864',\n        lineWidth: 4,\n        cursor: 'pointer',\n    },\n});\n\ncanvas.addEventListener(CanvasEvent.READY, () => {\n    canvas.appendChild(circle);\n});\n",paraId:57,tocIndex:3},{value:"完整 CodeSandbox 例子",paraId:58,tocIndex:3},{value:"完整 StackBlitz 例子",paraId:59,tocIndex:3}]},73247:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(93368);const d=[{value:"通常用户使用 G 绘图可以分成三步：",paraId:0},{value:"使用",paraId:1},{value:"场景图",paraId:2},{value:"描述待渲染对象",paraId:1},{value:"按需引入",paraId:3},{value:"一个或多个 Renderer 渲染器",paraId:1},{value:"使用渲染器渲染场景图，可以在运行时切换不同渲染器",paraId:1},{value:"其中，场景图是独立于各种渲染器的抽象，因此在组件库、布局系统这类与实际渲染效果无关的应用中，并不需要直接与渲染器打交道，各个渲染器应该保证在各自环境下的一致渲染效果。在构建场景图，操作图中节点的语法上，我们提供了与 ",paraId:4},{value:"DOM API 一致的方法",paraId:5},{value:"，同时提供",paraId:4},{value:"类似 CSS 选择器的语法",paraId:6},{value:"来查询图中节点，尽可能减少前端的学习成本。",paraId:4},{value:"在扩展性上，我们从场景图和渲染服务两个维度提供了",paraId:7},{value:"插件机制",paraId:7},{value:"。",paraId:7},{value:"场景图的插件关心每个节点的",paraId:8},{value:"生命周期",paraId:9},{value:"，选取其中的某些阶段扩展节点能力。",paraId:8},{value:"我们定义了统一的核心渲染层，它不关心具体渲染器的实现，暴露生命周期供扩展。以 WebGL 渲染器为例，它通过注册插件，为场景图中每一个节点扩展了 Material 等组件，得以适应 WebGL 渲染环境。",paraId:10},{value:"通过",paraId:11},{value:"依赖注入",paraId:12},{value:"使各个渲染器实现统一的上下文、渲染服务接口，核心层并不关心具体渲染器实现，因此可以在运行时动态替换不同渲染器。",paraId:11},{value:"我们在 G 的核心层定义了一套统一的渲染服务，该服务定义了如下生命周期。各个渲染器通过关联生命周期中的各个阶段，完成各自渲染环境下的渲染流程：",paraId:13,tocIndex:0},{value:"hooks = {\n    // 渲染服务初始化，切换到新渲染器时也会调用\n    init: new SyncHook<[]>(),\n    // 处理待渲染对象\n    prepareEntities: new AsyncSeriesWaterfallHook<[Entity[], DisplayObject]>(['entities', 'root']),\n    // 渲染帧开始\n    beginFrame: new AsyncSeriesHook<[Entity[]]>(['entities']),\n    // 渲染中\n    renderFrame: new AsyncSeriesHook<[Entity[]]>(['entities']),\n    // 渲染帧结束\n    endFrame: new AsyncSeriesHook<[Entity[]]>(['entities']),\n    // 渲染服务销毁，切换到新渲染器后，旧渲染器调用\n    destroy: new SyncHook<[]>(),\n};\n",paraId:14,tocIndex:0},{value:"其中核心层实现了一系列通用插件，它们与具体渲染环境无关：",paraId:15,tocIndex:0},{value:"MountDisplayObjectPlugin",paraId:16,tocIndex:0},{value:"prepareEntities 首次挂载到画布时调用，触发渲染对象的 ",paraId:17,tocIndex:0},{value:"mounted",paraId:17,tocIndex:0},{value:" 生命周期",paraId:17,tocIndex:0},{value:"DirtyCheckPlugin",paraId:18,tocIndex:0},{value:" 实现",paraId:18,tocIndex:0},{value:"脏矩形渲染",paraId:19,tocIndex:0},{value:"init 监听每个待渲染对象的包围盒变更",paraId:20,tocIndex:0},{value:"prepareEntities 过滤包含了脏标记的待渲染对象列表，合并脏矩形，通过 R-Tree 加速查询增量重绘对象列表",paraId:20,tocIndex:0},{value:"endFrame 对于当前帧完成绘制的对象列表中的每一个对象，保存它的包围盒，供下次脏检查合并使用",paraId:20,tocIndex:0},{value:"destroy 移除对于每个待渲染对象的包围盒变更的监听",paraId:20,tocIndex:0},{value:"CullingPlugin",paraId:21,tocIndex:0},{value:" 负责剔除，得到需要重绘的最小对象集合",paraId:21,tocIndex:0},{value:"prepareEntities 通过 ",paraId:22,tocIndex:0},{value:"visiblity",paraId:22,tocIndex:0},{value:" 和视口包围盒剔除",paraId:22,tocIndex:0},{value:"SortPlugin",paraId:23,tocIndex:0},{value:" 负责对象排序",paraId:23,tocIndex:0},{value:"prepareEntities 通过 ",paraId:24,tocIndex:0},{value:"z-index",paraId:24,tocIndex:0},{value:" 排序",paraId:24,tocIndex:0},{value:"DirtyRectanglePlugin",paraId:25,tocIndex:1},{value:"beginFrame\n",paraId:26,tocIndex:1},{value:"context.save()",paraId:27,tocIndex:1},{value:"擦除脏矩形，创建 clip",paraId:27,tocIndex:1},{value:"renderFrame\n",paraId:26,tocIndex:1},{value:"应用变换矩阵",paraId:28,tocIndex:1},{value:"在 Canvas 2D 上下文中应用属性",paraId:28,tocIndex:1},{value:"绘制路径",paraId:28,tocIndex:1},{value:"填充和描边",paraId:28,tocIndex:1},{value:"endFrame\n",paraId:26,tocIndex:1},{value:"context.restore()",paraId:29,tocIndex:1}]},79072:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(61436);const d=[{value:"在目前 monorep 中，各个包的依赖关系如下：",paraId:0,tocIndex:0},{value:"@antv/g",paraId:1,tocIndex:0},{value:" 核心包，依赖注入使用 mana-syringe",paraId:1,tocIndex:0},{value:"@antv/g-canvas/svg/webgl",paraId:1,tocIndex:0},{value:" 渲染器包，依赖 ",paraId:1,tocIndex:0},{value:"@antv/g",paraId:1,tocIndex:0},{value:"，内部注册了一系列插件：\n",paraId:1,tocIndex:0},{value:"例如 ",paraId:2,tocIndex:0},{value:"@antv/g-canvas",paraId:2,tocIndex:0},{value:" 依赖 ",paraId:2,tocIndex:0},{value:"@antv/g-plugin-canvas-renderer",paraId:2,tocIndex:0},{value:" 等四个插件",paraId:2,tocIndex:0},{value:"@antv/g-plugin-xxx",paraId:1,tocIndex:0},{value:" 插件包，依赖 ",paraId:1,tocIndex:0},{value:"@antv/g",paraId:1,tocIndex:0},{value:"，部分插件也会依赖其他插件",paraId:1,tocIndex:0},{value:"特别的，",paraId:3,tocIndex:0},{value:"g-webgl",paraId:3,tocIndex:0},{value:" 使用 wasm 转译 GLSL 到 WGSL。",paraId:3,tocIndex:0},{value:"在构建时我们选择 ",paraId:4,tocIndex:0},{value:"father",paraId:4,tocIndex:0},{value:" 构建 CJS 与 ESM，webpack4 构建 UMD。",paraId:4,tocIndex:0},{value:"构建时使用 father：",paraId:5,tocIndex:1},{value:'// 根目录 package.json\n"build": "father build",\n',paraId:6,tocIndex:1},{value:"在 ",paraId:7,tocIndex:1},{value:"fatherrc",paraId:7,tocIndex:1},{value:" 中选择 ",paraId:7,tocIndex:1},{value:"babel",paraId:7,tocIndex:1},{value:" 模式：",paraId:7,tocIndex:1},{value:"{\n  cjs: 'babel',\n  esm: 'babel',\n  umd: false,\n  nodeResolveOpts: {\n    mainFields: ['module', 'browser', 'main'],\n  },\n  pkgs: [\n    'g-math',\n    // 省略其他构建包\n  ]\n}\n",paraId:8,tocIndex:1},{value:"运行后在每个子包下 ",paraId:9,tocIndex:1},{value:"/es",paraId:9,tocIndex:1},{value:" 和 ",paraId:9,tocIndex:1},{value:"/lib",paraId:9,tocIndex:1},{value:" 下就会生成对应源文件的 ESM 和 CJS 文件了。",paraId:9,tocIndex:1},{value:"使用 webpack4 构建 UMD，以 ",paraId:10,tocIndex:2},{value:"g-canvas",paraId:10,tocIndex:2},{value:" 为例，在配置文件中排除掉：",paraId:10,tocIndex:2},{value:"module.exports = {\n    ...common,\n    externals: {\n        '@antv/g': {\n            commonjs: '@antv/g',\n            commonjs2: '@antv/g',\n            amd: '@antv/g',\n            root: 'G', // 运行时通过 window.G 获取\n        },\n        'mana-syringe': {\n            commonjs: 'mana-syringe',\n            commonjs2: 'mana-syringe',\n            amd: 'mana-syringe',\n            root: ['G', 'ManaSyringe'], // 运行时通过 window.G.ManaSyringe 获取\n        },\n    },\n    output: {\n        library: ['G', 'Canvas2D'], // 暴露 window.G.Canvas2D\n        libraryTarget: 'umd',\n        filename: 'index.umd.min.js',\n    },\n};\n",paraId:11,tocIndex:2},{value:"特别的 ",paraId:12,tocIndex:3},{value:"g-webgl",paraId:12,tocIndex:3},{value:" 需要使用 WASM，因此多加一个插件：",paraId:12,tocIndex:3},{value:"plugins: [\n    new WasmPackPlugin({\n        crateDirectory: path.join(__dirname, 'rust'), // crate 放在 /rust 下\n        forceMode: 'production',\n    }),\n],\n",paraId:13,tocIndex:3}]},51752:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(83797);const d=[{value:"支持以下渐变效果，可应用在 ",paraId:0,tocIndex:0},{value:"fill",paraId:0,tocIndex:0},{value:" ",paraId:0,tocIndex:0},{value:"stroke",paraId:0,tocIndex:0},{value:" 属性上。不支持动画（直接应用，无渐变效果）。",paraId:0,tocIndex:0},{value:"可以在",paraId:1,tocIndex:0},{value:"示例",paraId:2,tocIndex:0},{value:"中切换 Canvas2D/SVG/WebGL 查看效果。",paraId:1,tocIndex:0},{value:"线性渐变：",paraId:3,tocIndex:0},{value:"stroke: 'l(0) 0:#ffffff 0.5:#7ec2f3 1:#1890ff';\n",paraId:4,tocIndex:0},{value:"放射状/环形渐变：",paraId:5,tocIndex:0},{value:"fill: 'r(0.5, 0.5, 0.1) 0:#ffffff 1:#1890ff';\n",paraId:6,tocIndex:0},{value:"纹理：",paraId:7,tocIndex:0},{value:"fill: 'p(a)https://gw.alipayobjects.com/zos/rmsportal/ibtwzHXSxomqbZCPMLqS.png';\n",paraId:8,tocIndex:0},{value:"通过以下 API 创建：",paraId:9,tocIndex:2},{value:"createLinearGradient",paraId:10,tocIndex:2},{value:"createRadialGradient",paraId:10,tocIndex:2},{value:" 由于 xyr 使用的是相对值，需要结合当前图形包围盒计算",paraId:10,tocIndex:2},{value:"createPattern",paraId:10,tocIndex:2},{value:"需要注意的是可以使用缓存减少重复创建的成本，例如以图片 URL、颜色值等为 key。",paraId:11,tocIndex:2},{value:"在 defs 中可以定义 pattern、渐变，然后通过 fill 属性引用 url：",paraId:12,tocIndex:3},{value:'<defs>\n    <pattern\n        patternUnits="userSpaceOnUse"\n        id="_pattern_3_4"\n        width="3"\n        height="3"\n    >\n        <image\n            href="https://gw.alipayobjects.com/zos/rmsportal/ibtwzHXSxomqbZCPMLqS.png"\n        >\n        </image>\n    </pattern>\n\n    <radialGradient cx="0.5" cy="0.5" r="0.5" id="_pattern_2_5">\n        <stop offset="0" stop-color="#ffffff"></stop>\n        <stop offset="1" stop-color="#1890ff"></stop>\n    </radialGradient>\n\n    <linearGradient x1="0" y1="0" x2="1" y2="0" id="_pattern_1_6">\n        <stop offset="0" stop-color="#ffffff"></stop>\n        <stop offset="0.5" stop-color="#7ec2f3"></stop>\n        <stop offset="1" stop-color="#1890ff"></stop>\n    </linearGradient>\n</defs>\n',paraId:13,tocIndex:3},{value:"在开发时发现 Chrome 无法正常展示 stroke 为 url 的水平直线，只要直线不是水平都能正常展示：",paraId:14,tocIndex:4},{value:'<line x1="0" y1="0" x2="20" y2="0" stroke-width="20" stroke="url(#utrim)" />\n',paraId:15,tocIndex:4},{value:"有人向 Chrome 反映了这个 bug，目前修复办法只能是稍微调整一下（注意下面给 y2 加了一点点偏移）让直线不是完全水平。。。",paraId:16,tocIndex:4},{value:"https://stackoverflow.com/questions/14680240/did-chrome-break-svg-stroke-url",paraId:17,tocIndex:4},{value:'<line\n    x1="0"\n    y1="0"\n    x2="100%"\n    y2="0.01"\n    stroke-width="20"\n    stroke="url(#utrim)"\n/>\n',paraId:18,tocIndex:4},{value:"当然可以在 Shader 中做渐变，但问题是需要支持多个 colorStop，可以通过 attribute 实现但还是挺麻烦。",paraId:19,tocIndex:5},{value:"https://stackoverflow.com/questions/61862262/webgl-shader-for-directional-linear-gradient",paraId:19,tocIndex:5},{value:"纹理支持通过 Canvas 创建，因此可以用 Canvas2D 创建 Gradient，例如 PIXI.js 就是这么做的： ",paraId:20,tocIndex:5},{value:"https://pixijs.io/examples/#/textures/gradient-basic.js",paraId:20,tocIndex:5},{value:"以线性渐变为例，可以创建一个定长的 OffscreenCanvas 例如 256 * 1（高度 1 就够），多次 addColorStop 之后用这个 OffscreenCanvas 创建纹理。 ",paraId:21,tocIndex:5},{value:"https://github.com/ShukantPal/pixi-essentials/blob/master/packages/gradients/src/GradientFactory.ts",paraId:21,tocIndex:5},{value:"但是对于 RadialGradient，还是需要创建一个 256 ",paraId:22,tocIndex:5},{value:"256，wrapTS 都设置为 clamp to edge 即可。值得一提的是纹理大小（32",paraId:22,tocIndex:5},{value:" 32）一定要小于 Canvas 大小，不然会出现走样问题。",paraId:22,tocIndex:5},{value:"WebGL1 对于 NPOT(power of 2 即长宽都是 2 的平方、立方）这样的纹理是不支持 REPEAT 这样的 wrap mode 的，也不支持 mipmap。WebGL2 则没有这样的限制。",paraId:23,tocIndex:6},{value:"https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL",paraId:24,tocIndex:6},{value:"WebGL1 can only use non power of 2 textures with filtering set to NEAREST or LINEAR and it can not generate a mipmap for them. Their wrapping mode must also be set to CLAMP_TO_EDGE. On the other hand if the texture is a power of 2 in both dimensions then WebGL can do higher quality filtering, it can use mipmap, and it can set the wrapping mode to REPEAT or MIRRORED_REPEAT.",paraId:25,tocIndex:6},{value:"因此在一些渲染引擎中能看到：",paraId:26,tocIndex:6},{value:"PIXI.js 中不允许对 NPOT 这样的纹理进行平铺。",paraId:27,tocIndex:6},{value:"Babylon.js 会进行 resize，当然这会造成额外性能开销。",paraId:27,tocIndex:6},{value:"https://doc.babylonjs.com/advanced_topics/webGL2#power-of-two-textures",paraId:27,tocIndex:6},{value:"我们暂时限制纹理必须为 POT，否则不支持平铺。",paraId:28,tocIndex:6}]},82380:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(29260);const d=[{value:"画一条线到底有多难。",paraId:0},{value:"最近的一期 WebGL / WebGPU Meetup 上一个“老生常谈”的话题又出现了，来自 Pixi.js 团队的“如何用 WebGL 画一条直线”：",paraId:1,tocIndex:0},{value:"https://www.khronos.org/assets/uploads/developers/presentations/Crazy_Panda_How_to_draw_lines_in_WebGL.pdf",paraId:1,tocIndex:0},{value:"之前我在知乎上总结过一篇：",paraId:2,tocIndex:0},{value:"在 WebGL 中绘制直线",paraId:2,tocIndex:0},{value:"。结合上面的分享完善下目前 G 的实现。",paraId:2,tocIndex:0},{value:"WebGL 原生是提供了 LINES 这样的 primitive 的，但在实际使用中往往并不好用。尤其是涉及到地理信息的展示，直接使用原生的 gl.LINES 进行绘制存在一些问题：",paraId:3,tocIndex:1},{value:"线宽无法设置，Chrome 下试图设置 lineWidth 会得到警告，相关 ISSUE ：\n",paraId:4,tocIndex:1},{value:"MDN ：As of January 2017 most implementations of WebGL only support a minimum of 1 and a maximum of 1 as the technology they are based on has these same limits.",paraId:5,tocIndex:1},{value:"无法定义相邻线段间的连接形状 lineJoin 以及端点形状 lineCap",paraId:4,tocIndex:1},{value:"因此我们得考虑将线段转换成其他几何图形进行绘制。",paraId:6,tocIndex:1},{value:"因此目前几乎所有的引擎都采用了在 CPU 侧进行三角化，根据 Cap、Joint 类型增加顶点。Mapbox 也是如此。另外也有在 Shader 中进行的例如 Geo.js，大量计算在 Fragment Shader 中进行。",paraId:7,tocIndex:2},{value:"下图来自 Pixi.js 团队的分享 PPT：",paraId:8,tocIndex:2},{value:"在 G 中，除了 Line、Polyline、Path 这些基础图形，在实现 stroke 描边时，也需要使用这一实现。",paraId:9,tocIndex:2},{value:"在绘制大量直线、折线甚至是曲线时，最好能尽可能共享顶点数据。",paraId:10,tocIndex:4},{value:"一种简单的做法是将线段看作一个 instance，这样一组线段（line strip）就可以重复绘制多次（端点数目 - 1）: ",paraId:11,tocIndex:4},{value:"https://wwwtyro.net/2019/11/18/instanced-lines.html",paraId:11,tocIndex:4},{value:"其中 instanced geometry 如下：",paraId:12,tocIndex:4},{value:"vec2 point = pointA + xBasis * position.x + yBasis * width * position.y;\n",paraId:13,tocIndex:4},{value:"https://wwwtyro.net/2019/11/18/instanced-lines.html",paraId:14,tocIndex:5},{value:"https://www.khronos.org/assets/uploads/developers/presentations/Crazy_Panda_How_to_draw_lines_in_WebGL.pdf",paraId:14,tocIndex:5}]},25109:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(88622);const d=[{value:"当场景中需要使用 3D 图形时，可以引入该插件，其中内置了一些常用的 3D 图形。",paraId:0},{value:"3D 图形的绘制只有 ",paraId:1,tocIndex:0},{value:"g-webgl",paraId:1,tocIndex:0},{value:" 和 ",paraId:1,tocIndex:0},{value:"g-webgpu",paraId:1,tocIndex:0},{value:" 渲染器支持：",paraId:1,tocIndex:0},{value:"import { Renderer as WebGLRenderer } from '@antv/g-webgl';\n// 创建 WebGL 渲染器\nconst webglRenderer = new WebGLRenderer();\n",paraId:2,tocIndex:0},{value:"然后需要注册 3D 插件：",paraId:3,tocIndex:0},{value:"import { Plugin } from '@antv/g-plugin-3d';\n// 注册 3D 插件\nwebglRenderer.registerPlugin(new Plugin());\n",paraId:4,tocIndex:0},{value:"最后在创建画布时指定该渲染器：",paraId:5,tocIndex:0},{value:"import { Canvas } from '@antv/g';\n\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer: webglRenderer, // 指定 WebGL 渲染器\n});\n",paraId:6,tocIndex:0},{value:"材质",paraId:7,tocIndex:1},{value:"几何",paraId:8,tocIndex:1},{value:"光源",paraId:9,tocIndex:1},{value:"Mesh",paraId:10,tocIndex:1}]},79945:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(21655);const d=[{value:"由于画布通常呈现为一个“黑盒”，其中的内容无法被文本化进而被 Screen Reader 朗读。当然这只是无障碍中涉及一个功能，针对不同类型的障碍人士，还可以提供例如文本提取、键盘导航等功能。",paraId:0},{value:"在图表领域做的最好的是 ",paraId:1},{value:"https://www.highcharts.com/blog/accessibility/",paraId:1},{value:" 其中有大量实践值得借鉴。",paraId:1},{value:"创建插件并在渲染器中注册：",paraId:2,tocIndex:0},{value:"import { Plugin as PluginA11y } from '@antv/g-plugin-a11y';\nrenderer.registerPlugin(new PluginA11y());\n",paraId:3,tocIndex:0},{value:"在一些渲染器（例如 ",paraId:4,tocIndex:2},{value:"g-canvas",paraId:5,tocIndex:2},{value:" / ",paraId:4,tocIndex:2},{value:"g-webgl",paraId:6,tocIndex:2},{value:" / ",paraId:4,tocIndex:2},{value:"g-canvaskit",paraId:7,tocIndex:2},{value:"）中，当文本被绘制后便无法使用浏览器自带的搜索功能（Command + F）定位匹配，同样对于 SEO 也不友好。",paraId:4,tocIndex:2},{value:"在该",paraId:8,tocIndex:2},{value:"示例",paraId:9,tocIndex:2},{value:"中，我们开启 ",paraId:8,tocIndex:2},{value:"enableExtractingText",paraId:8,tocIndex:2},{value:" 后便可以使用以上功能：",paraId:8,tocIndex:2},{value:"const plugin = new Plugin({\n    enableExtractingText: true,\n});\ncanvasRenderer.registerPlugin(plugin);\n",paraId:10,tocIndex:2},{value:"在实现中我们在",paraId:11,tocIndex:2},{value:"画布容器",paraId:12,tocIndex:2},{value:"内添加了 DOM 元素，用于与画布中的可见文本实时同步：",paraId:11,tocIndex:2},{value:'<div\n    id="g-a11y-text-extractor-mask"\n    style="position: absolute; inset: 0px; z-index: 99; pointer-events: none; user-select: none; overflow: hidden;"\n>\n    <div\n        id="g-a11y-text-extractor-text-94"\n        style="line-height: 1; position: absolute; white-space: pre; word-break: keep-all; color: transparent !important; transform-origin: 0px 0px; transform: translate(0px, 0px) translate(-50%, -100%) matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 320, 350, 0, 1); font-size: 10px; font-family: sans-serif;"\n    >\n        Humidity\n    </div>\n</div>\n',paraId:13,tocIndex:2},{value:"有以下注意事项：",paraId:14,tocIndex:2},{value:"使用 ",paraId:15,tocIndex:2},{value:"g-svg",paraId:16,tocIndex:2},{value:" 渲染时，由于 SVG 天然支持 ",paraId:15,tocIndex:2},{value:"<foreignObject>",paraId:15,tocIndex:2},{value:"，不会添加上述 DOM 内容",paraId:15,tocIndex:2},{value:"由于浏览器有最小字号的限制（Chrome 中为 ",paraId:15,tocIndex:2},{value:"12px",paraId:15,tocIndex:2},{value:"），因此太小的文本会有不一致的渲染效果",paraId:15,tocIndex:2},{value:"使用 Tab 键进行导航，并朗读其中的文本内容。",paraId:17,tocIndex:3},{value:"https://developer.mozilla.org/zh-CN/docs/Web/Accessibility/ARIA/Attributes",paraId:18,tocIndex:3},{value:"我们提供了",paraId:19,tocIndex:5},{value:"动画",paraId:20,tocIndex:5},{value:"功能，但一些有认知障碍的用户，会因为动画内容而感到恶心或分心。",paraId:19,tocIndex:5},{value:"CSS 媒体查询提供了 ",paraId:21,tocIndex:5},{value:"prefers-reduced-motion",paraId:21,tocIndex:5},{value:"，可以帮助我们检测用户是否开启了浏览器 / 系统的 “减少动画” 功能，此时可以响应用户需求，尽可能减少场景中的动画。",paraId:21,tocIndex:5},{value:".animation {\n    animation: vibrate 0.3s linear infinite both;\n}\n\n@media (prefers-reduced-motion: reduce) {\n    .animation {\n        animation: none;\n    }\n}\n",paraId:22,tocIndex:5},{value:"除了通过 CSS 进行媒体查询，JS 也有对应的 API： ",paraId:23,tocIndex:5},{value:"https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia：",paraId:23,tocIndex:5},{value:"const mql = window.matchMedia('(prefers-reduced-motion: reduce)');\nmql.matches;\n",paraId:24,tocIndex:5}]},44489:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(59721);const d=[{value:"除了把图形渲染出来，有时我们还希望以交互形式对图形进行缩放等变换，例如 ",paraId:0},{value:"Fabric.js",paraId:0},{value:" 和 ",paraId:0},{value:"Konva.js",paraId:0},{value:" 就提供了这样的能力。以下图为例，鼠标选中图形后，会出现辅助操作的控件，可以通过拖拽蒙层移动目标图形，也可以通过拖拽锚点对图形进行缩放：",paraId:0},{value:"示例",paraId:1},{value:"该插件依赖 ",paraId:2,tocIndex:0},{value:"g-plugin-dragndrop",paraId:3,tocIndex:0},{value:" 提供的拖拽能力，因此在使用时需要同时注册：",paraId:2,tocIndex:0},{value:"import { Plugin as PluginDragndrop } from '@antv/g-plugin-dragndrop';\nimport { Plugin as PluginAnnotation } from '@antv/g-plugin-annotation';\n\nrenderer.registerPlugin(new PluginDragndrop());\nrenderer.registerPlugin(new PluginAnnotation());\n",paraId:4,tocIndex:0},{value:"该插件提供两种模式，可以通过 ",paraId:5,tocIndex:1},{value:"setDrawingMode",paraId:6,tocIndex:1},{value:" 进行切换：",paraId:5,tocIndex:1},{value:"绘制模式。该模式下可按预设步骤绘制图形。",paraId:7,tocIndex:1},{value:"编辑模式。该模式下选中 ",paraId:7,tocIndex:1},{value:"selectable",paraId:7,tocIndex:1},{value:" 图形会出现对应的编辑组件，通过组件交互完成图形平移、resize 等编辑操作。",paraId:7,tocIndex:1},{value:"进入绘制模式后，使用 ",paraId:8,tocIndex:2},{value:"setDrawer",paraId:9,tocIndex:2},{value:" 设置对应图形的绘制工具，即可开始绘制。例如我们想绘制折线：",paraId:8,tocIndex:2},{value:"plugin.setDrawingMode(true);\nplugin.setDrawer(DrawerTool.Polyline);\n// or\nplugin.setDrawer('polyline');\n",paraId:10,tocIndex:2},{value:"目前我们提供以下绘制工具：",paraId:11,tocIndex:2},{value:"export enum DrawerTool {\n  Circle = 'circle',\n  Rect = 'rect',\n  Polygon = 'polygon',\n  Polyline = 'polyline',\n}\n",paraId:12,tocIndex:2},{value:"在绘制过程中会触发一系列事件。在 Fabric.js 中需要先设置 Brush 笔刷，再进行绘制。使用该插件时，需要监听绘制完毕事件，使用事件对象中携带的绘制点数据创建基础图形并添加到画布中。",paraId:13,tocIndex:2},{value:"annotationPlugin.addEventListener('draw:complete', ({ type, path }) => {\n    // use any brush you preferred\n    const brush = {\n        stroke: 'black',\n        strokeWidth: 10,\n        selectable: true,\n    };\n});\n",paraId:14,tocIndex:2},{value:"按下鼠标确定点的位置，随后可以使用该位置绘制任意图形例如 ",paraId:15,tocIndex:3},{value:"Circle",paraId:16,tocIndex:3},{value:"。",paraId:15,tocIndex:3},{value:"按下鼠标、拖拽再抬起即可完成绘制。",paraId:17,tocIndex:4},{value:"支持以下键盘快捷操作：",paraId:18,tocIndex:4},{value:"esc",paraId:19,tocIndex:4},{value:" 取消绘制",paraId:19,tocIndex:4},{value:"依次按下鼠标确定顶点，双击鼠标或者连续顶点距离很近即视为结束绘制，顶点间连线形成最终的折线。",paraId:20,tocIndex:5},{value:"支持以下键盘快捷操作：",paraId:21,tocIndex:5},{value:"esc",paraId:22,tocIndex:5},{value:" 取消绘制",paraId:22,tocIndex:5},{value:"shift",paraId:22,tocIndex:5},{value:" + ",paraId:22,tocIndex:5},{value:"Z",paraId:22,tocIndex:5},{value:" 撤销最新的一个线段",paraId:22,tocIndex:5},{value:"space",paraId:22,tocIndex:5},{value:" 完成绘制",paraId:22,tocIndex:5},{value:"依次按下鼠标确定顶点，闭合形成多边形。",paraId:23,tocIndex:6},{value:"支持以下键盘快捷操作：",paraId:24,tocIndex:6},{value:"esc",paraId:25,tocIndex:6},{value:" 取消绘制",paraId:25,tocIndex:6},{value:"shift",paraId:25,tocIndex:6},{value:" + ",paraId:25,tocIndex:6},{value:"Z",paraId:25,tocIndex:6},{value:" 撤销最新的一个线段",paraId:25,tocIndex:6},{value:"space",paraId:25,tocIndex:6},{value:" 完成绘制",paraId:25,tocIndex:6},{value:"通过开启 ",paraId:26,tocIndex:7},{value:"selectable",paraId:26,tocIndex:7},{value:" 可以让基础图形具备交互功能：",paraId:26,tocIndex:7},{value:"circle.style.selectable = true;\n",paraId:27,tocIndex:7},{value:"目前我们支持以下",paraId:28,tocIndex:7},{value:"基础图形",paraId:28,tocIndex:7},{value:"：",paraId:28,tocIndex:7},{value:"Circle",paraId:29,tocIndex:7},{value:"、",paraId:28,tocIndex:7},{value:"Ellipse",paraId:30,tocIndex:7},{value:"、",paraId:28,tocIndex:7},{value:"Rect",paraId:31,tocIndex:7},{value:"、",paraId:28,tocIndex:7},{value:"Image",paraId:32,tocIndex:7},{value:"、",paraId:28,tocIndex:7},{value:"Line",paraId:33,tocIndex:7},{value:"、",paraId:28,tocIndex:7},{value:"Polyline",paraId:34,tocIndex:7},{value:"另外 ",paraId:35,tocIndex:7},{value:"anchorsVisibility",paraId:35,tocIndex:7},{value:" 可以控制锚点可见性。",paraId:35,tocIndex:7},{value:"maskDraggable",paraId:35,tocIndex:7},{value:" 可以控制蒙层是否可拖拽。",paraId:35,tocIndex:7},{value:"我们支持通过交互或者 API 选中单个或者多个图形。",paraId:36,tocIndex:8},{value:"通过 API 方式选中图形，可以调用 ",paraId:37,tocIndex:8},{value:"selectDisplayObject",paraId:38,tocIndex:8},{value:" 方法。图形被选中后会在上面出现一个蒙层，蒙层中包含若干锚点。",paraId:37,tocIndex:8},{value:"点击图形即可完成单选，这也是最常见的方式。我们支持以下两种方式完成多选：",paraId:39,tocIndex:8},{value:"按住 ",paraId:40,tocIndex:8},{value:"shift",paraId:40,tocIndex:8},{value:" 配合点击，在保留已选中图形的基础上追加选中",paraId:40,tocIndex:8},{value:"按住 ",paraId:40,tocIndex:8},{value:"shift",paraId:40,tocIndex:8},{value:" 并拖拽出一个矩形完成区域刷选",paraId:40,tocIndex:8},{value:"和选中图形相对，取消选中也有两种方式：",paraId:41,tocIndex:9},{value:"点击画布空白区域或者另一个图形。",paraId:42,tocIndex:9},{value:"通过 API 方式取消选中图形，调用 ",paraId:42,tocIndex:9},{value:"deselectDisplayObject",paraId:43,tocIndex:9},{value:" 方法。",paraId:42,tocIndex:9},{value:"选中图形后，在蒙层上拖拽即可实现图形移动：",paraId:44,tocIndex:10},{value:"在移动过程中以及移动完毕后会触发相应 ",paraId:45,tocIndex:10},{value:"事件",paraId:46,tocIndex:10},{value:"。",paraId:45,tocIndex:10},{value:"另外也可以在选中图形后，使用键盘上下左右方向键移动图形，移动的步长可以通过 ",paraId:47,tocIndex:10},{value:"arrowKeyStepLength",paraId:48,tocIndex:10},{value:" 配置。",paraId:47,tocIndex:10},{value:"拖拽锚点可以改变图形的大小。以下图为例，拖拽右下角的锚点时，实际上是先固定了左上角，再修改图片的宽高。",paraId:49,tocIndex:11},{value:"在创建插件时，可以传入一些初始化配置。",paraId:50,tocIndex:12},{value:"是否为绘制模式，默认值为 ",paraId:51,tocIndex:13},{value:"true",paraId:51,tocIndex:13},{value:"。",paraId:51,tocIndex:13},{value:"在某些场景下自动切换，默认值为 ",paraId:52,tocIndex:14},{value:"false",paraId:52,tocIndex:14},{value:"。",paraId:52,tocIndex:14},{value:"在绘制模式下点击可交互图形，将自动切换成编辑模式。",paraId:53,tocIndex:14},{value:"在编辑模式下点击空白区域，将自动切换成绘制模式。",paraId:53,tocIndex:14},{value:"支持使用键盘快捷键删除已选中的可交互图形，默认值为 ",paraId:54,tocIndex:15},{value:"false",paraId:54,tocIndex:15},{value:"。",paraId:54,tocIndex:15},{value:"开启后，可使用 ",paraId:55,tocIndex:15},{value:"Delete",paraId:55,tocIndex:15},{value:" / ",paraId:55,tocIndex:15},{value:"Esc",paraId:55,tocIndex:15},{value:" / ",paraId:55,tocIndex:15},{value:"Backspace",paraId:55,tocIndex:15},{value:" 按键删除已选中的可交互图形。",paraId:55,tocIndex:15},{value:"是否支持连续按住 ",paraId:56,tocIndex:16},{value:"shift",paraId:56,tocIndex:16},{value:" 进行框选，默认值为 ",paraId:56,tocIndex:16},{value:"true",paraId:56,tocIndex:16},{value:"。",paraId:56,tocIndex:16},{value:"关闭后，每次框选都会清除上一次的结果，重新选择。",paraId:57,tocIndex:16},{value:"编辑模式下，使用键盘上下左右方向键移动图形的步长，默认值为 ",paraId:58,tocIndex:17},{value:"4",paraId:58,tocIndex:17},{value:"。",paraId:58,tocIndex:17},{value:"辅助操作组件的部分样式支持自定义，因此可以在初始化时传入样式配置，例如将蒙层的填充色变成黑色：",paraId:59,tocIndex:18},{value:"const plugin = new PluginAnnotation({\n    selectableStyle: {\n        selectionFill: 'black',\n    },\n});\n",paraId:60,tocIndex:18},{value:"目前我们支持的样式配置如下：",paraId:61,tocIndex:18},{value:"export interface SelectableStyle {\n    /**\n     * 蒙层\n     */\n    selectionFill: string;\n    selectionFillOpacity: number;\n    selectionStroke: string;\n    selectionStrokeOpacity: number;\n    selectionStrokeWidth: number;\n    /**\n     * 锚点\n     */\n    anchorFill: string;\n    anchorStroke: string;\n    anchorSize: string | number;\n    anchorFillOpacity: number;\n    anchorStrokeOpacity: number;\n}\n",paraId:62,tocIndex:18},{value:"除了在初始化插件时指定，后续也可以随时使用 ",paraId:63,tocIndex:18},{value:"updateSelectableStyle",paraId:64,tocIndex:18},{value:" 方法修改。",paraId:63,tocIndex:18},{value:"蒙层填充色，可以参考 ",paraId:65,tocIndex:19},{value:"fill",paraId:66,tocIndex:19},{value:" 的取值，例如：",paraId:65,tocIndex:19},{value:"const plugin = new PluginAnnotation({\n    selectableStyle: {\n        selectionFill: 'rgba(0, 0, 0, 0.5)',\n    },\n});\n",paraId:67,tocIndex:19},{value:"蒙层填充色透明度，可以参考 ",paraId:68,tocIndex:20},{value:"fillOpacity",paraId:69,tocIndex:20},{value:" 的取值。",paraId:68,tocIndex:20},{value:"蒙层描边颜色。可以参考 ",paraId:70,tocIndex:21},{value:"stroke",paraId:71,tocIndex:21},{value:" 的取值。",paraId:70,tocIndex:21},{value:"const plugin = new PluginAnnotation({\n    selectableStyle: {\n        selectionStroke: 'rgba(0, 0, 0, 0.5)',\n    },\n});\n",paraId:72,tocIndex:21},{value:"蒙层描边透明度，可以参考 ",paraId:73,tocIndex:22},{value:"strokeOpacity",paraId:74,tocIndex:22},{value:" 的取值。",paraId:73,tocIndex:22},{value:"蒙层描边线宽。可以参考 ",paraId:75,tocIndex:23},{value:"strokeWidth",paraId:76,tocIndex:23},{value:" 的取值。",paraId:75,tocIndex:23},{value:"蒙层描边虚线。可以参考 ",paraId:77,tocIndex:24},{value:"lineDash",paraId:78,tocIndex:24},{value:" 的取值。",paraId:77,tocIndex:24},{value:"锚点填充色。",paraId:79,tocIndex:25},{value:"锚点填充色透明度。",paraId:80,tocIndex:26},{value:"锚点描边色。",paraId:81,tocIndex:27},{value:"锚点描边色透明度。",paraId:82,tocIndex:28},{value:"锚点描边线宽。",paraId:83,tocIndex:29},{value:"锚点尺寸。暂时我们仅支持圆形锚点，因此该属性等同于圆的半径。",paraId:84,tocIndex:30},{value:"辅助绘制组件样式。初始值通过构造函数 ",paraId:85,tocIndex:31},{value:"drawStyle",paraId:85,tocIndex:31},{value:" 参数指定，后续可通过 ",paraId:85,tocIndex:31},{value:"updateDrawerStyle",paraId:86,tocIndex:31},{value:" 更新。",paraId:85,tocIndex:31},{value:"例如我们想指定矩形绘制组件的描边颜色：",paraId:87,tocIndex:31},{value:"const annotationPlugin = new AnnotationPlugin({\n    drawerStyle: {\n        rectStroke: 'red',\n    },\n});\n",paraId:88,tocIndex:31},{value:"可参考 ",paraId:89,tocIndex:32},{value:"fill",paraId:90,tocIndex:32},{value:"，默认值为 ",paraId:89,tocIndex:32},{value:"'none'",paraId:89,tocIndex:32},{value:"。",paraId:89,tocIndex:32},{value:"可参考 ",paraId:91,tocIndex:33},{value:"fillOpacity",paraId:92,tocIndex:33},{value:"，默认值为 ",paraId:91,tocIndex:33},{value:"1",paraId:91,tocIndex:33},{value:"。",paraId:91,tocIndex:33},{value:"可参考 ",paraId:93,tocIndex:34},{value:"stroke",paraId:94,tocIndex:34},{value:"，默认值为 ",paraId:93,tocIndex:34},{value:"'#FAAD14'",paraId:93,tocIndex:34},{value:"。",paraId:93,tocIndex:34},{value:"可参考 ",paraId:95,tocIndex:35},{value:"strokeOpacity",paraId:96,tocIndex:35},{value:"，默认值为 ",paraId:95,tocIndex:35},{value:"1",paraId:95,tocIndex:35},{value:"。",paraId:95,tocIndex:35},{value:"可参考 ",paraId:97,tocIndex:36},{value:"strokeWidth",paraId:98,tocIndex:36},{value:"，默认值为 ",paraId:97,tocIndex:36},{value:"2.5",paraId:97,tocIndex:36},{value:"。",paraId:97,tocIndex:36},{value:"可参考 ",paraId:99,tocIndex:37},{value:"lineDash",paraId:100,tocIndex:37},{value:"，默认值为 ",paraId:99,tocIndex:37},{value:"6",paraId:99,tocIndex:37},{value:"。",paraId:99,tocIndex:37},{value:"折线已绘制顶点尺寸。暂时我们仅支持圆形顶点，因此该属性等同于圆的半径，默认值为 ",paraId:101,tocIndex:38},{value:"6",paraId:101,tocIndex:38},{value:"。",paraId:101,tocIndex:38},{value:"以下图为例，空心圆为已绘制顶点，实线为已绘制线段；实心圆为正在绘制的顶点，虚线为正在绘制的线段。",paraId:102,tocIndex:38},{value:"可参考 ",paraId:103,tocIndex:39},{value:"fill",paraId:104,tocIndex:39},{value:"，默认值为 ",paraId:103,tocIndex:39},{value:"'#FFFFFF'",paraId:103,tocIndex:39},{value:"。",paraId:103,tocIndex:39},{value:"可参考 ",paraId:105,tocIndex:40},{value:"fillOpacity",paraId:106,tocIndex:40},{value:"，默认值为 ",paraId:105,tocIndex:40},{value:"1",paraId:105,tocIndex:40},{value:"。",paraId:105,tocIndex:40},{value:"可参考 ",paraId:107,tocIndex:41},{value:"stroke",paraId:108,tocIndex:41},{value:"，默认值为 ",paraId:107,tocIndex:41},{value:"'#FAAD14'",paraId:107,tocIndex:41},{value:"。",paraId:107,tocIndex:41},{value:"可参考 ",paraId:109,tocIndex:42},{value:"strokeOpacity",paraId:110,tocIndex:42},{value:"，默认值为 ",paraId:109,tocIndex:42},{value:"1",paraId:109,tocIndex:42},{value:"。",paraId:109,tocIndex:42},{value:"可参考 ",paraId:111,tocIndex:43},{value:"strokeWidth",paraId:112,tocIndex:43},{value:"，默认值为 ",paraId:111,tocIndex:43},{value:"2",paraId:111,tocIndex:43},{value:"。",paraId:111,tocIndex:43},{value:"折线已绘制线段颜色，可参考 ",paraId:113,tocIndex:44},{value:"stroke",paraId:114,tocIndex:44},{value:"，默认值为 ",paraId:113,tocIndex:44},{value:"'#FAAD14'",paraId:113,tocIndex:44},{value:"。",paraId:113,tocIndex:44},{value:"折线已绘制线段线宽，可参考 ",paraId:115,tocIndex:45},{value:"strokeWidth",paraId:116,tocIndex:45},{value:"，默认值为 ",paraId:115,tocIndex:45},{value:"2",paraId:115,tocIndex:45},{value:"。",paraId:115,tocIndex:45},{value:"折线正在绘制顶点的尺寸。暂时我们仅支持圆形顶点，因此该属性等同于圆的半径，默认值为 ",paraId:117,tocIndex:46},{value:"6",paraId:117,tocIndex:46},{value:"。",paraId:117,tocIndex:46},{value:"可参考 ",paraId:118,tocIndex:47},{value:"fill",paraId:119,tocIndex:47},{value:"，默认值为 ",paraId:118,tocIndex:47},{value:"'#FFFFFF'",paraId:118,tocIndex:47},{value:"。",paraId:118,tocIndex:47},{value:"可参考 ",paraId:120,tocIndex:48},{value:"fillOpacity",paraId:121,tocIndex:48},{value:"，默认值为 ",paraId:120,tocIndex:48},{value:"1",paraId:120,tocIndex:48},{value:"。",paraId:120,tocIndex:48},{value:"可参考 ",paraId:122,tocIndex:49},{value:"stroke",paraId:123,tocIndex:49},{value:"，默认值为 ",paraId:122,tocIndex:49},{value:"'#FAAD14'",paraId:122,tocIndex:49},{value:"。",paraId:122,tocIndex:49},{value:"可参考 ",paraId:124,tocIndex:50},{value:"strokeOpacity",paraId:125,tocIndex:50},{value:"，默认值为 ",paraId:124,tocIndex:50},{value:"0.2",paraId:124,tocIndex:50},{value:"。",paraId:124,tocIndex:50},{value:"可参考 ",paraId:126,tocIndex:51},{value:"strokeWidth",paraId:127,tocIndex:51},{value:"，默认值为 ",paraId:126,tocIndex:51},{value:"2",paraId:126,tocIndex:51},{value:"。",paraId:126,tocIndex:51},{value:"折线正在绘制线段颜色，可参考 ",paraId:128,tocIndex:52},{value:"stroke",paraId:129,tocIndex:52},{value:"，默认值为 ",paraId:128,tocIndex:52},{value:"'#FAAD14'",paraId:128,tocIndex:52},{value:"。",paraId:128,tocIndex:52},{value:"折线正在绘制线段线宽，可参考 ",paraId:130,tocIndex:53},{value:"strokeWidth",paraId:131,tocIndex:53},{value:"，默认值为 ",paraId:130,tocIndex:53},{value:"2.5",paraId:130,tocIndex:53},{value:"。",paraId:130,tocIndex:53},{value:"以下 API 可以通过插件实例调用，例如：",paraId:132,tocIndex:54},{value:"const plugin = new PluginAnnotation();\n\ncircle.style.selectable = true;\nplugin.selectDisplayObject(circle);\n",paraId:133,tocIndex:54},{value:"设置是否开启绘制模式。",paraId:134,tocIndex:55},{value:"// 进入绘制模式\nplugin.setDrawingMode(true);\n\n// 进入编辑模式\nplugin.setDrawingMode(false);\n",paraId:135,tocIndex:55},{value:"在绘制模式下，我们提供以下图形的绘制能力：",paraId:136,tocIndex:56},{value:"circle",paraId:137,tocIndex:56},{value:"rect",paraId:137,tocIndex:56},{value:"polyline",paraId:137,tocIndex:56},{value:"polygon",paraId:137,tocIndex:56},{value:"例如绘制矩形：",paraId:138,tocIndex:56},{value:"plugin.setDrawingMode(true);\nplugin.setDrawer('rect');\n",paraId:139,tocIndex:56},{value:"选中一个图形。并不会对其他已选择的图形应用取消操作。",paraId:140,tocIndex:57},{value:"plugin.selectedDisplayObject(circle);\n",paraId:141,tocIndex:57},{value:"取消选中一个图形。",paraId:142,tocIndex:58},{value:"plugin.deselectedDisplayObject(circle);\n",paraId:143,tocIndex:58},{value:"获取当前选中的图形列表。",paraId:144,tocIndex:59},{value:"plugin.getSelectedDisplayObjects(); // [circle, path]\n",paraId:145,tocIndex:59},{value:"实时更新交互组件的",paraId:146,tocIndex:60},{value:"样式",paraId:147,tocIndex:60},{value:"，例如在 ",paraId:146,tocIndex:60},{value:"示例",paraId:148,tocIndex:60},{value:" 中修改蒙层填充色：",paraId:146,tocIndex:60},{value:"plugin.updateSelectableStyle({\n    selectionFill: 'red',\n});\n",paraId:149,tocIndex:60},{value:"更新辅助绘制组件的样式，例如：",paraId:150,tocIndex:61},{value:"plugin.updateDrawerStyle({\n    rectStroke: 'red',\n});\n",paraId:151,tocIndex:61},{value:"有时目标图形的定义发生了修改，需要让辅助操作组件感知并重新生成，此时可以手动调用该方法：",paraId:152,tocIndex:62},{value:"circle.style.cx = 100;\ncircle.style.cy = 100;\n\nplugin.markSelectableUIAsDirty(circle);\n",paraId:153,tocIndex:62},{value:"在不同模式下会触发不同事件，例如绘制模式下会在插件上触发，而编辑模式下会在图形上触发。",paraId:154,tocIndex:63},{value:"不同于 Fabric.js 的“自由绘制”模式，在插件上监听不同绘制阶段触发的事件，获取事件对象中包含的几何信息，自行创建对应图形并应用自定义样式完成绘制。",paraId:155,tocIndex:64},{value:"支持以下事件：",paraId:156,tocIndex:64},{value:"export enum DrawerEvent {\n  START = 'draw:start',\n  MOVE = 'draw:move',\n  MODIFIED = 'draw:modify',\n  COMPLETE = 'draw:complete',\n  CANCEL = 'draw:cancel',\n}\n",paraId:157,tocIndex:64},{value:"事件对象包含如下数据，其中关键属性为：",paraId:158,tocIndex:64},{value:"type",paraId:159,tocIndex:64},{value:" 绘制图形类型。目前支持 ",paraId:159,tocIndex:64},{value:"rect",paraId:159,tocIndex:64},{value:" ",paraId:159,tocIndex:64},{value:"polyline",paraId:159,tocIndex:64},{value:" ",paraId:159,tocIndex:64},{value:"polygon",paraId:159,tocIndex:64},{value:"path",paraId:159,tocIndex:64},{value:" 绘制图形顶点列表，形如：",paraId:159,tocIndex:64},{value:"[{ x: 0, y: 0 }, { x: 100, y: 100 }...]",paraId:159,tocIndex:64},{value:"plugin.addEventListener(DrawerEvent.COMPLETE, ({ type, path }) => {});\n",paraId:160,tocIndex:64},{value:"在结束绘制后，辅助绘制 UI 会自动隐藏，此时我们可以使用顶点数据绘制最终图形。",paraId:161,tocIndex:68},{value:"plugin.addEventListener(DrawerEvent.COMPLETE, ({ type, path }) => {\n    // use any brush you preferred\n    const brush = {\n        stroke: 'black',\n        strokeWidth: 10,\n        selectable: true,\n    };\n\n    if (type === 'polyline') {\n        const polyline = new Polyline({\n            style: {\n                ...brush,\n                points: path.map(({ x, y }) => [x, y]),\n            },\n        });\n        canvas.appendChild(polyline);\n    }\n});\n",paraId:162,tocIndex:68},{value:"当图形被选中、取消选中、移动、改变尺寸时，会触发对应事件。",paraId:163,tocIndex:69},{value:"export enum SelectableEvent {\n  SELECTED = 'selected',\n  DESELECTED = 'deselected',\n  MODIFIED = 'modified',\n  MOVED = 'moved',\n  MOVING = 'moving',\n}\n",paraId:164,tocIndex:69},{value:"当目标图形被选中时触发。在 ",paraId:165,tocIndex:70},{value:"示例",paraId:166,tocIndex:70},{value:" 中，我们监听了图片的选中事件：",paraId:165,tocIndex:70},{value:"import { SelectableEvent } from '@antv/g-plugin-annotation';\n\nimage.addEventListener('selected', () => {});\n// or\nimage.addEventListener(SelectableEvent.SELECTED, () => {});\n",paraId:167,tocIndex:70},{value:"当目标图形被取消选中时触发。在 ",paraId:168,tocIndex:71},{value:"示例",paraId:169,tocIndex:71},{value:" 中，我们监听了图片的取消选中事件：",paraId:168,tocIndex:71},{value:"import { SelectableEvent } from '@antv/g-plugin-annotation';\n\nimage.addEventListener('deselected', () => {});\n// or\nimage.addEventListener(SelectableEvent.DESELECTED, () => {});\n",paraId:170,tocIndex:71},{value:"拖拽蒙层时目标图形会跟着移动，此过程会持续触发移动中事件，类似 ",paraId:171,tocIndex:72},{value:"g-plugin-dragndrop",paraId:172,tocIndex:72},{value:" 中的 ",paraId:171,tocIndex:72},{value:"dragging",paraId:171,tocIndex:72},{value:"：",paraId:171,tocIndex:72},{value:"import { SelectableEvent } from '@antv/g-plugin-annotation';\n\nimage.addEventListener('moving', () => {});\n// or\nimage.addEventListener(SelectableEvent.MOVING, () => {});\n",paraId:173,tocIndex:72},{value:"该事件对象上携带以下信息：",paraId:174,tocIndex:72},{value:"image.addEventListener('moving', (e) => {\n    const { movingX, movingY } = e.detail;\n});\n",paraId:175,tocIndex:72},{value:"当拖拽结束后，会触发该事件，类似 ",paraId:176,tocIndex:73},{value:"g-plugin-dragndrop",paraId:177,tocIndex:73},{value:" 中的 ",paraId:176,tocIndex:73},{value:"dragend",paraId:176,tocIndex:73},{value:"：",paraId:176,tocIndex:73},{value:"import { SelectableEvent } from '@antv/g-plugin-annotation';\n\nimage.addEventListener('moved', () => {});\n// or\nimage.addEventListener(SelectableEvent.MOVED, () => {});\n",paraId:178,tocIndex:73},{value:"在锚点上拖拽可以对图形进行缩放，此过程也会持续触发修改事件：",paraId:179,tocIndex:74},{value:"import { SelectableEvent } from '@antv/g-plugin-annotation';\n\nimage.addEventListener('modified', () => {});\n// or\nimage.addEventListener(SelectableEvent.MODIFED, () => {});\n",paraId:180,tocIndex:74}]},15844:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(54887);const d=[{value:"支持 ",paraId:0},{value:"Box2D",paraId:0},{value:" 物理引擎（仅支持刚体）。2D 图形初始化后开始仿真，除了受重力和表面摩擦力，在任意时刻也可以施加外力改变图形的位置和旋转角度。",paraId:0},{value:"运行时加载 WASM 方式使用，entry 使用 UMD：",paraId:1},{value:"2.4 版本 ",paraId:2},{value:"https://github.com/Birch-san/box2d-wasm",paraId:2},{value:"2.3 & 2.2 版本 ",paraId:2},{value:"https://github.com/kripken/box2d.js",paraId:2},{value:"目前使用 Box2D 最新版 2.4，参考文档：",paraId:3},{value:"https://box2d.org/documentation/。",paraId:3},{value:"支持以下 2D 图形：",paraId:4},{value:"Circle",paraId:5},{value:"、",paraId:4},{value:"Rect",paraId:6},{value:"、",paraId:4},{value:"Line",paraId:7},{value:"、",paraId:4},{value:"Image",paraId:8},{value:"、",paraId:4},{value:"Polygon",paraId:9},{value:"在该",paraId:10},{value:"示例",paraId:11},{value:"中，我们创建了一系列动态物体，让它们进行自由落体，最终停留在“U 形槽”中。",paraId:10},{value:"创建插件并在渲染器中注册：",paraId:12,tocIndex:0},{value:"import { Plugin as PluginBox2D } from '@antv/g-plugin-box2d';\nrenderer.registerPlugin(new PluginBox2D());\n",paraId:13,tocIndex:0},{value:"在 2D 图形中使用相关物理属性：",paraId:14,tocIndex:0},{value:"new Circle({\n    style: {\n        rigid: 'dynamic', // 动态物体，参与受力计算\n        density: 10, // 密度：10 千克/平方米\n        r: 10, // 半径：对应物理世界中 10 米\n    },\n});\n",paraId:15,tocIndex:0},{value:"全局物理世界配置。",paraId:16,tocIndex:1},{value:"重力方向向量，默认值为 ",paraId:17,tocIndex:2},{value:"[0, 100]",paraId:17,tocIndex:2},{value:"。",paraId:17,tocIndex:2},{value:"例如设置成 ",paraId:18,tocIndex:2},{value:"[100, 100]",paraId:18,tocIndex:2},{value:"，物体会自然向右下角运动：",paraId:18,tocIndex:2},{value:"new PluginBox2D({\n  gravity: [100, 100],\n}),\n",paraId:19,tocIndex:2},{value:"仿真时间间隔，默认值为 ",paraId:20,tocIndex:3},{value:"1/60",paraId:20,tocIndex:3},{value:"计算加速度迭代次数，默认值为 ",paraId:21,tocIndex:4},{value:"8",paraId:21,tocIndex:4},{value:"，越高计算开销越大",paraId:21,tocIndex:4},{value:"计算位置迭代次数，默认值为 ",paraId:22,tocIndex:5},{value:"3",paraId:22,tocIndex:5},{value:"，越高计算开销越大",paraId:22,tocIndex:5},{value:"可以监听两个物体表面接触：",paraId:23,tocIndex:6},{value:"new PluginBox2D({\n  onContact: (objectA, objectB) => {\n    // 两个物体表面发生了接触\n  }\n}),\n",paraId:24,tocIndex:6},{value:"https://box2d.org/documentation/md__d_1__git_hub_box2d_docs_dynamics.html#autotoc_md105",paraId:25,tocIndex:6},{value:"Box2D 使用如下物理单位：米、千克和秒。",paraId:26,tocIndex:7},{value:"https://box2d.org/documentation/md__d_1__git_hub_box2d_docs_loose_ends.html#autotoc_md124",paraId:27,tocIndex:7},{value:"Box2D uses MKS (meters, kilograms, and seconds) units and radians for angles.",paraId:28,tocIndex:7},{value:"以下属性大部分都支持运行时修改，例如修改密度：",paraId:29,tocIndex:7},{value:"circle.style.density = 100;\n",paraId:30,tocIndex:7},{value:"刚体类型：",paraId:31,tocIndex:8},{value:"static 静态物体，例如地面",paraId:32,tocIndex:8},{value:"dynamic 动态物体，计算受力",paraId:32,tocIndex:8},{value:"密度，千克/平方米。静态物体为 0。",paraId:33,tocIndex:9},{value:"线速度，默认值为 ",paraId:34,tocIndex:10},{value:"[0, 0]",paraId:34,tocIndex:10},{value:"。",paraId:34,tocIndex:10},{value:"角速度，默认值为 ",paraId:35,tocIndex:11},{value:"0",paraId:35,tocIndex:11},{value:"。",paraId:35,tocIndex:11},{value:"重力因子，默认值为 ",paraId:36,tocIndex:12},{value:"1",paraId:36,tocIndex:12},{value:"。 ",paraId:36,tocIndex:12},{value:"https://box2d.org/documentation/md__d_1__git_hub_box2d_docs_dynamics.html#autotoc_md60",paraId:36,tocIndex:12},{value:"阻尼，默认值为 ",paraId:37,tocIndex:13},{value:"0",paraId:37,tocIndex:13},{value:"。",paraId:37,tocIndex:13},{value:"https://box2d.org/documentation/md__d_1__git_hub_box2d_docs_dynamics.html#autotoc_md59",paraId:37,tocIndex:13},{value:"角阻尼，默认值为 ",paraId:38,tocIndex:14},{value:"0",paraId:38,tocIndex:14},{value:"。",paraId:38,tocIndex:14},{value:"https://box2d.org/documentation/md__d_1__git_hub_box2d_docs_dynamics.html#autotoc_md59",paraId:38,tocIndex:14},{value:"固定旋转角度，默认值为 ",paraId:39,tocIndex:15},{value:"false",paraId:39,tocIndex:15},{value:"。",paraId:39,tocIndex:15},{value:"https://box2d.org/documentation/md__d_1__git_hub_box2d_docs_dynamics.html#autotoc_md62",paraId:39,tocIndex:15},{value:"默认值为 ",paraId:40,tocIndex:16},{value:"false",paraId:40,tocIndex:16},{value:"。",paraId:40,tocIndex:16},{value:"https://box2d.org/documentation/md__d_1__git_hub_box2d_docs_dynamics.html#autotoc_md63",paraId:40,tocIndex:16},{value:"摩擦力，取值范围为 ",paraId:41,tocIndex:17},{value:"[0 - 1]",paraId:41,tocIndex:17},{value:"恢复力，取值范围为 ",paraId:42,tocIndex:18},{value:"[0 - 1]",paraId:42,tocIndex:18},{value:"。例如一个球落向地面，恢复力为 0 时则不会弹起。",paraId:42,tocIndex:18},{value:"除了通过初始化参数进行仿真，在任意时刻都可以通过施加外力，改变物体的位置和旋转角度。",paraId:43,tocIndex:19},{value:"https://box2d.org/documentation/md__d_1__git_hub_box2d_docs_dynamics.html#autotoc_md71",paraId:44,tocIndex:19},{value:"void b2Body::ApplyForce(const b2Vec2& force, const b2Vec2& point);\nvoid b2Body::ApplyTorque(float torque);\nvoid b2Body::ApplyLinearImpulse(const b2Vec2& impulse, const b2Vec2& point);\nvoid b2Body::ApplyAngularImpulse(float impulse);\n",paraId:45,tocIndex:19},{value:"const plugin = new PluginBox2D();\nplugin.applyForce(circle, [0, 0], [0, 0]);\n",paraId:46,tocIndex:20},{value:"物理间的连接会导致作用力的发生。Box2D 提供了一系列连接的描述。",paraId:47,tocIndex:24},{value:"https://box2d.org/documentation/md__d_1__git_hub_box2d_docs_dynamics.html#autotoc_md82",paraId:48,tocIndex:24},{value:"使用 liquidfun：",paraId:49,tocIndex:25},{value:"https://github.com/Birch-san/box2d-wasm/blob/c04514c040/README.md#alternative-distributions",paraId:49,tocIndex:25}]},96371:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(7270);const d=[{value:"使用 CanvasRenderingContext2D 绘制各个图形的路径，例如使用 ",paraId:0},{value:"arcTo()",paraId:0},{value:" 绘制 ",paraId:0},{value:"Circle",paraId:1},{value:"。",paraId:0},{value:"除了用于最终渲染，在使用 ",paraId:2},{value:"isPointInPath()",paraId:2},{value:" 前也需要在离屏画布中绘制。",paraId:2},{value:"该插件提供两个 Token，使用时通过 Token 注入：",paraId:3,tocIndex:0},{value:"export const PathGeneratorFactory = Syringe.defineToken('PathGeneratorFactory');\nexport const PathGenerator = Syringe.defineToken('PathGenerator');\n",paraId:4,tocIndex:0},{value:"例如目前在 ",paraId:5,tocIndex:1},{value:"g-plugin-canvas-renderer",paraId:6,tocIndex:1},{value:" 和 ",paraId:5,tocIndex:1},{value:"g-plugin-canvas-picker",paraId:7,tocIndex:1},{value:" 这两个插件中都能看到通过 ",paraId:5,tocIndex:1},{value:"PathGeneratorFactory",paraId:5,tocIndex:1},{value:" 这个 token 将工厂方法注入，传入 ",paraId:5,tocIndex:1},{value:"nodeName",paraId:8,tocIndex:1},{value:" 就能得到对应图形路径的绘制方法：",paraId:5,tocIndex:1},{value:"@inject(PathGeneratorFactory)\nprivate pathGeneratorFactory: (tagName: Shape | string) => PathGenerator<any>;\n\nconst circlePathGenerator = this.pathGeneratorFactory(Shape.CIRCLE);\n",paraId:9,tocIndex:1},{value:"具体到每一种基础图形的路径绘制方法，它接受 CanvasRenderingContext2D 上下文和解析后的图形样式属性作为参数：",paraId:10,tocIndex:2},{value:"export type PathGenerator<T extends ParsedBaseStyleProps> = (\n  context: CanvasRenderingContext2D,\n  attributes: T,\n) => void;\n",paraId:11,tocIndex:2},{value:"以 Circle 为例：",paraId:12,tocIndex:2},{value:"function generatePath(\n    context: CanvasRenderingContext2D,\n    parsedStyle: ParsedCircleStyleProps,\n) {\n    const { r } = parsedStyle;\n    context.arc(r.value, r.value, r.value, 0, Math.PI * 2, false);\n}\n",paraId:13,tocIndex:2}]},89589:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(54910);const d=[{value:"提供基于 Canvas2D 的拾取能力。",paraId:0},{value:"g-canvas",paraId:1,tocIndex:0},{value:" 渲染器默认内置，因此无需手动引入。",paraId:1,tocIndex:0},{value:"import { Renderer as CanvasRenderer } from '@antv/g-canvas';\n// 创建 Canvas 渲染器，其中内置了该插件\nconst canvasRenderer = new CanvasRenderer();\n",paraId:2,tocIndex:0},{value:"基于 Canvas2D API 实现的拾取：",paraId:3,tocIndex:1},{value:"使用 R-Tree 空间索引查找拾取点命中的一系列图形包围盒",paraId:4,tocIndex:1},{value:"在这些图形中找到最顶层的一个图形，依据 ",paraId:4,tocIndex:1},{value:"z-index",paraId:4,tocIndex:1},{value:"使用数学计算精确判定是否命中该图形，例如 Circle 测算到圆心距离是否小于半径",paraId:4,tocIndex:1},{value:"该方案基于 CPU，因此优化点在于包围盒相交运算是否足够快。",paraId:5,tocIndex:1}]},95568:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(87801);const d=[{value:"提供基于 Canvas2D 的渲染能力。",paraId:0},{value:"g-canvas",paraId:1,tocIndex:0},{value:" 渲染器默认内置，因此无需手动引入。",paraId:2,tocIndex:0},{value:"import { Renderer as CanvasRenderer } from '@antv/g-canvas';\n// 创建 Canvas 渲染器，其中内置了该插件\nconst canvasRenderer = new CanvasRenderer();\n",paraId:3,tocIndex:0},{value:"在使用 ",paraId:4,tocIndex:2},{value:"CanvasRenderingContext2D",paraId:4,tocIndex:2},{value:" 渲染基础图形时，在使用 ",paraId:4,tocIndex:2},{value:"g-plugin-canvas-path-generator",paraId:5,tocIndex:2},{value:" 生成图形路径之后，实现该接口即可完成绘制样式。",paraId:4,tocIndex:2},{value:"export interface StyleRenderer {\n    render: (\n        context: CanvasRenderingContext2D,\n        parsedStyle: ParsedBaseStyleProps,\n        object: DisplayObject,\n        renderingService: RenderingService,\n    ) => void;\n}\n",paraId:6,tocIndex:2},{value:"我们为不同类型的图形提供了不同的扩展点。例如在 ",paraId:7,tocIndex:2},{value:"g-plugin-rough-canvas-renderer",paraId:8,tocIndex:2},{value:" 中，我们使用 rough.js 提供的 API 为 ",paraId:7,tocIndex:2},{value:"Circle",paraId:9,tocIndex:2},{value:" 增加手绘风格的样式：",paraId:7,tocIndex:2},{value:"@singleton({\n  token: CanvasRenderer.CircleRendererContribution,\n})\nexport class CircleRenderer implements CanvasRenderer.StyleRenderer {\n  render(\n    context: CanvasRenderingContext2D,\n    parsedStyle: ParsedCircleStyleProps,\n    object: DisplayObject<any, any>,\n  ) {\n    const { r } = parsedStyle as ParsedCircleStyleProps;\n    // rough.js use diameter instead of radius\n    // @see https://github.com/rough-stuff/rough/wiki#circle-x-y-diameter--options\n    context.roughCanvas.circle(r.value, r.value, r.value * 2, generateRoughOptions(object));\n  }\n}\n",paraId:10,tocIndex:2}]},12290:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(81052);const d=[{value:"使用 ",paraId:0},{value:"Skia",paraId:0},{value:" 绘制 2D 图形。在运行时异步加载 WASM 格式的 ",paraId:0},{value:"Canvaskit",paraId:0},{value:"，将 ",paraId:0},{value:"WebGL2RenderingContext",paraId:0},{value:" 封装成 ",paraId:0},{value:"SkSurface",paraId:0},{value:" ，进而通过页面上的 ",paraId:0},{value:"<canvas>",paraId:0},{value:" 元素进行绘制。",paraId:0},{value:"Skia 相比 Canvas2D API 提供了更多特性，例如文本段落排版、",paraId:1},{value:"Lottie 动画",paraId:1},{value:"等。除了 Chrome 和 Android，一些跨平台的方案例如 ",paraId:1},{value:"Flutter",paraId:1},{value:"、",paraId:1},{value:"Weex",paraId:1},{value:" 中也使用了它作为底层渲染引擎。",paraId:1},{value:"g-canvaskit",paraId:2,tocIndex:0},{value:" 渲染器默认内置，因此无需手动引入。",paraId:2,tocIndex:0},{value:"import { Renderer as CanvaskitRenderer } from '@antv/g-canvaskit';\n// 创建 CanvasKit 渲染器，其中内置了该插件\nconst canvaskitRenderer = new CanvaskitRenderer();\n",paraId:3,tocIndex:0},{value:"Lottie",paraId:4,tocIndex:2},{value:" 动画通过 After Effects 的 ",paraId:4,tocIndex:2},{value:"Bodymovin",paraId:4,tocIndex:2},{value:" 插件创建，导出成 JSON 格式。",paraId:4,tocIndex:2},{value:"完整方法签名如下，其中包含以下参数：",paraId:5,tocIndex:2},{value:"name 动画名称，必填",paraId:6,tocIndex:2},{value:"jsonStr JSON 格式的 Lottie 描述文件，必填",paraId:6,tocIndex:2},{value:"bounds 展示区域，接受的数据格式为 ",paraId:6,tocIndex:2},{value:"[left, top, width, height]",paraId:6,tocIndex:2},{value:"，可选。不填写会尝试使用描述文件中定义的大小，即 ",paraId:6,tocIndex:2},{value:"[0, 0, width, height]",paraId:6,tocIndex:2},{value:"assets 额外的资源文件，可选。",paraId:6,tocIndex:2},{value:"返回一个 ",paraId:7,tocIndex:2},{value:"ManagedSkottieAnimation",paraId:7,tocIndex:2},{value:" 对象",paraId:7,tocIndex:2},{value:"playAnimation(name: string, jsonStr: string, bounds?: InputRect, assets?: any): ManagedSkottieAnimation;\n",paraId:8,tocIndex:2},{value:"首先创建渲染器并通过 ",paraId:9,tocIndex:2},{value:"getPlugin",paraId:10,tocIndex:2},{value:" 获取 ",paraId:9,tocIndex:2},{value:"g-plugin-canvaskit-renderer",paraId:11,tocIndex:2},{value:" 插件：",paraId:9,tocIndex:2},{value:"import { Renderer } from '@antv/g-canvaskit';\n\n// 创建渲染器\nconst canvaskitRenderer = new Renderer({\n    wasmDir: '/',\n});\n// 获取渲染插件\nconst plugin = canvaskitRenderer.getPlugin('canvaskit-renderer');\n",paraId:12,tocIndex:2},{value:"然后等待画布初始化完成，并加载 Lottie 动画描述文件：",paraId:13,tocIndex:2},{value:"(async () => {\n    const cdn = 'https://storage.googleapis.com/skia-cdn/misc/';\n\n    const [_, jsonstr] = await Promise.all([\n        canvas.ready,\n        fetch(cdn + 'lego_loader.json').then((response) => response.text()),\n    ]);\n\n    const animation = plugin.playAnimation(\n        'sk_legos',\n        jsonstr,\n        [-50, 0, 350, 300],\n    );\n})();\n",paraId:14,tocIndex:2},{value:"如果想移除动画，可以在返回的动画对象上调用 ",paraId:15,tocIndex:2},{value:"delete()",paraId:15,tocIndex:2},{value:" 方法：",paraId:15,tocIndex:2},{value:"animation.delete();\n",paraId:16,tocIndex:2},{value:"例如烟火、火焰等粒子特效需要生成大量“粒子”并应用动画，通常在 GPU 中通过 Shader 编程实现，例如用以改变每个粒子位置的插值计算，应当放在 GPU 而非在 CPU 中完成。",paraId:17,tocIndex:3},{value:"CanvasKit 提供了基于 Skia 的编程语言 ",paraId:18,tocIndex:3},{value:"SkSL(Skia’s shading language)",paraId:18,tocIndex:3},{value:" 实现，语法上十分接近 GLSL，在 Shader 中用以控制粒子的生成以及动画，对于没接触过 Shader 编程的开发者存在一定门槛。",paraId:18,tocIndex:3},{value:"在该",paraId:19,tocIndex:3},{value:"示例",paraId:20,tocIndex:3},{value:"中，我们实现了一些粒子特效：",paraId:19,tocIndex:3},{value:"首先创建渲染器并通过 ",paraId:21,tocIndex:3},{value:"getPlugin",paraId:22,tocIndex:3},{value:" 获取 ",paraId:21,tocIndex:3},{value:"g-plugin-canvaskit-renderer",paraId:23,tocIndex:3},{value:" 插件：",paraId:21,tocIndex:3},{value:"import { Renderer } from '@antv/g-canvaskit';\n\n// 创建渲染器\nconst canvaskitRenderer = new Renderer({\n    wasmDir: '/',\n});\n// 获取渲染插件\nconst plugin = canvaskitRenderer.getPlugin('canvaskit-renderer');\n",paraId:24,tocIndex:3},{value:"然后调用插件的 ",paraId:25,tocIndex:3},{value:"createParticles",paraId:26,tocIndex:3},{value:" 创建粒子效果，在每一帧的回调函数中对画布进行变换以调整粒子的位置，最后通过 ",paraId:25,tocIndex:3},{value:"start",paraId:27,tocIndex:3},{value:" 开始生成粒子：",paraId:25,tocIndex:3},{value:"const textParticles = plugin.createParticles(JSON.stringify(text), (canvas) => {\n    canvas.translate(250, 250);\n});\ntextParticles.start(Date.now() / 1000.0, true);\n",paraId:28,tocIndex:3},{value:"最后我们来看关键的粒子效果定义：",paraId:29,tocIndex:3},{value:"MaxCount 粒子数目",paraId:30,tocIndex:3},{value:"Drawable 粒子的类型，通常使用 ",paraId:30,tocIndex:3},{value:"'SkCircleDrawable'",paraId:30,tocIndex:3},{value:" 即可，可以修改大小",paraId:30,tocIndex:3},{value:"Code SkSL 代码，用以控制粒子的生命周期，例如每一帧中位置和颜色应该如何改变",paraId:30,tocIndex:3},{value:"Bindings",paraId:30,tocIndex:3},{value:"const text = {\n    MaxCount: 2000,\n    Drawable: {\n        Type: 'SkCircleDrawable',\n        Radius: 1,\n    },\n    Code: [\n        'void effectSpawn(inout Effect effect) {',\n        '  effect.rate = 1000;',\n        '}',\n        '',\n        'void spawn(inout Particle p) {',\n        '  p.lifetime = mix(1, 3, rand(p.seed));',\n        '  float a = radians(mix(250, 290, rand(p.seed)));',\n        '  float s = mix(10, 30, rand(p.seed));',\n        '  p.vel.x = cos(a) * s;',\n        '  p.vel.y = sin(a) * s;',\n        '  p.pos += text(rand(p.seed)).xy;',\n        '}',\n        '',\n        'void update(inout Particle p) {',\n        '  float4 startColor = float4(1, 0.196, 0.078, 1);',\n        '  float4 endColor   = float4(1, 0.784, 0.078, 1);',\n        '  p.color = mix(startColor, endColor, p.age);',\n        '}',\n        '',\n    ],\n    Bindings: [\n        {\n            Type: 'SkTextBinding',\n            Name: 'text',\n            Text: 'AntV',\n            FontSize: 96,\n        },\n    ],\n};\n",paraId:31,tocIndex:3},{value:"如果想移除粒子效果，可以在返回的对象上调用 ",paraId:32,tocIndex:3},{value:"delete()",paraId:32,tocIndex:3},{value:" 方法：",paraId:32,tocIndex:3},{value:"particles.delete();\n",paraId:33,tocIndex:3}]},78708:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(23166);const d=[{value:"为 3D 场景提供相机交互，内部使用 Hammer.js 响应鼠标移动、滚轮事件。根据不同的 ",paraId:0},{value:"相机类型",paraId:1},{value:"，提供不同的交互效果。",paraId:0},{value:"创建 ",paraId:2,tocIndex:0},{value:"g-webgl",paraId:2,tocIndex:0},{value:" 渲染器，注册该插件：",paraId:2,tocIndex:0},{value:"import { Renderer as WebGLRenderer } from '@antv/g-webgl';\nimport { Plugin } from '@antv/g-plugin-control';\n// 创建 WebGL 渲染器\nconst webglRenderer = new WebGLRenderer();\n// 注册 3D 插件\nwebglRenderer.registerPlugin(new Plugin());\n",paraId:3,tocIndex:0},{value:"完整示例",paraId:4,tocIndex:1},{value:"：",paraId:5,tocIndex:1}]},43087:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(44859);const d=[{value:"在场景图中查找节点时，我们可以使用一些类似 DOM API 的",paraId:0},{value:"高级查询方式",paraId:1},{value:"：",paraId:0},{value:"getElementById",paraId:2},{value:" 在当前节点子树下按 id 查找单一元素",paraId:2},{value:"getElementsByName",paraId:2},{value:" 在当前节点子树下按 name 查找元素列表",paraId:2},{value:"getElementsByClassName",paraId:2},{value:" 在当前节点子树下按 className 查找元素列表",paraId:2},{value:"getElementsByTagName",paraId:2},{value:" 在当前节点子树下按 tagName 查找元素列表",paraId:2},{value:"假设我们构建了如下场景图：",paraId:3},{value:"solarSystem<Group>\n   |    |\n   |   sun<Circle name='sun' />\n   |\n earthOrbit<Group>\n   |    |\n   |  earth<Circle>\n   |\n moonOrbit<Group>\n      |\n     moon<Circle r='25' />\n",paraId:4},{value:"我们可以使用以上查询方法：",paraId:5},{value:"solarSystem.getElementsByName('sun');\n// [sun]\n\nsolarSystem.getElementsByTagName('circle');\nsolarSystem.getElementsByTagName(Shape.CIRCLE);\n// [sun, earth, moon]\n",paraId:6},{value:"当我们想使用类似 CSS 选择器这样更复杂的查询条件时，就可以选择安装该插件：",paraId:7},{value:"querySelector",paraId:8},{value:"querySelectorAll",paraId:8},{value:"安装完成后就可以使用属性选择器：",paraId:9},{value:"solarSystem.querySelector('[name=sun]');\n// sun\n\nsolarSystem.querySelectorAll('[r=25]');\n// [moon]\n",paraId:10},{value:"任意渲染器（g-canvas/g-svg/g-webgl）都可以使用该插件：",paraId:11,tocIndex:0},{value:"import { Plugin } from '@antv/g-plugin-css-select';\n// 注册插件\nwebglRenderer.registerPlugin(new Plugin());\n",paraId:12,tocIndex:0},{value:"我们可以使用类似 DOM API + CSS 选择器的方式进行场景图中的节点查询，",paraId:13,tocIndex:1},{value:"完整示例",paraId:14,tocIndex:1},{value:"：",paraId:13,tocIndex:1},{value:"solarSystem.getElementsByName('sun');\n// [sun]\n\nsolarSystem.getElementsByTagName('circle');\nsolarSystem.getElementsByTagName(Shape.CIRCLE);\n// [sun, earth, moon]\n\nsolarSystem.querySelector('[name=sun]');\n// sun\n\nsolarSystem.querySelectorAll('[r=25]');\n// [moon]\n",paraId:15,tocIndex:1}]},62921:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(68279);const d=[{value:"在命名方式上，所有的插件名都以 ",paraId:0,tocIndex:0},{value:"g-plugin-",paraId:0,tocIndex:0},{value:" 开头。下面我们通过对于 ",paraId:0,tocIndex:0},{value:"g-plugin-canvas-renderer",paraId:1,tocIndex:0},{value:" 这个使用 Canvas2D 渲染的插件分析，深入了解一下插件的结构，它也是 ",paraId:0,tocIndex:0},{value:"g-canvas",paraId:2,tocIndex:0},{value:" 的核心插件之一。",paraId:0,tocIndex:0},{value:"https://github.com/antvis/G/tree/next/packages/g-plugin-canvas-renderer",paraId:3,tocIndex:1},{value:"从 ",paraId:4,tocIndex:2},{value:"package.json",paraId:4,tocIndex:2},{value:" 的 ",paraId:4,tocIndex:2},{value:"peerDependencies",paraId:4,tocIndex:2},{value:" 可以看出，一个插件的最核心依赖就是 ",paraId:4,tocIndex:2},{value:"@antv/g",paraId:4,tocIndex:2},{value:"，即 G 的核心层，包含了依赖注入、画布、基础图形、事件等核心对象。",paraId:4,tocIndex:2},{value:'"peerDependencies": {\n    "@antv/g-lite": "^1.0.0"\n},\n',paraId:5,tocIndex:2},{value:"打开插件的入口文件，我们可以发现一个继承了 ",paraId:6,tocIndex:3},{value:"AbstractRendererPlugin",paraId:6,tocIndex:3},{value:" 的插件需要实现两个方法：",paraId:6,tocIndex:3},{value:"init",paraId:7,tocIndex:3},{value:" 在容器中加载模块",paraId:7,tocIndex:3},{value:"destroy",paraId:7,tocIndex:3},{value:" 在容器中卸载模块",paraId:7,tocIndex:3},{value:"import { AbstractRendererPlugin, Module } from '@antv/g';\nimport { DOMInteractionPlugin } from './DOMInteractionPlugin';\n\n// 定义该插件的模块\nconst containerModule = Module((register) => {\n    register(ImagePool);\n    // ...省略注册其他依赖\n    register(CanvasRendererPlugin);\n    register(LoadImagePlugin);\n});\n\nexport class Plugin extends AbstractRendererPlugin {\n    name = 'canvas-renderer';\n    init(): void {\n        // 加载模块\n        this.container.load(containerModule, true);\n    }\n    destroy(): void {\n        // 卸载模块\n        this.container.unload(containerModule);\n    }\n}\n",paraId:8,tocIndex:3},{value:"这里我们注册了一个 ",paraId:9,tocIndex:3},{value:"CanvasRendererPlugin",paraId:9,tocIndex:3},{value:"，让我们继续深入看看。",paraId:9,tocIndex:3},{value:"export class CanvasRendererPlugin implements RenderingPlugin {\n    static tag = 'CanvasRenderer';\n}\n",paraId:10,tocIndex:4},{value:"接下来就可以通过渲染服务提供的一系列 ",paraId:11,tocIndex:4},{value:"hooks",paraId:11,tocIndex:4},{value:" 选择适当的执行时机，例如在渲染服务初始化时处理下 DPR：",paraId:11,tocIndex:4},{value:"apply(context: RenderingPluginContext) {\n    const { config, camera, renderingService, renderingContext, rBushRoot, pathGeneratorFactory } =\n      context;\n\n    // 当渲染服务初始化时...\n    renderingService.hooks.init.tap(CanvasRendererPlugin.tag, () => {\n        // 使用容器注入的上下文服务\n        const context = this.contextService.getContext();\n        const dpr = this.contextService.getDPR();\n        context && context.scale(dpr, dpr);\n\n        // 使用容器注入的渲染上下文服务\n        this.renderingContext.root.addEventListener(ElementEvent.MOUNTED, handleMounted);\n        this.renderingContext.root.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);\n        this.renderingContext.root.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);\n    });\n}\n",paraId:12,tocIndex:4},{value:"所有插件都遵循以上的结构实现。",paraId:13,tocIndex:4},{value:"插件之间也会存在依赖关系，例如 ",paraId:14,tocIndex:5},{value:"g-plugin-gpgpu",paraId:14,tocIndex:5},{value:" 就依赖 ",paraId:14,tocIndex:5},{value:"g-plugin-device-renderer",paraId:14,tocIndex:5},{value:"。在独立构建 UMD 时需要排除掉依赖，详见",paraId:14,tocIndex:5},{value:"构建说明",paraId:15,tocIndex:5},{value:"。",paraId:14,tocIndex:5}]},14668:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(26846);const d=[{value:"提供基于 WebGL 1/2 和 WebGPU 的渲染能力，也包括基于 GPU 的拾取能力。内置 G 核心包提供的全部 2D 基础图形，同时暴露其他自定义 2D/3D 图形的扩展能力。",paraId:0},{value:"g-webgl",paraId:1,tocIndex:0},{value:" 和 ",paraId:1,tocIndex:0},{value:"g-webgpu",paraId:1,tocIndex:0},{value:" 渲染器默认内置，因此无需手动引入。",paraId:1,tocIndex:0},{value:"import { Renderer as WebGLRenderer } from '@antv/g-webgl';\n// 创建 WebGL 渲染器，其中内置了该插件\nconst renderer = new WebGLRenderer();\n",paraId:2,tocIndex:0},{value:"它代表 GPU 设备（与之相对 Host 通常指指 CPU），提供统一的 HAL 硬件适配层供 WebGL 1/2 和 WebGPU 实现。在设计相关 API 时大量参考了 WebGPU ",paraId:3,tocIndex:1},{value:"相关 API",paraId:3,tocIndex:1},{value:"。",paraId:3,tocIndex:1},{value:"由于设备初始化可能为异步操作（例如 WebGPU 的 ",paraId:4,tocIndex:1},{value:"adapter.requestDevice()",paraId:4,tocIndex:1},{value:"），因此提供了两种获取 Device 方式：",paraId:4,tocIndex:1},{value:"import { CanvasEvent } from '@antv/g';\n\n// 监听画布准备就绪事件\ncanvas.addEventListener(CanvasEvent.READY, () => {\n    // 通过渲染器获取 Device\n    const plugin = renderer.getPlugin('device-renderer');\n    const device = plugin.getDevice();\n});\n\n// 或者等待画布准备就绪\nawait canvas.ready;\n// 通过渲染器获取 Device\nconst plugin = renderer.getPlugin('device-renderer');\nconst device = plugin.getDevice();\n",paraId:5,tocIndex:1},{value:"获取 Device 之后可以使用它创建一系列 GPU 相关的资源，例如 Buffer、Texture 等。",paraId:6,tocIndex:1},{value:"Buffer 代表 GPU 操作中使用的一块内存，在创建时可以指定初始化数据，随后也可以对其中部分数据进行修改。数据以线性布局的方式存储。当需要在 CPU 侧（Host）读取其中的数据时，需要通过 ",paraId:7,tocIndex:2},{value:"Readback",paraId:8,tocIndex:2},{value:" 完成。",paraId:7,tocIndex:2},{value:"export interface Buffer {\n    setSubData(\n        dstByteOffset: number,\n        src: ArrayBufferView,\n        srcByteOffset?: number,\n        byteLength?: number,\n    ): void;\n\n    destroy(): void;\n}\n",paraId:9,tocIndex:2},{value:"创建 Buffer 方式如下，需要指定：",paraId:10,tocIndex:3},{value:"viewOrSize 必填，指定初始化数据或者 Buffer 大小",paraId:11,tocIndex:3},{value:"usage 必填，内存用途，完全参考 ",paraId:11,tocIndex:3},{value:"WebGPU Buffer Usage",paraId:11,tocIndex:3},{value:"hint 可选，仅 WebGL 环境下生效",paraId:11,tocIndex:3},{value:"interface Device {\n    createBuffer(descriptor: BufferDescriptor): Buffer;\n}\n\nexport interface BufferDescriptor {\n    viewOrSize: ArrayBufferView | number;\n    usage: BufferUsage;\n    hint?: BufferFrequencyHint;\n}\n\nexport enum BufferUsage {\n    MAP_READ = 0x0001,\n    MAP_WRITE = 0x0002,\n    COPY_SRC = 0x0004,\n    COPY_DST = 0x0008,\n    INDEX = 0x0010,\n    VERTEX = 0x0020,\n    UNIFORM = 0x0040,\n    STORAGE = 0x0080,\n    INDIRECT = 0x0100,\n    QUERY_RESOLVE = 0x0200,\n}\n\nexport enum BufferFrequencyHint {\n    Static = 0x01,\n    Dynamic = 0x02,\n}\n",paraId:12,tocIndex:3},{value:"例如配合 ",paraId:13,tocIndex:3},{value:"g-plugin-gpgpu",paraId:14,tocIndex:3},{value:" 使用时，用来分配输入和输出 Buffer：",paraId:13,tocIndex:3},{value:"const buffer = device.createBuffer({\n    usage: BufferUsage.STORAGE | BufferUsage.COPY_SRC,\n    viewOrSize: new Float32Array([1, 2, 3, 4]),\n});\n",paraId:15,tocIndex:3},{value:"dstByteOffset 必填，目标 Buffer 中的偏移量，以 Byte 为单位",paraId:16,tocIndex:4},{value:"src 必填，类型为 ArrayBufferView",paraId:16,tocIndex:4},{value:"srcByteOffset 选填，src 中起始偏移量，以 Byte 为单位",paraId:16,tocIndex:4},{value:"byteLength 选填，src 中长度，以 Byte 为单位",paraId:16,tocIndex:4},{value:"例如修改 Uniform 中的某个变量，它位于原始 Buffer 中的第 20 个 bytes：",paraId:17,tocIndex:4},{value:"paramBuffer.setSubData(\n    5 * Float32Array.BYTES_PER_ELEMENT,\n    new Float32Array([maxDisplace]),\n);\n",paraId:18,tocIndex:4},{value:"释放 Buffer 资源。",paraId:19,tocIndex:5},{value:"buffer.destroy();\n",paraId:20,tocIndex:5},{value:"有时我们需要在 CPU 侧(Host)读取 GPU 侧(Device) Buffer 或者 Texture 中的数据，此时需要通过 Readback 对象实现，它提供异步读取方法。",paraId:21,tocIndex:6},{value:"interface Device {\n    createReadback(): Readback;\n}\n",paraId:22,tocIndex:7},{value:"异步读取 Buffer 内容。",paraId:23,tocIndex:8},{value:"WebGPU 中通过 ",paraId:24,tocIndex:8},{value:"copyBufferToBuffer",paraId:24,tocIndex:8},{value:" 实现，",paraId:24,tocIndex:8},{value:"WebGL2 中通过 ",paraId:24,tocIndex:8},{value:"fenceSync",paraId:24,tocIndex:8},{value:" 实现",paraId:24,tocIndex:8},{value:"WebGL1 不支持",paraId:24,tocIndex:8},{value:"参数列表如下：",paraId:25,tocIndex:8},{value:"srcBuffer 必填，源 Buffer",paraId:26,tocIndex:8},{value:"srcByteOffset 选填，目标 Buffer 起始偏移量，默认为 0，即从头读取",paraId:26,tocIndex:8},{value:"dstBuffer 选填，读取内容存放至目标 ArrayBufferView，不填自动创建，最终以结果形式返回",paraId:26,tocIndex:8},{value:"dstOffset 选填，目标 ArrayBufferView 偏移量，默认为 0，即从头写入",paraId:26,tocIndex:8},{value:"length 选填，读取长度，默认为全部",paraId:26,tocIndex:8},{value:"返回值为读取结果 ArrayBufferView。",paraId:27,tocIndex:8},{value:"export interface Readback {\n    readBuffer(\n        srcBuffer: Buffer,\n        srcByteOffset?: number,\n        dstBuffer?: ArrayBufferView,\n        dstOffset?: number,\n        length?: number,\n    ): Promise<ArrayBufferView>;\n}\n",paraId:28,tocIndex:8},{value:"例如配合 ",paraId:29,tocIndex:8},{value:"g-plugin-gpgpu",paraId:29,tocIndex:8},{value:" 使用时，读取计算结果：",paraId:29,tocIndex:8},{value:"const result = await readback.readBuffer(resultBuffer); // Float32Array([...])\n",paraId:30,tocIndex:8},{value:"读取纹理内容。",paraId:31,tocIndex:9},{value:"WebGL1 通过 ",paraId:32,tocIndex:9},{value:"readPixels",paraId:32,tocIndex:9},{value:" 实现",paraId:32,tocIndex:9},{value:"WebGL2 中和 readBuffer 一样通过 ",paraId:32,tocIndex:9},{value:"fenceSync",paraId:32,tocIndex:9},{value:" 实现",paraId:32,tocIndex:9},{value:"WebGPU 中使用 ",paraId:32,tocIndex:9},{value:"copyTextureToBuffer",paraId:32,tocIndex:9},{value:" 后，再使用 readBuffer 一样的实现方式",paraId:32,tocIndex:9},{value:"参数列表如下：",paraId:33,tocIndex:9},{value:"texture 必填，源 Texture",paraId:34,tocIndex:9},{value:"x 必填，读取区域起始 X 坐标",paraId:34,tocIndex:9},{value:"y 必填，读取区域起始 Y 坐标",paraId:34,tocIndex:9},{value:"width 必填，读取区域宽度",paraId:34,tocIndex:9},{value:"height 必填，读取区域高度",paraId:34,tocIndex:9},{value:"dstBuffer 必填，读取内容存放至目标 ArrayBufferView，最终以结果形式返回",paraId:34,tocIndex:9},{value:"dstOffset 选填，目标 ArrayBufferView 偏移量，默认为 0，即从头写入",paraId:34,tocIndex:9},{value:"length 选填，读取长度，默认为全部",paraId:34,tocIndex:9},{value:"返回值为读取结果 ArrayBufferView。",paraId:35,tocIndex:9},{value:"export interface Readback {\n    readTexture(\n        t: Texture,\n        x: number,\n        y: number,\n        width: number,\n        height: number,\n        dstBuffer: ArrayBufferView,\n        dstOffset?: number,\n        length?: number,\n    ): Promise<ArrayBufferView>;\n}\n",paraId:36,tocIndex:9},{value:"例如在实现基于 GPU 颜色编码的拾取时：",paraId:37,tocIndex:9},{value:"const pickedColors = await readback.readTexture(\n    this.pickingTexture,\n    rect.x,\n    rect.y,\n    rect.width,\n    rect.height,\n    new Uint8Array(rect.width * rect.height * 4),\n);\n",paraId:38,tocIndex:9},{value:"释放 Readback 资源。",paraId:39,tocIndex:10},{value:"readback.destroy();\n",paraId:40,tocIndex:10},{value:"纹理是很常用的 GPU 资源。",paraId:41,tocIndex:11},{value:"export interface Texture {\n    setImageData(data: TexImageSource | ArrayBufferView[]): void;\n}\n",paraId:42,tocIndex:11},{value:"interface Device {\n    createTexture(descriptor: TextureDescriptor): Texture;\n}\n\nexport interface TextureDescriptor {\n    dimension: TextureDimension;\n    pixelFormat: Format;\n    width: number;\n    height: number;\n    depth: number;\n    numLevels: number;\n    usage: TextureUsage;\n    pixelStore?: Partial<{\n        packAlignment: number,\n        unpackAlignment: number,\n        unpackFlipY: boolean,\n    }>;\n}\n",paraId:43,tocIndex:12},{value:"例如在加载图片成功后，设置纹理内容：",paraId:44,tocIndex:13},{value:"const image = new window.Image();\nimage.onload = () => {\n    // 设置纹理内容，以 Image 形式\n    texture.setImageData(image);\n};\nimage.onerror = () => {};\nimage.crossOrigin = 'Anonymous';\nimage.src = src;\n",paraId:45,tocIndex:13},{value:"释放 Texture 资源。",paraId:46,tocIndex:14},{value:"texture.destroy();\n",paraId:47,tocIndex:14},{value:"interface Device {\n    createSampler(descriptor: SamplerDescriptor): Sampler;\n}\n\nexport interface SamplerDescriptor {\n    wrapS: WrapMode;\n    wrapT: WrapMode;\n    wrapQ?: WrapMode;\n    minFilter: TexFilterMode;\n    magFilter: TexFilterMode;\n    mipFilter: MipFilterMode;\n    minLOD?: number;\n    maxLOD?: number;\n    maxAnisotropy?: number;\n    compareMode?: CompareMode;\n}\n",paraId:48,tocIndex:16},{value:"释放 Sampler 资源。",paraId:49,tocIndex:17},{value:"sampler.destroy();\n",paraId:50,tocIndex:17},{value:"有两种方式可以创建：",paraId:51,tocIndex:19},{value:"interface Device {\n    createRenderTarget(descriptor: RenderTargetDescriptor): RenderTarget;\n    createRenderTargetFromTexture(texture: Texture): RenderTarget;\n}\n\nexport interface RenderTargetDescriptor {\n    pixelFormat: Format;\n    width: number;\n    height: number;\n    sampleCount: number;\n    texture?: Texture;\n}\n",paraId:52,tocIndex:19},{value:"释放 RenderTarget 资源。",paraId:53,tocIndex:20},{value:"renderTarget.destroy();\n",paraId:54,tocIndex:20},{value:"interface Device {\n    createProgram(program: ProgramDescriptor): Program;\n}\n\nexport interface ProgramDescriptor {\n    vert?: string;\n    frag?: string;\n    preprocessedVert?: string;\n    preprocessedFrag?: string;\n    preprocessedCompute?: string;\n}\n",paraId:55,tocIndex:22},{value:"释放 Program 资源。",paraId:56,tocIndex:23},{value:"program.destroy();\n",paraId:57,tocIndex:23},{value:"与 ",paraId:58,tocIndex:24},{value:"g-plugin-canvas-picker",paraId:59,tocIndex:24},{value:" 和 ",paraId:58,tocIndex:24},{value:"g-plugin-svg-picker",paraId:60,tocIndex:24},{value:" 这些基于 CPU 的拾取方案不同，我们使用使用一种基于 GPU 称作“颜色编码”的方式。",paraId:58,tocIndex:24},{value:"该方式包含以下步骤：",paraId:61,tocIndex:24},{value:"为每个图形分配一个独立的用于拾取的“颜色”",paraId:62,tocIndex:24},{value:"当需要拾取时（触发",paraId:62,tocIndex:24},{value:"交互事件",paraId:63,tocIndex:24},{value:"或者通过 ",paraId:62,tocIndex:24},{value:"element(s)FromPoint",paraId:64,tocIndex:24},{value:" API），使用上一步分配的“颜色”而非真实颜色渲染到 Framebuffer（大小无需全屏，通常只需要 1x1）中。同时使用 ",paraId:62,tocIndex:24},{value:"setViewOffset",paraId:65,tocIndex:24},{value:" 为相机设置偏移量，这样只需要渲染拾取区域（通常是 1x1）而无需渲染全屏",paraId:62,tocIndex:24},{value:"读取 Framebuffer 中纹理像素值，映射回图形",paraId:62,tocIndex:24},{value:"如果需要获取目标点重叠在一起而非最顶部的全部图形（例如使用 ",paraId:62,tocIndex:24},{value:"elementsFromPoint",paraId:66,tocIndex:24},{value:"），设置已拾取到图形的拾取“颜色”为空。重复 2/3 步，直至无法拾取到任何图形",paraId:62,tocIndex:24}]},48567:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(98783);const d=[{value:"基于 DOM API 绑定事件。",paraId:0},{value:"g-webgl/canvas/svg",paraId:1,tocIndex:0},{value:" 渲染器默认内置，因此无需手动引入。",paraId:1,tocIndex:0},{value:"import { Renderer as SvgRenderer } from '@antv/g-svg';\n// 创建 SVG 渲染器，其中内置了该插件\nconst svgRenderer = new SvgRenderer();\n",paraId:2,tocIndex:0}]},55176:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(97400);const d=[{value:"基于 ",paraId:0},{value:"PointerEvents",paraId:1},{value:" 实现拖放功能。在该",paraId:0},{value:"示例",paraId:2},{value:"中，我们监听了足球的 drag 事件，用以移动它到正确的位置，同时监听了球门的 dragover 事件，当足球划过球门区域时改变透明度：",paraId:0},{value:"import { Renderer as CanvasRenderer } from '@antv/g-canvas';\nimport { Plugin } from '@antv/g-plugin-dragndrop';\n\nconst canvasRenderer = new CanvasRenderer();\ncanvasRenderer.registerPlugin(new Plugin());\n",paraId:3,tocIndex:0},{value:"我们提供了以下配置项，可以在创建插件时传入，例如 ",paraId:4,tocIndex:1},{value:"overlap",paraId:5,tocIndex:1},{value:"：",paraId:4,tocIndex:1},{value:"new Plugin({\n    overlap: 'center',\n});\n",paraId:6,tocIndex:1},{value:"由于 ",paraId:7,tocIndex:2},{value:"Document",paraId:8,tocIndex:2},{value:" 上并没有“样式”，因此当我们想在画布的空白区域进行拖拽时，并不能这么做：",paraId:7,tocIndex:2},{value:"// wrong\ncanvas.document.style.draggable = true;\n\n// correct\nconst plugin = new Plugin({\n    // we can drag the whole document from empty space now!\n    isDocumentDraggable: true,\n});\n",paraId:9,tocIndex:2},{value:"在该",paraId:10,tocIndex:2},{value:"示例",paraId:11,tocIndex:2},{value:"中，在空白区域进行拖拽可以通过 ",paraId:10,tocIndex:2},{value:"camera.pan()",paraId:12,tocIndex:2},{value:" 平移相机，以达到整个画布发生移动的视觉效果：",paraId:10,tocIndex:2},{value:"const camera = canvas.getCamera();\ncanvas.addEventListener('drag', function (e) {\n    if (e.target === canvas.document) {\n        camera.pan(-e.movementX, -e.movementY);\n    }\n});\n",paraId:13,tocIndex:2},{value:"在上面的例子中我们有 ",paraId:14,tocIndex:2},{value:"e.target === canvas.document",paraId:14,tocIndex:2},{value:" 这样的判断，是为了避免移动“足球”等非 ",paraId:14,tocIndex:2},{value:"Document",paraId:15,tocIndex:2},{value:" 元素也造成相机移动。",paraId:14,tocIndex:2},{value:"同样的，如果我们想让 ",paraId:16,tocIndex:3},{value:"Document",paraId:17,tocIndex:3},{value:" 也成为“可放置区域”，可以使用该配置项：",paraId:16,tocIndex:3},{value:"// wrong\ncanvas.document.style.droppable = true;\n\n// correct\nconst plugin = new Plugin({\n    isDocumentDroppable: true,\n});\n",paraId:18,tocIndex:3},{value:"在该",paraId:19,tocIndex:3},{value:"示例",paraId:20,tocIndex:3},{value:"中，当我们拖动足球到空白区域时，控制台会打印如下信息：",paraId:19,tocIndex:3},{value:"canvas.addEventListener('drop', function (e) {\n    if (e.target === canvas.document) {\n        console.log('drop on document');\n    }\n});\n",paraId:21,tocIndex:3},{value:"对于满足何种条件判定“开始拖拽”，我们提供了以下配置项：分别基于拖拽距离和时间。只有这些判定条件全部满足，才会触发 ",paraId:22,tocIndex:4},{value:"dragstart",paraId:22,tocIndex:4},{value:" 等一系列拖放事件。",paraId:22,tocIndex:4},{value:"该配置项用于配置拖放距离的检测阈值，单位为像素，只有 ",paraId:23,tocIndex:4},{value:"大于",paraId:23,tocIndex:4},{value:" 该值才会判定通过。默认值为 0。",paraId:23,tocIndex:4},{value:"在该",paraId:24,tocIndex:4},{value:"示例",paraId:25,tocIndex:4},{value:"中，我们配置了该选项为 10，即只有拖动超过 10 像素距离才会触发拖动事件：",paraId:24,tocIndex:4},{value:"const plugin = new Plugin({\n    dragstartDistanceThreshold: 10,\n});\n",paraId:26,tocIndex:4},{value:"该配置项用于配置拖放时间的检测阈值，单位为毫秒，只有 ",paraId:27,tocIndex:5},{value:"大于",paraId:27,tocIndex:5},{value:" 该值才会判定通过。默认值为 0。",paraId:27,tocIndex:5},{value:"在该",paraId:28,tocIndex:5},{value:"示例",paraId:29,tocIndex:5},{value:"中，我们配置了该选项为 100，即只有拖动超过 100 毫秒才会触发拖动事件：",paraId:28,tocIndex:5},{value:"const plugin = new Plugin({\n    dragstartTimeThreshold: 100,\n});\n",paraId:30,tocIndex:5},{value:"用以判断拖拽中的图形是否进入 ",paraId:31,tocIndex:6},{value:"dropzone",paraId:31,tocIndex:6},{value:"，支持以下两个取值：",paraId:31,tocIndex:6},{value:"'pointer'",paraId:32,tocIndex:6},{value:" 默认值。鼠标位置进入 ",paraId:32,tocIndex:6},{value:"dropzone",paraId:32,tocIndex:6},{value:" 区域则通过判定",paraId:32,tocIndex:6},{value:"'center'",paraId:32,tocIndex:6},{value:" 拖拽中图形包围盒中心进入 ",paraId:32,tocIndex:6},{value:"dropzone",paraId:32,tocIndex:6},{value:" 区域则通过判定",paraId:32,tocIndex:6},{value:"除了在插件初始化时传入，还可以在后续任意时刻使用 ",paraId:33,tocIndex:7},{value:"setOptions",paraId:33,tocIndex:7},{value:" 对以上配置项进行修改：",paraId:33,tocIndex:7},{value:"plugin.setOptions({\n    dragstartTimeThreshold: 200,\n});\n",paraId:34,tocIndex:7},{value:"通过配置图形支持 Drag（拖拽）、Drop（放置），我们可以监听相关的事件。Drag 和 Drop 相关的事件都是可冒泡的。",paraId:35,tocIndex:8},{value:"注册插件完毕之后，为了让图形支持拖拽，需要设置 ",paraId:36,tocIndex:9},{value:"draggable",paraId:36,tocIndex:9},{value:" 属性为 ",paraId:36,tocIndex:9},{value:"true",paraId:36,tocIndex:9},{value:"。例如上面的足球：",paraId:36,tocIndex:9},{value:"const ball = new Image({\n    style: {\n        draggable: true, // 表示该图形支持拖拽\n        x: 300,\n        y: 200,\n        width: 100,\n        height: 100,\n        src: 'https://en.js.cx/clipart/ball.svg',\n        cursor: 'pointer',\n    },\n});\n",paraId:37,tocIndex:9},{value:"此时就可以监听该图形的 drag 相关事件，包括以下三类事件，事件对象的 ",paraId:38,tocIndex:9},{value:"target",paraId:39,tocIndex:9},{value:" 都是被拖拽的图形：",paraId:38,tocIndex:9},{value:"dragstart 在开始拖拽时触发 ",paraId:40,tocIndex:9},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/dragstart_event",paraId:40,tocIndex:9},{value:"drag 在拖拽中频繁触发 ",paraId:40,tocIndex:9},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/drag_event",paraId:40,tocIndex:9},{value:"dragend 在拖拽结束后触发 ",paraId:40,tocIndex:9},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/dragend_event",paraId:40,tocIndex:9},{value:"drag 相关事件都是 ",paraId:41,tocIndex:9},{value:"PointerEvents",paraId:42,tocIndex:9},{value:"，因此可以在事件监听器中访问事件对象上的属性。",paraId:41,tocIndex:9},{value:"例如开始拖拽时，我们记录下鼠标位置到被拖拽元素位置的偏移量 ",paraId:43,tocIndex:9},{value:"shiftX/Y",paraId:43,tocIndex:9},{value:"，两者都在",paraId:43,tocIndex:9},{value:"Canvas/世界坐标系",paraId:44,tocIndex:9},{value:"下。在 ",paraId:43,tocIndex:9},{value:"drag",paraId:43,tocIndex:9},{value:" 事件中我们调用 ",paraId:43,tocIndex:9},{value:"setPosition",paraId:45,tocIndex:9},{value:" 完成被拖拽图形的平移。",paraId:43,tocIndex:9},{value:"https://javascript.info/mouse-drag-and-drop#correct-positioning",paraId:46,tocIndex:9},{value:"let shiftX = 0;\nlet shiftY = 0;\nfunction moveAt(target, canvasX, canvasY) {\n    target.setPosition(canvasX - shiftX, canvasY - shiftY);\n}\n\nball.addEventListener('dragstart', function (e) {\n    e.target.style.opacity = 0.5;\n    ballText.style.text = 'ball dragstart';\n\n    const [x, y] = e.target.getPosition();\n    shiftX = e.canvasX - x;\n    shiftY = e.canvasY - y;\n\n    moveAt(e.target, e.canvasX, e.canvasY);\n});\nball.addEventListener('drag', function (e) {\n    moveAt(e.target, e.canvasX, e.canvasY);\n    ballText.style.text = `ball drag movement: ${e.movementX}, ${e.movementY}`;\n});\nball.addEventListener('dragend', function (e) {\n    e.target.style.opacity = 1;\n    ballText.style.text = 'ball dragend';\n});\n",paraId:47,tocIndex:9},{value:"同样，我们可以为支持放置的图形开启 ",paraId:48,tocIndex:10},{value:"droppable",paraId:48,tocIndex:10},{value:"：",paraId:48,tocIndex:10},{value:"const gate = new Image({\n    style: {\n        droppable: true, // 表示该图形支持放置\n        x: 50,\n        y: 100,\n        width: 200,\n        height: 100,\n        src: 'https://en.js.cx/clipart/soccer-gate.svg',\n    },\n});\n",paraId:49,tocIndex:10},{value:"此时就可以监听放置区域的 drag/drop 相关事件，包括以下三类事件，事件对象的 ",paraId:50,tocIndex:10},{value:"target",paraId:51,tocIndex:10},{value:" 都是放置区域的图形：",paraId:50,tocIndex:10},{value:"dragenter 有图形被拖入该区域 ",paraId:52,tocIndex:10},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/dragenter_event",paraId:52,tocIndex:10},{value:"dragleave 有图形被拖离该区域 ",paraId:52,tocIndex:10},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/dragleave_event",paraId:52,tocIndex:10},{value:"dragover 有图形正在划过该区域 ",paraId:52,tocIndex:10},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/dragover_event",paraId:52,tocIndex:10},{value:"drop 有图形放置在该区域 ",paraId:52,tocIndex:10},{value:"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/drop_event",paraId:52,tocIndex:10},{value:"例如我们让球门监听相关事件：",paraId:53,tocIndex:10},{value:"gate.addEventListener('dragenter', function (e) {\n    e.target.style.opacity = 0.6;\n    gateText.style.text = 'gate dragenter';\n});\ngate.addEventListener('dragleave', function (e) {\n    e.target.style.opacity = 1;\n    gateText.style.text = 'gate dragleave';\n});\ngate.addEventListener('dragover', function (e) {\n    e.target.style.opacity = 0.6;\n    gateText.style.text = 'gate dragover';\n});\ngate.addEventListener('drop', function (e) {\n    e.target.style.opacity = 1;\n    gateText.style.text = 'gate drop';\n});\n",paraId:54,tocIndex:10},{value:"drag",paraId:55,tocIndex:12},{value:" 系列事件与其它交互事件存在先后触发的顺序问题，以 ",paraId:55,tocIndex:12},{value:"pointer",paraId:55,tocIndex:12},{value:" 系列事件为例，在一个典型的拖拽过程中，会依次触发以下事件：",paraId:55,tocIndex:12},{value:"pointerdown",paraId:56,tocIndex:12},{value:" 按下",paraId:56,tocIndex:12},{value:"pointermove * n",paraId:56,tocIndex:12},{value:" 拖动一定距离后判定通过，进入拖拽流程",paraId:56,tocIndex:12},{value:"dragstart",paraId:56,tocIndex:12},{value:" 开始拖拽",paraId:56,tocIndex:12},{value:"drag",paraId:56,tocIndex:12},{value:" 拖拽中",paraId:56,tocIndex:12},{value:"pointermove",paraId:56,tocIndex:12},{value:"drag",paraId:56,tocIndex:12},{value:" 拖拽中",paraId:56,tocIndex:12},{value:"pointermove",paraId:56,tocIndex:12},{value:"drag",paraId:56,tocIndex:12},{value:" 拖拽中",paraId:56,tocIndex:12},{value:"pointermove",paraId:56,tocIndex:12},{value:"dragend",paraId:56,tocIndex:12},{value:" 拖拽结束",paraId:56,tocIndex:12},{value:"pointerup",paraId:56,tocIndex:12},{value:" 抬起",paraId:56,tocIndex:12},{value:"在 HTML 的 Drag'n'drop 实现中，",paraId:57,tocIndex:13},{value:"click",paraId:57,tocIndex:13},{value:" 和 ",paraId:57,tocIndex:13},{value:"drag",paraId:57,tocIndex:13},{value:" 事件同时只会触发一个：",paraId:57,tocIndex:13},{value:"https://plnkr.co/edit/5mdl7oTg0dPWXIip",paraId:57,tocIndex:13},{value:"我们在实现中也保留了这一设定，在触发 ",paraId:58,tocIndex:13},{value:"dragend",paraId:58,tocIndex:13},{value:" 事件之后不会再触发 ",paraId:58,tocIndex:13},{value:"click",paraId:58,tocIndex:13},{value:"。",paraId:58,tocIndex:13}]},4599:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(54862);const d=[{value:"基于 WebGPU 提供 GPGPU 能力。直接使用 WGSL 编写 Compute Shader，非常适合移植已有的 CUDA 算法。",paraId:0},{value:"例如在图场景中有非常多适合并行的布局和分析算法：",paraId:1},{value:"Fruchterman 布局算法",paraId:2},{value:"Pagerank",paraId:3},{value:"SSSP 单源最短路径",paraId:4},{value:"在图中节点/边数目达到一定规模时会带来非常可观的性能提升效果。以 pagerank 为例，在 1k 节点和 50w 条边的测试数据中，GPU 版本相较 CPU 版本有 100 倍以上的提升（300ms vs 30s）。",paraId:5},{value:"只能配合 ",paraId:6,tocIndex:0},{value:"g-webgpu",paraId:6,tocIndex:0},{value:" 渲染器使用：",paraId:6,tocIndex:0},{value:"import { Renderer } from '@antv/g-webgpu';\nimport { Plugin } from '@antv/g-plugin-gpgpu';\n\nconst webgpuRenderer = new Renderer();\nwebgpuRenderer.registerPlugin(new Plugin());\n",paraId:7,tocIndex:0},{value:"在创建一个计算任务时，我们需要获取 GPU 设备（Device），用它创建 Buffer 等底层对象。在画布的 ",paraId:8,tocIndex:1},{value:"READY",paraId:9,tocIndex:1},{value:" 事件处理器中，我们可以通过渲染器获取 Device：",paraId:8,tocIndex:1},{value:"import { CanvasEvent } from '@antv/g';\n\n// 等待画布准备就绪\ncanvas.addEventListener(CanvasEvent.READY, () => {\n    // 通过渲染器获取 Device\n    const plugin = renderer.getPlugin('device-renderer');\n    const device = plugin.getDevice();\n\n    // 使用 Device 创建 GPU 相关对象，见下节\n});\n",paraId:10,tocIndex:1},{value:"因此 g-plugin-gpgpu 插件提供了 Kernel 用于描述计算任务，除了传入上一节获取的 device，还需要通过 computeShader 使用字符串描述：",paraId:11,tocIndex:2},{value:"import { Kernel } from '@antv/g-plugin-gpgpu';\n\nconst kernel = new Kernel(device, {\n    computeShader: `...`,\n});\n",paraId:12,tocIndex:2},{value:"定义好了 Kernel，我们需要向它传递输入，结束后获取输出结果。分配内存的工作在 Host 侧执行，通过 Device 创建 Buffer，其中 ",paraId:13,tocIndex:3},{value:"usage",paraId:13,tocIndex:3},{value:" 需要与 Compute Shader 中定义的内存用途对应，同时进行内存初始数据的写入。",paraId:13,tocIndex:3},{value:"const firstMatrixBuffer = device.createBuffer({\n    usage: BufferUsage.STORAGE,\n    viewOrSize: firstMatrix, // new Float32Array([2 /* rows */, 4 /* columns */, 1, 2, 3, 4, 5, 6, 7, 8])\n});\n",paraId:14,tocIndex:3},{value:"创建完 Buffer 之后，需要绑定到 Kernel 的指定位置（与 Compute Shader 中的 binding 对应）：",paraId:15,tocIndex:3},{value:"kernel.setBinding(0, firstMatrixBuffer);\n",paraId:16,tocIndex:3},{value:"使用 ",paraId:17,tocIndex:4},{value:"dispatch",paraId:17,tocIndex:4},{value:" 可以分配线程网格大小，执行计算管线。在矩阵乘法的例子中，如果线程组的大小为 ",paraId:17,tocIndex:4},{value:"1 * 1",paraId:17,tocIndex:4},{value:"，网格大小就是 ",paraId:17,tocIndex:4},{value:"M * N",paraId:17,tocIndex:4},{value:"：",paraId:17,tocIndex:4},{value:"const x = Math.ceil(firstMatrix[0] / WORKGROUP_SIZE_X);\nconst y = Math.ceil(secondMatrix[1] / WORKGROUP_SIZE_Y);\nkernel.dispatch(x, y);\n",paraId:18,tocIndex:4},{value:"在计算完成后，我们需要读取结果矩阵中的数据，这是一次 GPU 到 CPU 的异步读取操作：",paraId:19,tocIndex:4},{value:"const readback = device.createReadback();\nconst result = await readback.readBuffer(resultBuffer); // Float32Array([...])\n",paraId:20,tocIndex:4}]},18870:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(64746);const d=[{value:"在持续迭代的过程中，开发之初很难把所有需要支持的功能都想清楚，有时候还需要借助社区的力量去持续生产新的功能点，或者优化已有的功能。这就需要系统具备一定的可扩展性。而插件模式就是常常选用的方法，其优点包括：",paraId:0},{value:"单一职责。插件代码与系统代码在工程上解耦，可独立开发，并对开发者隔离框架内部逻辑的复杂度。",paraId:1},{value:"可动态引入和配置。",paraId:1},{value:"在众多常用软件中都能找到插件系统的存在，例如 Webpack、VSCode 和 Chrome 浏览器。",paraId:2},{value:"为了让渲染引擎也具有良好的可扩展性，我们也内置了一套插件系统，让不同的渲染器可以在运行时扩展自身能力。目前支持的完整插件集如下。",paraId:3},{value:"渲染相关\n",paraId:4,tocIndex:0},{value:"g-plugin-canvas-renderer",paraId:5,tocIndex:0},{value:" 基于 Canvas2D 渲染 2D 图形",paraId:6,tocIndex:0},{value:"g-plugin-canvaskit-renderer",paraId:7,tocIndex:0},{value:" 基于 CanvasKit / Skia 渲染 2D 图形",paraId:6,tocIndex:0},{value:"g-plugin-svg-renderer",paraId:8,tocIndex:0},{value:" 基于 SVG 渲染 2D 图形",paraId:6,tocIndex:0},{value:"g-plugin-device-renderer",paraId:9,tocIndex:0},{value:" 基于 WebGPU / WebGL 渲染 2D 图形",paraId:6,tocIndex:0},{value:"g-plugin-html-renderer",paraId:10,tocIndex:0},{value:" 渲染 DOM 元素",paraId:6,tocIndex:0},{value:"g-plugin-3d",paraId:11,tocIndex:0},{value:" 基于 g-plugin-device-renderer 扩展 3D 能力",paraId:6,tocIndex:0},{value:"g-plugin-rough-canvas-renderer",paraId:12,tocIndex:0},{value:" 基于 rough.js 和 Canvas2D 渲染手绘风格图形",paraId:6,tocIndex:0},{value:"g-plugin-rough-svg-renderer",paraId:13,tocIndex:0},{value:" 基于 rough.js 和 SVG 渲染手绘风格图形",paraId:6,tocIndex:0},{value:"拾取\n",paraId:4,tocIndex:0},{value:"g-plugin-canvas-picker",paraId:14,tocIndex:0},{value:" 基于 Canvas2D",paraId:15,tocIndex:0},{value:"g-plugin-svg-picker",paraId:16,tocIndex:0},{value:" 基于 SVG",paraId:15,tocIndex:0},{value:"无障碍\n",paraId:4,tocIndex:0},{value:"g-plugin-a11y",paraId:17,tocIndex:0},{value:" 提供文本提取、Screen Reader、键盘导航等无障碍功能",paraId:18,tocIndex:0},{value:"交互\n",paraId:4,tocIndex:0},{value:"g-plugin-dom-interaction",paraId:19,tocIndex:0},{value:" 基于 DOM API 绑定事件",paraId:20,tocIndex:0},{value:"g-plugin-dragndrop",paraId:21,tocIndex:0},{value:" 基于 PointerEvents 实现拖放功能",paraId:20,tocIndex:0},{value:"g-plugin-control",paraId:22,tocIndex:0},{value:" 为 3D 场景提供相机交互",paraId:20,tocIndex:0},{value:"g-plugin-annotation",paraId:23,tocIndex:0},{value:" 提供基础图形的绘制和编辑能力，类似 ",paraId:20,tocIndex:0},{value:"Fabric.js",paraId:20,tocIndex:0},{value:" 和 ",paraId:20,tocIndex:0},{value:"Konva.js",paraId:20,tocIndex:0},{value:"物理引擎\n",paraId:4,tocIndex:0},{value:"g-plugin-box2d",paraId:24,tocIndex:0},{value:" 基于 Box2D",paraId:25,tocIndex:0},{value:"g-plugin-matterjs",paraId:26,tocIndex:0},{value:" 基于 matter.js",paraId:25,tocIndex:0},{value:"g-plugin-physx",paraId:27,tocIndex:0},{value:" 基于 PhysX",paraId:25,tocIndex:0},{value:"布局引擎\n",paraId:4,tocIndex:0},{value:"g-plugin-yoga",paraId:28,tocIndex:0},{value:" 基于 Yoga 提供 Flex 布局能力",paraId:29,tocIndex:0},{value:"GPGPU\n",paraId:4,tocIndex:0},{value:"g-plugin-gpgpu",paraId:30,tocIndex:0},{value:" 基于 WebGPU 提供 GPGPU 能力",paraId:31,tocIndex:0},{value:"CSS 选择器\n",paraId:4,tocIndex:0},{value:"g-plugin-css-select",paraId:32,tocIndex:0},{value:" 支持使用 CSS 选择器在场景图中检索",paraId:33,tocIndex:0},{value:"首先",paraId:34,tocIndex:2},{value:"引入核心和渲染器",paraId:35,tocIndex:2},{value:"，然后在 HTML 中引入插件的 UMD：",paraId:34,tocIndex:2},{value:'\x3c!-- 插件 --\x3e\n<script src="https://unpkg.com/@antv/g-plugin-rough-canvas-renderer@1.7.16/dist/index.umd.min.js"><\/script>\n',paraId:36,tocIndex:2},{value:"然后在 ",paraId:37,tocIndex:2},{value:"window.G",paraId:37,tocIndex:2},{value:" 的命名空间下使用插件，以 ",paraId:37,tocIndex:2},{value:"g-plugin-rough-canvas-renderer",paraId:38,tocIndex:2},{value:" 为例：",paraId:37,tocIndex:2},{value:"const plugin = new window.G.RoughCanvasRenderer.Plugin();\n",paraId:39,tocIndex:2},{value:"CodeSandbox 例子",paraId:40,tocIndex:2},{value:"首先",paraId:41,tocIndex:3},{value:"安装核心包和渲染器",paraId:42,tocIndex:3},{value:"，然后安装插件，以 ",paraId:41,tocIndex:3},{value:"g-plugin-rough-canvas-renderer",paraId:43,tocIndex:3},{value:" 为例：",paraId:41,tocIndex:3},{value:"npm install @antv/g-plugin-rough-canvas-renderer --save\n",paraId:44,tocIndex:3},{value:"然后可以使用 ",paraId:45,tocIndex:3},{value:"registerPlugin",paraId:46,tocIndex:3},{value:" 在渲染器上注册插件：",paraId:45,tocIndex:3},{value:"import { Plugin } from '@antv/g-plugin-rough-canvas-renderer';\n\nrenderer.registerPlugin(new Plugin());\n",paraId:47,tocIndex:3},{value:"渲染器本质上是由一组插件组成，以 ",paraId:48,tocIndex:4},{value:"g-canvas",paraId:49,tocIndex:4},{value:" 为例，在构造函数中内置了一系列插件：",paraId:48,tocIndex:4},{value:"this.registerPlugin(new ContextRegisterPlugin());\nthis.registerPlugin(new ImageLoader.Plugin());\nthis.registerPlugin(new CanvasPathGenerator.Plugin());\nthis.registerPlugin(new CanvasRenderer.Plugin());\nthis.registerPlugin(new DomInteraction.Plugin());\nthis.registerPlugin(new CanvasPicker.Plugin());\nthis.registerPlugin(new HTMLRenderer.Plugin());\n",paraId:50,tocIndex:4},{value:"在运行时也可以扩展它们的能力：",paraId:51,tocIndex:4},{value:"import { Plugin } from '@antv/g-plugin-rough-canvas-renderer';\nrenderer.registerPlugin(new Plugin());\n",paraId:52,tocIndex:4}]},80118:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(17551);const d=[{value:"支持 ",paraId:0},{value:"matter.js",paraId:0},{value:" 物理引擎（仅支持刚体）。2D 图形初始化后开始仿真，除了受重力和表面摩擦力，在任意时刻也可以施加外力改变图形的位置和旋转角度。",paraId:0},{value:"支持以下 2D 图形：",paraId:1},{value:"Circle",paraId:2},{value:"、",paraId:1},{value:"Rect",paraId:3},{value:"、",paraId:1},{value:"Line",paraId:4},{value:"、",paraId:1},{value:"Image",paraId:5},{value:"、",paraId:1},{value:"Polygon",paraId:6},{value:"在该",paraId:7},{value:"示例",paraId:8},{value:"中，我们创建了一系列动态物体，让它们进行自由落体，最终停留在“U 形槽”中。",paraId:7},{value:"创建插件并在渲染器中注册：",paraId:9,tocIndex:0},{value:"import { Plugin as PluginMatterjs } from '@antv/g-plugin-matterjs';\nrenderer.registerPlugin(new PluginMatterjs());\n",paraId:10,tocIndex:0},{value:"在 2D 图形中使用相关物理属性：",paraId:11,tocIndex:0},{value:"new Circle({\n    style: {\n        rigid: 'dynamic', // 动态物体，参与受力计算\n        density: 10, // 密度：10 千克/平方米\n        r: 10, // 半径：对应物理世界中 10 米\n    },\n});\n",paraId:12,tocIndex:0},{value:"全局物理世界配置。",paraId:13,tocIndex:1},{value:"matter.js \b 本身支持渲染。开启后配合 ",paraId:14,tocIndex:2},{value:"debugContainer",paraId:15,tocIndex:2},{value:" 可以绘制物理引擎世界中每个对象的 wireframe，便于 debug：",paraId:14,tocIndex:2},{value:"const plugin = new PluginMatterjs({\n    debug: true,\n    debugContainer: document.getElementById('container'),\n    debugCanvasWidth: 600,\n    debugCanvasHeight: 500,\n});\n",paraId:16,tocIndex:2},{value:"例如下图展示了三堵静态墙壁和一些动态物体的 wireframe：",paraId:17,tocIndex:2},{value:"类型为 ",paraId:18,tocIndex:3},{value:"HTMLElement",paraId:18,tocIndex:3},{value:"，matter.js 会在容器内创建 ",paraId:18,tocIndex:3},{value:"<canvas>",paraId:18,tocIndex:3},{value:" 用于渲染。",paraId:18,tocIndex:3},{value:"类型为 ",paraId:19,tocIndex:4},{value:"number",paraId:19,tocIndex:4},{value:"，用于调试的 ",paraId:19,tocIndex:4},{value:"<canvas>",paraId:19,tocIndex:4},{value:" 的宽度。",paraId:19,tocIndex:4},{value:"类型为 ",paraId:20,tocIndex:5},{value:"number",paraId:20,tocIndex:5},{value:"，用于调试的 ",paraId:20,tocIndex:5},{value:"<canvas>",paraId:20,tocIndex:5},{value:" 的高度。",paraId:20,tocIndex:5},{value:"重力方向向量，默认值为 ",paraId:21,tocIndex:6},{value:"[0, 1]",paraId:21,tocIndex:6},{value:"。",paraId:21,tocIndex:6},{value:"https://brm.io/matter-js/docs/classes/Engine.html#property_gravity",paraId:22,tocIndex:6},{value:"例如设置成 ",paraId:23,tocIndex:6},{value:"[1, 1]",paraId:23,tocIndex:6},{value:"，物体会自然向右下角运动：",paraId:23,tocIndex:6},{value:"new PluginMatterjs({\n  gravity: [1, 1],\n}),\n",paraId:24,tocIndex:6},{value:"类型为 ",paraId:25,tocIndex:7},{value:"number",paraId:25,tocIndex:7},{value:"，重力缩放系数。",paraId:25,tocIndex:7},{value:"https://brm.io/matter-js/docs/classes/Engine.html#property_gravity.scale",paraId:26,tocIndex:7},{value:"仿真时间间隔，默认值为 ",paraId:27,tocIndex:8},{value:"1/60",paraId:27,tocIndex:8},{value:"计算加速度迭代次数，默认值为 ",paraId:28,tocIndex:9},{value:"4",paraId:28,tocIndex:9},{value:"，越高计算开销越大",paraId:28,tocIndex:9},{value:"https://brm.io/matter-js/docs/classes/Engine.html#property_velocityIterations",paraId:29,tocIndex:9},{value:"计算位置迭代次数，默认值为 ",paraId:30,tocIndex:10},{value:"6",paraId:30,tocIndex:10},{value:"，越高计算开销越大",paraId:30,tocIndex:10},{value:"https://brm.io/matter-js/docs/classes/Engine.html#property_positionIterations",paraId:31,tocIndex:10},{value:"以下属性大部分都支持运行时修改，例如修改密度：",paraId:32,tocIndex:11},{value:"circle.style.density = 100;\n",paraId:33,tocIndex:11},{value:"刚体类型：",paraId:34,tocIndex:12},{value:"static 静态物体，例如地面",paraId:35,tocIndex:12},{value:"dynamic 动态物体，计算受力",paraId:35,tocIndex:12},{value:"密度，千克/平方米。静态物体为 0。",paraId:36,tocIndex:13},{value:"https://brm.io/matter-js/docs/classes/Body.html#property_density",paraId:37,tocIndex:13},{value:"线速度，默认值为 ",paraId:38,tocIndex:14},{value:"[0, 0]",paraId:38,tocIndex:14},{value:"。",paraId:38,tocIndex:14},{value:"https://brm.io/matter-js/docs/classes/Body.html#property_velocity",paraId:39,tocIndex:14},{value:"角速度，默认值为 ",paraId:40,tocIndex:15},{value:"0",paraId:40,tocIndex:15},{value:"。",paraId:40,tocIndex:15},{value:"https://brm.io/matter-js/docs/classes/Body.html#property_angularVelocity",paraId:41,tocIndex:15},{value:"摩擦力，取值范围为 ",paraId:42,tocIndex:16},{value:"[0 - 1]",paraId:42,tocIndex:16},{value:"，默认值为 ",paraId:42,tocIndex:16},{value:"0.1",paraId:42,tocIndex:16},{value:"。",paraId:42,tocIndex:16},{value:"0",paraId:42,tocIndex:16},{value:" 代表物体会无限滑动下去，",paraId:42,tocIndex:16},{value:"1",paraId:42,tocIndex:16},{value:" 表示物体受力后会立刻停止。",paraId:42,tocIndex:16},{value:"https://brm.io/matter-js/docs/classes/Body.html#property_friction",paraId:43,tocIndex:16},{value:"定义在空气中的摩擦力，",paraId:44,tocIndex:17},{value:"0",paraId:44,tocIndex:17},{value:" 表示无重力，值越高物体在空间中移动减速就越明显，默认值为 ",paraId:44,tocIndex:17},{value:"0.01",paraId:44,tocIndex:17},{value:"。",paraId:44,tocIndex:17},{value:"https://brm.io/matter-js/docs/classes/Body.html#property_frictionAir",paraId:45,tocIndex:17},{value:"默认值为 ",paraId:46,tocIndex:18},{value:"0.5",paraId:46,tocIndex:18},{value:"https://brm.io/matter-js/docs/classes/Body.html#property_frictionStatic",paraId:47,tocIndex:18},{value:"恢复力，取值范围为 ",paraId:48,tocIndex:19},{value:"[0 - 1]",paraId:48,tocIndex:19},{value:"。例如一个球落向地面，恢复力为 0 时则不会弹起。",paraId:48,tocIndex:19},{value:"除了通过初始化参数进行仿真，在任意时刻都可以通过施加外力，改变物体的位置和旋转角度。",paraId:49,tocIndex:20},{value:"方法签名，对一个图形在某个点上施加力：",paraId:50,tocIndex:21},{value:"applyForce(object: DisplayObject, force: [number, number], point: [number, number])\n",paraId:51,tocIndex:21},{value:"const plugin = new PluginMatterjs();\nplugin.applyForce(circle, [10, 0], [0, 0]);\n",paraId:52,tocIndex:21}]},43280:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(57815);const d=[{value:"使用 ",paraId:0},{value:"rough.js",paraId:0},{value:" 的 Canvas 版本进行手绘风格的渲染，",paraId:0},{value:"示例",paraId:1},{value:"。",paraId:0},{value:"首先需要使用 ",paraId:2,tocIndex:0},{value:"g-canvas",paraId:2,tocIndex:0},{value:" 渲染器，注册该插件，它会替换掉 ",paraId:2,tocIndex:0},{value:"g-plugin-canvas-renderer",paraId:3,tocIndex:0},{value:" 中对于 2D 图形的渲染效果：",paraId:2,tocIndex:0},{value:"import { Canvas } from '@antv/g';\nimport { Renderer } from '@antv/g-canvas';\nimport { Plugin as PluginRoughCanvasRenderer } from '@antv/g-plugin-rough-canvas-renderer';\n\n// create a renderer\nconst renderer = new Renderer();\nrenderer.registerPlugin(new PluginRoughCanvasRenderer());\n\n// create a canvas & use `g-canvas`\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer,\n});\n",paraId:4,tocIndex:0},{value:"需要注意的是一旦使用该插件，“脏矩形渲染”便无法使用，这意味着任何图形的任何样式属性改变，都会导致画布的全量重绘。",paraId:5,tocIndex:0},{value:"另外，我们支持所有 2D 图形，其中 ",paraId:6,tocIndex:0},{value:"Text",paraId:7,tocIndex:0},{value:"、",paraId:6,tocIndex:0},{value:"Image",paraId:8,tocIndex:0},{value:" 和 ",paraId:6,tocIndex:0},{value:"HTML",paraId:9,tocIndex:0},{value:" 无手绘风格。",paraId:6,tocIndex:0},{value:"除了 2D 图形的样式属性，rough.js 提供的配置项也可以使用。",paraId:10,tocIndex:1},{value:"rough.js 并不支持 ",paraId:11,tocIndex:2},{value:"opacity",paraId:11,tocIndex:2},{value:"，但我们可以通过 ",paraId:11,tocIndex:2},{value:"globalAlpha",paraId:11,tocIndex:2},{value:" 实现，这一点和 ",paraId:11,tocIndex:2},{value:"g-plugin-canvas-renderer",paraId:12,tocIndex:2},{value:" 一样。",paraId:11,tocIndex:2},{value:"rough.js 并不支持 ",paraId:13,tocIndex:3},{value:"shadow",paraId:13,tocIndex:3},{value:" 相关效果，但我们提供了相关效果：",paraId:13,tocIndex:3},{value:"配置项可以参考 ",paraId:14,tocIndex:3},{value:"阴影",paraId:15,tocIndex:3},{value:"：",paraId:14,tocIndex:3},{value:"circle.style.shadowColor = '#000';\ncircle.style.shadowBlur = 0;\ncircle.style.shadowOffsetX = 0;\ncircle.style.shadowOffsetY = 0;\n",paraId:16,tocIndex:3},{value:"rough.js 提供了很多影响手绘效果的",paraId:17,tocIndex:4},{value:"配置项",paraId:17,tocIndex:4},{value:"，都可以正常使用。",paraId:17,tocIndex:4},{value:"示例",paraId:18,tocIndex:4},{value:"表示手绘风格程度，默认值为 ",paraId:19,tocIndex:4},{value:"1",paraId:19,tocIndex:4},{value:"。",paraId:19,tocIndex:4},{value:"0",paraId:19,tocIndex:4},{value:" 代表无手绘效果，数字越大风格化效果越明显，但超过 ",paraId:19,tocIndex:4},{value:"10",paraId:19,tocIndex:4},{value:" 会完全失去原本的形状也就没意义了。",paraId:19,tocIndex:4},{value:"circle.style.roughness = 2;\n",paraId:20,tocIndex:4},{value:"线条的弯曲程度，默认值为 ",paraId:21,tocIndex:5},{value:"1",paraId:21,tocIndex:5},{value:"。",paraId:21,tocIndex:5},{value:"0",paraId:21,tocIndex:5},{value:" 代表直线。",paraId:21,tocIndex:5},{value:"示例",paraId:22,tocIndex:5},{value:"circle.style.bowing = 2;\n",paraId:23,tocIndex:5},{value:"填充风格，支持以下枚举值，",paraId:24,tocIndex:6},{value:"示例",paraId:25,tocIndex:6},{value:"：",paraId:24,tocIndex:6},{value:"'hachure'",paraId:26,tocIndex:6},{value:"'solid'",paraId:26,tocIndex:6},{value:"'zigzag'",paraId:26,tocIndex:6},{value:"'cross-hatch'",paraId:26,tocIndex:6},{value:"'dots'",paraId:26,tocIndex:6},{value:"'dashed'",paraId:26,tocIndex:6},{value:"'zigzag-line'",paraId:26,tocIndex:6},{value:"circle.style.fillStyle = 'zigzag';\n",paraId:27,tocIndex:6},{value:"代表填充的线宽，默认为 ",paraId:28,tocIndex:7},{value:"strokeWidth",paraId:28,tocIndex:7},{value:" 的一半。当 ",paraId:28,tocIndex:7},{value:"fillStyle",paraId:29,tocIndex:7},{value:" 选择 ",paraId:28,tocIndex:7},{value:"'dots'",paraId:28,tocIndex:7},{value:" 样式时，代表点的直径。",paraId:28,tocIndex:7},{value:"circle.style.fillWeight = 2;\n",paraId:30,tocIndex:7},{value:"填充线条旋转的角度，默认为 ",paraId:31,tocIndex:8},{value:"-41",paraId:31,tocIndex:8},{value:"。",paraId:31,tocIndex:8},{value:"circle.style.hachureAngle = 30;\n",paraId:32,tocIndex:8},{value:"相邻填充线条之间的距离，默认值为 ",paraId:33,tocIndex:9},{value:"strokeWidth",paraId:33,tocIndex:9},{value:" 的 4 倍。",paraId:33,tocIndex:9},{value:"绘制 Ellipse Circle 和曲线时，用于近似步长估计，默认值为 ",paraId:34,tocIndex:10},{value:"9",paraId:34,tocIndex:10},{value:"，越小会越走形。",paraId:34,tocIndex:10},{value:"绘制 Ellipse Circle 和曲线时，用于决定填充区域比例，默认值为 ",paraId:35,tocIndex:11},{value:"0.95",paraId:35,tocIndex:11},{value:"，越小会越走形。",paraId:35,tocIndex:11},{value:"描边虚线。",paraId:36,tocIndex:12},{value:"circle.style.lineDash = [10, 10];\n",paraId:37,tocIndex:12},{value:"描边虚线偏移量。",paraId:38,tocIndex:13},{value:"circle.style.lineDashOffset = 10;\n",paraId:39,tocIndex:13},{value:"填充虚线。",paraId:40,tocIndex:14},{value:"circle.style.fillLineDash = [10, 10];\n",paraId:41,tocIndex:14},{value:"填充虚线偏移量。",paraId:42,tocIndex:15},{value:"circle.style.fillLineDashOffset = 10;\n",paraId:43,tocIndex:15},{value:"禁止在描边上应用多个线条。",paraId:44,tocIndex:16},{value:"circle.style.disableMultiStroke = true;\n",paraId:45,tocIndex:16},{value:"禁止在填充上应用多个线条。",paraId:46,tocIndex:17},{value:"circle.style.disableMultiStrokeFill = true;\n",paraId:47,tocIndex:17},{value:"路径简化程度，取值范围在 ",paraId:48,tocIndex:18},{value:"0 - 1",paraId:48,tocIndex:18},{value:" 之间，默认值为 ",paraId:48,tocIndex:18},{value:"0",paraId:48,tocIndex:18},{value:"，值越大简化程度越高。",paraId:48,tocIndex:18},{value:"当 ",paraId:49,tocIndex:19},{value:"fillStyle",paraId:50,tocIndex:19},{value:" 选择 ",paraId:49,tocIndex:19},{value:"'dashed'",paraId:49,tocIndex:19},{value:" 时，表示每段虚线长度。未设置会使用 ",paraId:49,tocIndex:19},{value:"hachureGap",paraId:51,tocIndex:19},{value:" 的值。",paraId:49,tocIndex:19},{value:"当 ",paraId:52,tocIndex:20},{value:"fillStyle",paraId:53,tocIndex:20},{value:" 选择 ",paraId:52,tocIndex:20},{value:"'dashed'",paraId:52,tocIndex:20},{value:" 时，表示虚线间隔。未设置会使用 ",paraId:52,tocIndex:20},{value:"hachureGap",paraId:54,tocIndex:20},{value:" 的值。",paraId:52,tocIndex:20},{value:"当 ",paraId:55,tocIndex:21},{value:"fillStyle",paraId:56,tocIndex:21},{value:" 选择 ",paraId:55,tocIndex:21},{value:"'zigzag-line'",paraId:55,tocIndex:21},{value:" 时，指定三角形的宽度。未设置会使用 ",paraId:55,tocIndex:21},{value:"hachureGap",paraId:57,tocIndex:21},{value:" 的值。",paraId:55,tocIndex:21},{value:"在 ",paraId:58,tocIndex:23},{value:"g-plugin-canvas-picker",paraId:59,tocIndex:23},{value:" 中我们使用空间索引快速过滤，再配合图形几何定义的数学计算完成精确拾取。",paraId:58,tocIndex:23},{value:"但在手绘风格下，似乎无法也没必要做精确拾取，因此我们仍使用该插件。",paraId:60,tocIndex:23}]},23068:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(2195);const d=[{value:"使用 ",paraId:0},{value:"rough.js",paraId:0},{value:" 的 SVG 版本进行手绘风格的渲染，",paraId:0},{value:"示例",paraId:1},{value:"。",paraId:0},{value:"首先需要使用 ",paraId:2,tocIndex:0},{value:"g-svg",paraId:2,tocIndex:0},{value:" 渲染器，注册该插件，它会替换掉 ",paraId:2,tocIndex:0},{value:"g-plugin-svg-renderer",paraId:3,tocIndex:0},{value:" 中对于 2D 图形的渲染效果：",paraId:2,tocIndex:0},{value:"import { Canvas } from '@antv/g';\nimport { Renderer } from '@antv/g-svg';\nimport { Plugin as PluginRoughSVGRenderer } from '@antv/g-plugin-rough-svg-renderer';\n\n// create a renderer\nconst renderer = new Renderer();\nrenderer.registerPlugin(new PluginRoughSVGRenderer());\n\n// create a canvas & use `g-svg`\nconst canvas = new Canvas({\n    container: 'container',\n    width: 600,\n    height: 500,\n    renderer,\n});\n",paraId:4,tocIndex:0},{value:"另外，我们支持所有 2D 图形，其中 ",paraId:5,tocIndex:0},{value:"Text",paraId:6,tocIndex:0},{value:"、",paraId:5,tocIndex:0},{value:"Image",paraId:7,tocIndex:0},{value:" 和 ",paraId:5,tocIndex:0},{value:"HTML",paraId:8,tocIndex:0},{value:" 无手绘风格。",paraId:5,tocIndex:0},{value:"除了 2D 图形的样式属性，rough.js 提供的配置项也可以使用。可以完全参考 ",paraId:9,tocIndex:1},{value:"g-plugin-rough-canvas-renderer",paraId:10,tocIndex:1},{value:"。",paraId:9,tocIndex:1},{value:"非 ",paraId:11,tocIndex:2},{value:"solid",paraId:11,tocIndex:2},{value:" 的填充样式会留下很多空白，这些空白区域并不会触发交互事件。这一点和 ",paraId:11,tocIndex:2},{value:"g-plugin-canvas-renderer",paraId:12,tocIndex:2},{value:" 不一致。",paraId:11,tocIndex:2}]},81573:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(88238);const d=[{value:"提供基于 SVG 的拾取能力。",paraId:0},{value:"g-svg",paraId:1,tocIndex:0},{value:" 渲染器默认内置，因此无需手动引入。",paraId:1,tocIndex:0},{value:"import { Renderer as SvgRenderer } from '@antv/g-svg';\n// 创建 SVG 渲染器，其中内置了该插件\nconst svgRenderer = new SvgRenderer();\n",paraId:2,tocIndex:0},{value:"直接使用 ",paraId:3,tocIndex:1},{value:"elementFromPoint",paraId:3,tocIndex:1},{value:" 获取 ",paraId:3,tocIndex:1},{value:"SVGElement",paraId:3,tocIndex:1},{value:"。找到后通过 ",paraId:3,tocIndex:1},{value:"id",paraId:3,tocIndex:1},{value:" 查询 ",paraId:3,tocIndex:1},{value:"DisplayObject",paraId:3,tocIndex:1},{value:" 返回。",paraId:3,tocIndex:1}]},13278:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(29878);const d=[{value:"提供基于 SVG 的渲染能力。",paraId:0},{value:"g-svg",paraId:1,tocIndex:0},{value:" 渲染器默认内置，因此无需手动引入。",paraId:1,tocIndex:0},{value:"import { Renderer as SvgRenderer } from '@antv/g-svg';\n// 创建 SVG 渲染器，其中内置了该插件\nconst svgRenderer = new SvgRenderer();\n",paraId:2,tocIndex:0},{value:"该插件暴露以下扩展点。",paraId:3,tocIndex:1},{value:"该扩展点提供 SVG 元素从创建、更新到销毁的生命周期。",paraId:4,tocIndex:2},{value:"export interface ElementLifeCycleContribution {\n    createElement: (object: DisplayObject) => SVGElement;\n    shouldUpdateElementAttribute: (\n        object: DisplayObject,\n        attributeName: string,\n    ) => boolean;\n    updateElementAttribute: (object: DisplayObject, $el: SVGElement) => void;\n    destroyElement: (object: DisplayObject, $el: SVGElement) => void;\n}\n",paraId:5,tocIndex:2},{value:"不同渲染器插件可以实现以上接口，使用自定义方式管理每个图形的生命周期。例如下面的代码展示了两个基于 SVG 的渲染器插件，前者为 ",paraId:6,tocIndex:2},{value:"g-svg",paraId:7,tocIndex:2},{value:" 内置，提供默认 SVG 元素的渲染能力，后者在此基础上借助 rough.js 实现手绘风格渲染。",paraId:6,tocIndex:2},{value:"// g-plugin-svg-renderer\n@singleton({ token: ElementLifeCycleContribution })\nexport class DefaultElementLifeCycleContribution\n    implements ElementLifeCycleContribution {}\n\n// g-plugin-svg-rough-renderer\n@singleton({ token: ElementLifeCycleContribution })\nexport class RoughElementLifeCycleContribution\n    implements ElementLifeCycleContribution {}\n",paraId:8,tocIndex:2},{value:"该方法根据传入的基础图形，使用 DOM API 创建对应的 SVGElement。在触发 ",paraId:9,tocIndex:3},{value:"ElementEvent.MOUNTED",paraId:10,tocIndex:3},{value:" 事件时调用。",paraId:9,tocIndex:3},{value:"重绘在 SVG 中表现为属性更新，但部分属性（例如 ",paraId:11,tocIndex:4},{value:"visibility",paraId:12,tocIndex:4},{value:"，",paraId:11,tocIndex:4},{value:"z-index",paraId:13,tocIndex:4},{value:" 等）的更新我们有统一的内部实现，并不打算开放自定义能力。因此需要有一个判断方法决定是否触发属性更新。",paraId:11,tocIndex:4},{value:"当图形首次挂载触发 ",paraId:14,tocIndex:4},{value:"ElementEvent.MOUNTED",paraId:15,tocIndex:4},{value:" 以及后续属性更新触发 ",paraId:14,tocIndex:4},{value:"ElementEvent.ATTR_MODIFIED",paraId:16,tocIndex:4},{value:" 事件时调用。",paraId:14,tocIndex:4},{value:"通过属性更新判断方法后，执行更新属性逻辑。",paraId:17,tocIndex:5},{value:"当图形从画布中移除触发 ",paraId:18,tocIndex:6},{value:"ElementEvent.UNMOUNTED",paraId:19,tocIndex:6},{value:" 时调用该方法。",paraId:18,tocIndex:6}]},6248:function(a,e,n){n.r(e),n.d(e,{texts:function(){return d}});n(73826);const d=[{value:"Yoga",paraId:0},{value:" 是 Facebook 提供的跨平台布局引擎，基于 Flex，属性和 CSS Flex 完全一致，因此也可以阅读 ",paraId:0},{value:"MDN flex 布局的基本概念",paraId:0},{value:" 获取更多概念知识。",paraId:0},{value:"示例：",paraId:1},{value:"容器相关配置",paraId:2},{value:"子元素相关配置",paraId:3},{value:"自适应布局",paraId:4},{value:"文本换行",paraId:5},{value:"对相关属性应用动画",paraId:6},{value:"该插件使用 ",paraId:7},{value:"yoga-layout-prebuilt",paraId:7},{value:"，包体积较大，后续我们会使用自己开发的轻量版布局引擎。",paraId:7},{value:"首先注册插件：",paraId:8,tocIndex:0},{value:"import { Renderer } from '@antv/g-canvas';\nimport { Plugin } from '@antv/g-plugin-yoga';\n\nconst renderer = new Renderer();\nrenderer.registerPlugin(new Plugin());\n",paraId:9,tocIndex:0},{value:"通过 ",paraId:10,tocIndex:0},{value:"display: 'flex'",paraId:10,tocIndex:0},{value:" 可以声明一个图形使用 Flex 布局。目前我们仅支持 ",paraId:10,tocIndex:0},{value:"Rect",paraId:11,tocIndex:0},{value:" 和 ",paraId:10,tocIndex:0},{value:"Group",paraId:12,tocIndex:0},{value:" 两类图形作为 Flex 容器：",paraId:10,tocIndex:0},{value:"// 声明一个容器\nconst container = new Rect({\n    style: {\n        width: 500, // 尺寸\n        height: 300,\n        display: 'flex', // 声明使用 flex 布局\n        justifyContent: 'center', // 居中\n        alignItems: 'center', // 居中\n        x: 0,\n        y: 0,\n        fill: '#C6E5FF',\n    },\n});\ncanvas.appendChild(container);\n\n// 声明子元素，不需要手动设置位置，由布局引擎计算\nconst node1 = new Rect({\n    style: {\n        fill: 'white',\n        width: 100,\n        height: 100,\n    },\n});\nconst node2 = new Rect({\n    style: {\n        fill: 'white',\n        width: 100,\n        height: 100,\n    },\n});\ncontainer.appendChild(node1);\ncontainer.appendChild(node2);\n",paraId:13,tocIndex:0},{value:"不同的属性支持的单位也不同，例如 ",paraId:14,tocIndex:1},{value:"number",paraId:14,tocIndex:1},{value:" 类型的绝对像素值、",paraId:14,tocIndex:1},{value:"'100%'",paraId:14,tocIndex:1},{value:" 字符串类型的百分比以及特殊含义的 ",paraId:14,tocIndex:1},{value:"'auto'",paraId:14,tocIndex:1},{value:"。",paraId:14,tocIndex:1},{value:"使用 ",paraId:15,tocIndex:2},{value:"display: 'flex'",paraId:15,tocIndex:2},{value:" 可以声明一个 Flex 容器，容器内所有直系子元素按照布局引擎计算结果进行布局，暂时仅支持 ",paraId:15,tocIndex:2},{value:"Rect",paraId:16,tocIndex:2},{value:" 和 ",paraId:15,tocIndex:2},{value:"Group",paraId:17,tocIndex:2},{value:" 作为容器：",paraId:15,tocIndex:2},{value:"// 或者使用 Group\n// const container = new Group({\nconst container = new Rect({\n    style: {\n        width: 500, // 尺寸\n        height: 300,\n        display: 'flex', // 声明使用 flex 布局\n        justifyContent: 'center', // 居中\n        alignItems: 'center', // 居中\n        x: 0, // 容器局部坐标系下位置\n        y: 0,\n        fill: '#C6E5FF', // 其他样式属性\n    },\n});\n",paraId:18,tocIndex:2},{value:"容器内子元素无类型限制，例如下图中可以看到 ",paraId:19,tocIndex:2},{value:"Image",paraId:20,tocIndex:2},{value:" 也可以按照计算结果正常布局。",paraId:19,tocIndex:2},{value:"另外容器支持嵌套，例如上图中 Node1 自身也是一个 Flex 容器，因此其中的文本可以水平垂直居中。",paraId:21,tocIndex:2},{value:"Layout 属性用于设置自身在容器中的布局效果，例如相对于已有结果进行调整。",paraId:22,tocIndex:3},{value:"支持以下取值，可以配合 top / right / botton / left 使用，和 CSS 完全一致：",paraId:23,tocIndex:4},{value:"relative",paraId:24,tocIndex:4},{value:" 默认值，相对于正常布局位置",paraId:24,tocIndex:4},{value:"absolute",paraId:24,tocIndex:4},{value:" 相对于父容器进行绝对定位",paraId:24,tocIndex:4},{value:"下左图中 Node1 使用 ",paraId:25,tocIndex:4},{value:"relative",paraId:25,tocIndex:4},{value:"，下右图使用 ",paraId:25,tocIndex:4},{value:"absolute",paraId:25,tocIndex:4},{value:" 进行绝对定位：",paraId:25,tocIndex:4},{value:"可应用动画",paraId:26,tocIndex:5},{value:"支持绝对值与百分比，例如 ",paraId:27,tocIndex:5},{value:"{ top: 10 }",paraId:27,tocIndex:5},{value:"、",paraId:27,tocIndex:5},{value:"{ top: '50%' }",paraId:27,tocIndex:5},{value:"。当传入百分比字符串时，相对于父元素的尺寸。",paraId:27,tocIndex:5},{value:"例如下图中 Node1 使用 ",paraId:28,tocIndex:5},{value:"absolute",paraId:28,tocIndex:5},{value:" 进行绝对定位，",paraId:28,tocIndex:5},{value:"top",paraId:28,tocIndex:5},{value:" 和 ",paraId:28,tocIndex:5},{value:"left",paraId:28,tocIndex:5},{value:" 设置为 10：",paraId:28,tocIndex:5},{value:"下图中 Node1 使用 ",paraId:29,tocIndex:5},{value:"absolute",paraId:29,tocIndex:5},{value:" 进行绝对定位，",paraId:29,tocIndex:5},{value:"top",paraId:29,tocIndex:5},{value:" 取 ",paraId:29,tocIndex:5},{value:"'50%'",paraId:29,tocIndex:5},{value:"，即父元素高度的一半：",paraId:29,tocIndex:5},{value:"下图中 Node1 使用 ",paraId:30,tocIndex:5},{value:"absolute",paraId:30,tocIndex:5},{value:" 进行绝对定位，",paraId:30,tocIndex:5},{value:"top",paraId:30,tocIndex:5},{value:" 取 ",paraId:30,tocIndex:5},{value:"-50",paraId:30,tocIndex:5},{value:"：",paraId:30,tocIndex:5},{value:"可应用动画",paraId:31,tocIndex:6},{value:"设置自身宽高尺寸。默认值为 ",paraId:32,tocIndex:6},{value:"'auto'",paraId:32,tocIndex:6},{value:"。",paraId:32,tocIndex:6},{value:"支持百分比和绝对值，取百分比时相对于父元素尺寸。",paraId:33,tocIndex:6},{value:"例如下图中 Node1 设置了一个稍大一些的长宽：",paraId:34,tocIndex:6},{value:"最大最小约束，优先级高于其他属性。可以配合 ",paraId:35,tocIndex:7},{value:"flexGrow",paraId:36,tocIndex:7},{value:" 使用。",paraId:35,tocIndex:7},{value:"默认值为 NaN，即无约束。支持百分比和绝对值，取百分比时相对于父元素尺寸，例如 ",paraId:37,tocIndex:7},{value:"{ minWidth: 50% }",paraId:37,tocIndex:7},{value:"。",paraId:37,tocIndex:7},{value:"例如下图 Node1 设置了 ",paraId:38,tocIndex:7},{value:"{ flexGrow: 1, maxWidth: 50% }",paraId:38,tocIndex:7},{value:"，因此它最多只能占据父元素宽度的一半：",paraId:38,tocIndex:7},{value:"可应用动画",paraId:39,tocIndex:8},{value:"数据类型为 ",paraId:40,tocIndex:8},{value:"[number | string, number | string, number | string, number | string]",paraId:40,tocIndex:8},{value:"，一次性设置上右下左的 padding。",paraId:40,tocIndex:8},{value:"支持以下取值，可参考 ",paraId:41,tocIndex:8},{value:"CSS padding 属性",paraId:41,tocIndex:8},{value:"：",paraId:41,tocIndex:8},{value:"绝对像素值，不支持负值，例如 ",paraId:42,tocIndex:8},{value:"10",paraId:42,tocIndex:8},{value:"百分比字符串，不支持负值，例如 ",paraId:42,tocIndex:8},{value:"'50%'",paraId:42,tocIndex:8},{value:"，取百分比时相对于",paraId:42,tocIndex:8},{value:"自身的宽度",paraId:42,tocIndex:8},{value:"例如以下两种写法等价：",paraId:43,tocIndex:8},{value:"{\n    padding: [10, 0, 10, 0],\n}\n{\n    paddingTop: 10,\n    paddingRight: 0,\n    paddingBottom: 10,\n    paddingLeft: 0,\n}\n",paraId:44,tocIndex:8},{value:"可应用动画",paraId:45,tocIndex:9},{value:"数据类型为 ",paraId:46,tocIndex:9},{value:"number | string",paraId:46,tocIndex:9},{value:"，统一设置上右下左的 padding。",paraId:46,tocIndex:9},{value:"可应用动画",paraId:47,tocIndex:10},{value:"单独设置上右下左的 padding。",paraId:48,tocIndex:10},{value:"可应用动画",paraId:49,tocIndex:11},{value:"type PixelsOrPercentage = number | string;\ntype YogaSize = PixelsOrPercentage | 'auto';\n",paraId:50,tocIndex:11},{value:"数据类型为 ",paraId:51,tocIndex:11},{value:"[YogaSize, YogaSize, YogaSize, YogaSize]",paraId:51,tocIndex:11},{value:"，一次性设置上右下左的 margin。",paraId:51,tocIndex:11},{value:"支持以下取值，可参考 ",paraId:52,tocIndex:11},{value:"CSS margin 属性",paraId:52,tocIndex:11},{value:"：",paraId:52,tocIndex:11},{value:"绝对像素值，支持负值，例如 ",paraId:53,tocIndex:11},{value:"10",paraId:53,tocIndex:11},{value:" ",paraId:53,tocIndex:11},{value:"-50",paraId:53,tocIndex:11},{value:"百分比字符串，支持负值，例如 ",paraId:53,tocIndex:11},{value:"'50%'",paraId:53,tocIndex:11},{value:" ",paraId:53,tocIndex:11},{value:"'-20%'",paraId:53,tocIndex:11},{value:"，取百分比时相对于",paraId:53,tocIndex:11},{value:"父元素的宽度",paraId:53,tocIndex:11},{value:"'auto'",paraId:53,tocIndex:11},{value:"，让布局引擎选择合适的外边距，可实现元素居中",paraId:53,tocIndex:11},{value:"例如下图中 Node1 分别设置了 ",paraId:54,tocIndex:11},{value:"marginRight: 10",paraId:54,tocIndex:11},{value:" 和 ",paraId:54,tocIndex:11},{value:"marginLeft: -50",paraId:54,tocIndex:11},{value:"：",paraId:54,tocIndex:11},{value:"下图展示了 ",paraId:55,tocIndex:11},{value:"marginTop: '50%'",paraId:55,tocIndex:11},{value:" 的效果，以父元素宽度（500）为基准：",paraId:55,tocIndex:11},{value:"下图展示了 ",paraId:56,tocIndex:11},{value:"margin: [0, 'auto', 0, 'auto']",paraId:56,tocIndex:11},{value:" 的效果，让元素水平居中：",paraId:56,tocIndex:11},{value:"可应用动画",paraId:57,tocIndex:12},{value:"数据类型为 ",paraId:58,tocIndex:12},{value:"YogaSize",paraId:58,tocIndex:12},{value:"，统一设置上右下左的 margin。详见 ",paraId:58,tocIndex:12},{value:"margin",paraId:59,tocIndex:12},{value:"。",paraId:58,tocIndex:12},{value:"可应用动画",paraId:60,tocIndex:13},{value:"单独设置上右下左的 margin。详见 ",paraId:61,tocIndex:13},{value:"margin",paraId:62,tocIndex:13},{value:"。",paraId:61,tocIndex:13},{value:"暂不支持。",paraId:63,tocIndex:14},{value:"来自 ",paraId:64,tocIndex:16},{value:"MDN 的说明",paraId:64,tocIndex:16},{value:"使用 flex 布局时，首先想到的是两根轴线：主轴和交叉轴。主轴由 ",paraId:65,tocIndex:16},{value:"flexDirection",paraId:65,tocIndex:16},{value:" 定义，另一根轴垂直于它。",paraId:65,tocIndex:16},{value:"支持以下取值：",paraId:66,tocIndex:16},{value:"row 默认值",paraId:67,tocIndex:16},{value:"row-reverse",paraId:67,tocIndex:16},{value:"column",paraId:67,tocIndex:16},{value:"column-reverse",paraId:67,tocIndex:16},{value:"下左图为默认效果，下右图为 ",paraId:68,tocIndex:16},{value:"column",paraId:68,tocIndex:16},{value:"：",paraId:68,tocIndex:16},{value:"来自 ",paraId:69,tocIndex:17},{value:"MDN 的说明",paraId:69,tocIndex:17},{value:"：",paraId:69,tocIndex:17},{value:"虽然 flexbox 是一维模型，但可以使我们的 flex 项目应用到多行中。 在这样做的时候，您应该把每一行看作一个新的 flex 容器。 任何空间分布都将在该行上发生，而不影响该空间分布的其他行。",paraId:70,tocIndex:17},{value:"支持以下取值：",paraId:71,tocIndex:17},{value:"wrap",paraId:72,tocIndex:17},{value:"no-wrap 默认值",paraId:72,tocIndex:17},{value:"wrap-reverse",paraId:72,tocIndex:17},{value:"在该",paraId:73,tocIndex:17},{value:"示例",paraId:74,tocIndex:17},{value:"中，可以点击 ",paraId:73,tocIndex:17},{value:"appendChild",paraId:73,tocIndex:17},{value:" 按钮向容器中添加子元素。下左图展示了容器默认 ",paraId:73,tocIndex:17},{value:"no-wrap",paraId:73,tocIndex:17},{value:" 的效果（注意由于不允许换行，子元素在宽度上被压缩了），下右图设置为 ",paraId:73,tocIndex:17},{value:"wrap",paraId:73,tocIndex:17},{value:" 自动换行：",paraId:73,tocIndex:17},{value:"可应用动画",paraId:75,tocIndex:18},{value:"该属性是处理子元素在主轴上增加空间的问题。当 Flex 容器首次分配完子元素空间之后，如果还有剩余空间，它会按照这些子元素的 flexGrow 属性进行二次分配。",paraId:76,tocIndex:18},{value:"默认值为 0，支持大于等于 0 的取值，作为分配剩余空间的权重。",paraId:77,tocIndex:18},{value:"例如下图中，Node1 和 Node2 都设置了初始大小 ",paraId:78,tocIndex:18},{value:"{ width: 100, height: 100 }",paraId:78,tocIndex:18},{value:"，但 Node1 额外设置了 ",paraId:78,tocIndex:18},{value:"{ flexGrow: 1 }",paraId:78,tocIndex:18},{value:"，因此它将占据容器主轴上的全部剩余空间（总宽度 500 - Node2 宽度 100 = 400），效果上看就被“拉长”了：",paraId:78,tocIndex:18},{value:"如果想让 Node1 和 Node2 平分空间，可以在 Node2 上也设置 ",paraId:79,tocIndex:18},{value:"{ flexGrow: 1 }",paraId:79,tocIndex:18},{value:"。",paraId:79,tocIndex:18},{value:"可以在该",paraId:80,tocIndex:18},{value:"示例",paraId:81,tocIndex:18},{value:"中调整以观察效果。特别适合实现“自适应”布局，当容器宽度发生修改时，剩余空间也跟着改变。",paraId:80,tocIndex:18},{value:"另外，剩余空间的分配也会考虑到子元素上 ",paraId:82,tocIndex:18},{value:"min/maxWidth/Height",paraId:83,tocIndex:18},{value:" 这样的约束条件，在该",paraId:82,tocIndex:18},{value:"示例",paraId:84,tocIndex:18},{value:"中，Node1 同时设置了 ",paraId:82,tocIndex:18},{value:"{ maxWidth: 200 }",paraId:82,tocIndex:18},{value:"，因此即使容器还有更多剩余空间，也不会分配给它（注意下图右侧容器的空白部分）：",paraId:82,tocIndex:18},{value:"同样，当剩余空间不足时，",paraId:85,tocIndex:18},{value:"minWidth",paraId:85,tocIndex:18},{value:" 也能做为一个下限，例如下图中 Node1 最小宽度设置为 50，因此即使容器宽度仅有 100，也将保证它的展示宽度：",paraId:85,tocIndex:18},{value:"可应用动画",paraId:86,tocIndex:19},{value:"该属性是处理子元素收缩的问题。如果容器中没有足够排列元素的空间，那么可以把子元素的 flexShrink 属性设置为正整数来缩小它所占空间到 flexBasis 以下。与 flexGrow 属性一样，可以赋予不同的值来控制子元素收缩的程度，即给 flexShrink 属性赋予更大的数值可以比赋予小数值的同级元素收缩程度更大。",paraId:87,tocIndex:19},{value:"默认值为 1，支持大于等于 0 的取值。",paraId:88,tocIndex:19},{value:"例如下图当容器宽度不足以容纳 Node1 和 Node2 设置的初始宽度时，会按照 flexShrink 进行缩放，两个字节点都设置为 1 因此缩放程度一致：",paraId:89,tocIndex:19},{value:"可应用动画",paraId:90,tocIndex:20},{value:"来自 ",paraId:91,tocIndex:20},{value:"MDN 的说明",paraId:91,tocIndex:20},{value:"在考虑这几个属性的作用之前，需要先了解一下 可用空间 available space 这个概念。",paraId:92,tocIndex:20},{value:"Yoga 示例",paraId:93,tocIndex:20},{value:"定义了该元素在主轴上的默认空间大小。",paraId:94,tocIndex:20},{value:"默认值为 NaN。",paraId:95,tocIndex:20},{value:"来自 ",paraId:96,tocIndex:21},{value:"MDN 的说明",paraId:96,tocIndex:21},{value:"flexbox 的一个关键特性是能够设置 flex 元素沿主轴方向和交叉轴方向的对齐方式，以及它们之间的空间分配。",paraId:97,tocIndex:21},{value:"该属性用来使元素在主轴方向上对齐。",paraId:98,tocIndex:22},{value:"支持以下枚举值：",paraId:99,tocIndex:22},{value:"flex-start 默认值",paraId:100,tocIndex:22},{value:"flex-end",paraId:100,tocIndex:22},{value:"center",paraId:100,tocIndex:22},{value:"space-between",paraId:100,tocIndex:22},{value:"space-around",paraId:100,tocIndex:22},{value:"space-evenly",paraId:100,tocIndex:22},{value:"在该",paraId:101,tocIndex:22},{value:"示例",paraId:102,tocIndex:22},{value:"中，展示了 ",paraId:101,tocIndex:22},{value:"center",paraId:101,tocIndex:22},{value:" / ",paraId:101,tocIndex:22},{value:"space-between",paraId:101,tocIndex:22},{value:" / ",paraId:101,tocIndex:22},{value:"space-around",paraId:101,tocIndex:22},{value:" 的效果：",paraId:101,tocIndex:22},{value:"该属性可以使元素在交叉轴方向对齐。",paraId:103,tocIndex:23},{value:"支持以下枚举值：",paraId:104,tocIndex:23},{value:"stretch 默认值",paraId:105,tocIndex:23},{value:"auto",paraId:105,tocIndex:23},{value:"baseline",paraId:105,tocIndex:23},{value:"center",paraId:105,tocIndex:23},{value:"flex-start",paraId:105,tocIndex:23},{value:"flex-end",paraId:105,tocIndex:23},{value:"space-between",paraId:105,tocIndex:23},{value:"space-around",paraId:105,tocIndex:23},{value:"下图为 ",paraId:106,tocIndex:23},{value:"center",paraId:106,tocIndex:23},{value:" 效果：",paraId:106,tocIndex:23},{value:"用于子元素覆盖容器中已有的 ",paraId:107,tocIndex:24},{value:"alignItems",paraId:108,tocIndex:24},{value:" 的值：",paraId:107,tocIndex:24},{value:"在下图中，容器设置的 ",paraId:109,tocIndex:24},{value:"alignItems",paraId:109,tocIndex:24},{value:" 为默认值 ",paraId:109,tocIndex:24},{value:"stretch",paraId:109,tocIndex:24},{value:"，但 Node1 可以通过 ",paraId:109,tocIndex:24},{value:"alignSelf: center",paraId:109,tocIndex:24},{value:" 让自身脱离原本 Node2 和 Node3 的布局效果：",paraId:109,tocIndex:24},{value:"容器如何分配子元素周围空间，只有当 ",paraId:110,tocIndex:25},{value:"flexWrap",paraId:111,tocIndex:25},{value:" 取值为 ",paraId:110,tocIndex:25},{value:"wrap",paraId:110,tocIndex:25},{value:" 时生效：",paraId:110,tocIndex:25},{value:"支持以下枚举值：",paraId:112,tocIndex:25},{value:"stretch",paraId:113,tocIndex:25},{value:"center",paraId:113,tocIndex:25},{value:"flex-start 默认值",paraId:113,tocIndex:25},{value:"flex-end",paraId:113,tocIndex:25},{value:"space-between",paraId:113,tocIndex:25},{value:"space-around",paraId:113,tocIndex:25},{value:"在该",paraId:114,tocIndex:25},{value:"示例",paraId:115,tocIndex:25},{value:"中，依次展示了 ",paraId:114,tocIndex:25},{value:"center",paraId:114,tocIndex:25},{value:" / ",paraId:114,tocIndex:25},{value:"space-between",paraId:114,tocIndex:25},{value:" / ",paraId:114,tocIndex:25},{value:"space-around",paraId:114,tocIndex:25},{value:" 效果：",paraId:114,tocIndex:25},{value:"支持，每个容器内单独计算布局并影响内部的子元素。",paraId:116,tocIndex:27},{value:"暂不支持。如果容器本身不需要被渲染，应该使用 Group。以上例子为了更好地展示容器尺寸，我们选择了 Rect。",paraId:117,tocIndex:28},{value:"setPosition/setLocalPosition()",paraId:118},{value:"一旦容器使用了 Flex，它内部的子元素都应该使用 Flex 相关属性进行定位。虽然不禁止使用 ",paraId:119,tocIndex:29},{value:"setPosition",paraId:119,tocIndex:29},{value:"，但它显然会和布局引擎的计算结果冲突。",paraId:119,tocIndex:29},{value:"支持。但不同属性使用百分比的参考值并不相同。",paraId:120,tocIndex:30},{value:"例如 ",paraId:121,tocIndex:30},{value:"width/height",paraId:122,tocIndex:30},{value:" 相对于父元素的宽高：",paraId:121,tocIndex:30},{value:"{\n    width: '100%',\n    height: '50%'\n}\n",paraId:123,tocIndex:30},{value:"目前 ",paraId:124,tocIndex:31},{value:"Text",paraId:125,tocIndex:31},{value:" 已经支持多行文本，自动换行，但需要用户手动设置 ",paraId:124,tocIndex:31},{value:"wordWrapWidth",paraId:124,tocIndex:31},{value:"，超出后换行。",paraId:124,tocIndex:31},{value:"在 Flex 布局中，当文本作为子元素时，无需用户手动设置文本行宽，只需要开启 ",paraId:126,tocIndex:31},{value:"wordWrap",paraId:126,tocIndex:31},{value:"，配合 ",paraId:126,tocIndex:31},{value:"width",paraId:126,tocIndex:31},{value:" 即可：",paraId:126,tocIndex:31},{value:"const text = new Text({\n    style: {\n        fontFamily: 'PingFang SC',\n        fontSize: 32,\n        fill: '#1890FF',\n        text: '这是测试文字，这是测试文字，这是测试文字，这是测试文字',\n        wordWrap: true, // 开启自动换行\n        width: '100%', // 行宽\n    },\n});\n",paraId:127,tocIndex:31},{value:"在该",paraId:128,tocIndex:31},{value:"示例",paraId:129,tocIndex:31},{value:"中，可以随时改变需要换行文本的行宽，下图为 ",paraId:128,tocIndex:31},{value:"width: '100%'",paraId:128,tocIndex:31},{value:" 的效果：",paraId:128,tocIndex:31},{value:"Flex 布局新增了很多新属性，例如 ",paraId:130,tocIndex:32},{value:"padding",paraId:131,tocIndex:32},{value:" ",paraId:130,tocIndex:32},{value:"margin",paraId:132,tocIndex:32},{value:" 等，在 CSS 中是可以对这些属性进行动画的。",paraId:130,tocIndex:32},{value:"目前支持了部分属性，在该",paraId:133,tocIndex:32},{value:"示例",paraId:134,tocIndex:32},{value:"中可以查看：",paraId:133,tocIndex:32},{value:"node1.animate(\n    [\n        { top: 0, left: 0, width: 100, marginAll: 0, paddingLeft: 0 },\n        { top: 100, left: 100, width: 200, marginAll: 20, paddingLeft: 50 },\n    ],\n    {\n        duration: 1000,\n        easing: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)',\n        fill: 'both',\n        iterations: Infinity,\n        direction: 'alternate-reverse',\n    },\n);\n",paraId:135,tocIndex:32},{value:"需要指定一个平面，然后才能应用 Yoga 这样的 2D 布局引擎。",paraId:136,tocIndex:33},{value:"例如 ",paraId:137,tocIndex:33},{value:"react-three-flex",paraId:137,tocIndex:33},{value:" 中使用 ",paraId:137,tocIndex:33},{value:"xy",paraId:137,tocIndex:33},{value:" ",paraId:137,tocIndex:33},{value:"yz",paraId:137,tocIndex:33},{value:" ",paraId:137,tocIndex:33},{value:"xz",paraId:137,tocIndex:33},{value:"。",paraId:137,tocIndex:33}]}}]);